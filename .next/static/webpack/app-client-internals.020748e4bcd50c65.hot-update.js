/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app-client-internals",{

/***/ "./.yarn/__virtual__/next-virtual-393d91bbcd/0/cache/next-npm-13.0.2-b39abd22d0-f6fea2ee34.zip/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=next%2Fdist%2Fclient%2Fcomponents%2Fapp-router.js&modules=next%2Fdist%2Fclient%2Fcomponents%2Flayout-router.js&modules=next%2Fdist%2Fclient%2Fcomponents%2Frender-from-template-context.js&server=false!":
/*!******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-393d91bbcd/0/cache/next-npm-13.0.2-b39abd22d0-f6fea2ee34.zip/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=next%2Fdist%2Fclient%2Fcomponents%2Fapp-router.js&modules=next%2Fdist%2Fclient%2Fcomponents%2Flayout-router.js&modules=next%2Fdist%2Fclient%2Fcomponents%2Frender-from-template-context.js&server=false! ***!
  \******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! next/dist/client/components/app-router.js */ \"./.yarn/__virtual__/next-virtual-393d91bbcd/0/cache/next-npm-13.0.2-b39abd22d0-f6fea2ee34.zip/node_modules/next/dist/client/components/app-router.js\", 23));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! next/dist/client/components/layout-router.js */ \"./.yarn/__virtual__/next-virtual-393d91bbcd/0/cache/next-npm-13.0.2-b39abd22d0-f6fea2ee34.zip/node_modules/next/dist/client/components/layout-router.js\", 23));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! next/dist/client/components/render-from-template-context.js */ \"./.yarn/__virtual__/next-virtual-393d91bbcd/0/cache/next-npm-13.0.2-b39abd22d0-f6fea2ee34.zip/node_modules/next/dist/client/components/render-from-template-context.js\", 23))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi8ueWFybi9fX3ZpcnR1YWxfXy9uZXh0LXZpcnR1YWwtMzkzZDkxYmJjZC8wL2NhY2hlL25leHQtbnBtLTEzLjAuMi1iMzlhYmQyMmQwLWY2ZmVhMmVlMzQuemlwL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz1uZXh0JTJGZGlzdCUyRmNsaWVudCUyRmNvbXBvbmVudHMlMkZhcHAtcm91dGVyLmpzJm1vZHVsZXM9bmV4dCUyRmRpc3QlMkZjbGllbnQlMkZjb21wb25lbnRzJTJGbGF5b3V0LXJvdXRlci5qcyZtb2R1bGVzPW5leHQlMkZkaXN0JTJGY2xpZW50JTJGY29tcG9uZW50cyUyRnJlbmRlci1mcm9tLXRlbXBsYXRlLWNvbnRleHQuanMmc2VydmVyPWZhbHNlIS5qcyIsIm1hcHBpbmdzIjoiQUFBQSx5U0FBOEU7QUFDOUUsK1NBQWlGO0FBQ2pGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8/ZTk4ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIm5leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9hcHAtcm91dGVyLmpzXCIpO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCJuZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvbGF5b3V0LXJvdXRlci5qc1wiKTtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwibmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlbmRlci1mcm9tLXRlbXBsYXRlLWNvbnRleHQuanNcIikiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./.yarn/__virtual__/next-virtual-393d91bbcd/0/cache/next-npm-13.0.2-b39abd22d0-f6fea2ee34.zip/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=next%2Fdist%2Fclient%2Fcomponents%2Fapp-router.js&modules=next%2Fdist%2Fclient%2Fcomponents%2Flayout-router.js&modules=next%2Fdist%2Fclient%2Fcomponents%2Frender-from-template-context.js&server=false!\n"));

/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-393d91bbcd/0/cache/next-npm-13.0.2-b39abd22d0-f6fea2ee34.zip/node_modules/next/dist/client/components/app-router.js":
/*!************************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-393d91bbcd/0/cache/next-npm-13.0.2-b39abd22d0-f6fea2ee34.zip/node_modules/next/dist/client/components/app-router.js ***!
  \************************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArrayLimit(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nvar __generator = (void 0) && (void 0).__generator || function(thisArg, body) {\n    var f, y, t, g, _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    };\n    return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(_)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n};\nvar _s = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = AppRouter;\nexports.fetchServerResponse = fetchServerResponse;\nvar _async_to_generator = (__webpack_require__(/*! @swc/helpers/lib/_async_to_generator.js */ \"./.yarn/cache/@swc-helpers-npm-0.4.11-d20747f9c8-736857d524.zip/node_modules/@swc/helpers/lib/_async_to_generator.js\")[\"default\"]);\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"./.yarn/cache/@swc-helpers-npm-0.4.11-d20747f9c8-736857d524.zip/node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar _react = _interop_require_wildcard(__webpack_require__(/*! react */ \"./.yarn/__virtual__/next-virtual-393d91bbcd/0/cache/next-npm-13.0.2-b39abd22d0-f6fea2ee34.zip/node_modules/next/dist/compiled/react/index.js\"));\nvar _client = __webpack_require__(/*! next/dist/compiled/react-server-dom-webpack/client */ \"./.yarn/__virtual__/next-virtual-393d91bbcd/0/cache/next-npm-13.0.2-b39abd22d0-f6fea2ee34.zip/node_modules/next/dist/compiled/react-server-dom-webpack/client.js\");\nvar _appRouterContext = __webpack_require__(/*! ../../shared/lib/app-router-context */ \"./.yarn/__virtual__/next-virtual-393d91bbcd/0/cache/next-npm-13.0.2-b39abd22d0-f6fea2ee34.zip/node_modules/next/dist/shared/lib/app-router-context.js\");\nvar _reducer = __webpack_require__(/*! ./reducer */ \"./.yarn/__virtual__/next-virtual-393d91bbcd/0/cache/next-npm-13.0.2-b39abd22d0-f6fea2ee34.zip/node_modules/next/dist/client/components/reducer.js\");\nvar _hooksClientContext = __webpack_require__(/*! ../../shared/lib/hooks-client-context */ \"./.yarn/__virtual__/next-virtual-393d91bbcd/0/cache/next-npm-13.0.2-b39abd22d0-f6fea2ee34.zip/node_modules/next/dist/shared/lib/hooks-client-context.js\");\nvar _useReducerWithDevtools = __webpack_require__(/*! ./use-reducer-with-devtools */ \"./.yarn/__virtual__/next-virtual-393d91bbcd/0/cache/next-npm-13.0.2-b39abd22d0-f6fea2ee34.zip/node_modules/next/dist/client/components/use-reducer-with-devtools.js\");\nvar _errorBoundary = __webpack_require__(/*! ./error-boundary */ \"./.yarn/__virtual__/next-virtual-393d91bbcd/0/cache/next-npm-13.0.2-b39abd22d0-f6fea2ee34.zip/node_modules/next/dist/client/components/error-boundary.js\");\nfunction AppRouter(props) {\n    return /*#__PURE__*/ _react[\"default\"].createElement(_errorBoundary.ErrorBoundary, {\n        errorComponent: _errorBoundary.GlobalErrorComponent\n    }, /*#__PURE__*/ _react[\"default\"].createElement(Router, Object.assign({}, props)));\n}\n_c = AppRouter;\n\"use client\";\nfunction urlToUrlWithoutFlightMarker(url) {\n    var urlWithoutFlightParameters = new URL(url, location.origin);\n    // TODO-APP: handle .rsc for static export case\n    return urlWithoutFlightParameters;\n}\nvar HotReloader =  false ? 0 : (__webpack_require__(/*! ./react-dev-overlay/hot-reloader-client */ \"./.yarn/__virtual__/next-virtual-393d91bbcd/0/cache/next-npm-13.0.2-b39abd22d0-f6fea2ee34.zip/node_modules/next/dist/client/components/react-dev-overlay/hot-reloader-client.js\")[\"default\"]);\nfunction fetchServerResponse(url, flightRouterState, prefetch) {\n    return _fetchServerResponse.apply(this, arguments);\n}\nfunction _fetchServerResponse() {\n    _fetchServerResponse = _async_to_generator(function(url, flightRouterState, prefetch) {\n        var headers, res, canonicalUrl, isFlightResponse, flightData;\n        return __generator(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    headers = {\n                        // Enable flight response\n                        __rsc__: \"1\",\n                        // Provide the current router state\n                        __next_router_state_tree__: JSON.stringify(flightRouterState)\n                    };\n                    if (prefetch) {\n                        // Enable prefetch response\n                        headers.__next_router_prefetch__ = \"1\";\n                    }\n                    return [\n                        4,\n                        fetch(url.toString(), {\n                            headers: headers\n                        })\n                    ];\n                case 1:\n                    res = _state.sent();\n                    canonicalUrl = res.redirected ? urlToUrlWithoutFlightMarker(res.url) : undefined;\n                    isFlightResponse = res.headers.get(\"content-type\") === \"application/octet-stream\";\n                    // If fetch returns something different than flight response handle it like a mpa navigation\n                    if (!isFlightResponse) {\n                        return [\n                            2,\n                            [\n                                res.url,\n                                undefined\n                            ]\n                        ];\n                    }\n                    return [\n                        4,\n                        (0, _client).createFromFetch(Promise.resolve(res))\n                    ];\n                case 2:\n                    flightData = _state.sent();\n                    return [\n                        2,\n                        [\n                            flightData,\n                            canonicalUrl\n                        ]\n                    ];\n            }\n        });\n    });\n    return _fetchServerResponse.apply(this, arguments);\n}\n// Ensure the initialParallelRoutes are not combined because of double-rendering in the browser with Strict Mode.\n// TODO-APP: move this back into AppRouter\nvar initialParallelRoutes =  false ? 0 : new Map();\nvar prefetched = new Set();\n/**\n * The global router that wraps the application components.\n */ function Router(param) {\n    var initialHead = param.initialHead, initialTree = param.initialTree, initialCanonicalUrl = param.initialCanonicalUrl, children = param.children, assetPrefix = param.assetPrefix;\n    _s();\n    var initialState = (0, _react).useMemo(function() {\n        return {\n            tree: initialTree,\n            cache: {\n                data: null,\n                subTreeData: children,\n                parallelRoutes:  false ? 0 : initialParallelRoutes\n            },\n            prefetchCache: new Map(),\n            pushRef: {\n                pendingPush: false,\n                mpaNavigation: false\n            },\n            focusAndScrollRef: {\n                apply: false\n            },\n            canonicalUrl: initialCanonicalUrl + // Hash is read as the initial value for canonicalUrl in the browser\n            // This is safe to do as canonicalUrl can't be rendered, it's only used to control the history updates the useEffect further down.\n            ( true ? window.location.hash : 0)\n        };\n    }, [\n        children,\n        initialCanonicalUrl,\n        initialTree\n    ]);\n    var ref = _slicedToArray((0, _useReducerWithDevtools).useReducerWithReduxDevtools(_reducer.reducer, initialState), 3), ref1 = ref[0], tree = ref1.tree, cache = ref1.cache, prefetchCache = ref1.prefetchCache, pushRef = ref1.pushRef, focusAndScrollRef = ref1.focusAndScrollRef, canonicalUrl = ref1.canonicalUrl, dispatch = ref[1], sync = ref[2];\n    (0, _react).useEffect(function() {\n        // Ensure initialParallelRoutes is cleaned up from memory once it's used.\n        initialParallelRoutes = null;\n    }, []);\n    // Add memoized pathname/query for useSearchParams and usePathname.\n    var ref2 = (0, _react).useMemo(function() {\n        var url = new URL(canonicalUrl,  false ? 0 : window.location.href);\n        return {\n            // This is turned into a readonly class in `useSearchParams`\n            searchParams: url.searchParams,\n            pathname: url.pathname\n        };\n    }, [\n        canonicalUrl\n    ]), searchParams = ref2.searchParams, pathname = ref2.pathname;\n    /**\n   * Server response that only patches the cache and tree.\n   */ var changeByServerResponse = (0, _react).useCallback(function(previousTree, flightData, overrideCanonicalUrl) {\n        dispatch({\n            type: _reducer.ACTION_SERVER_PATCH,\n            flightData: flightData,\n            previousTree: previousTree,\n            overrideCanonicalUrl: overrideCanonicalUrl,\n            cache: {\n                data: null,\n                subTreeData: null,\n                parallelRoutes: new Map()\n            },\n            mutable: {}\n        });\n    }, [\n        dispatch\n    ]);\n    /**\n   * The app router that is exposed through `useRouter`. It's only concerned with dispatching actions to the reducer, does not hold state.\n   */ var appRouter = (0, _react).useMemo(function() {\n        var navigate = function(href, navigateType, forceOptimisticNavigation) {\n            return dispatch({\n                type: _reducer.ACTION_NAVIGATE,\n                url: new URL(href, location.origin),\n                forceOptimisticNavigation: forceOptimisticNavigation,\n                navigateType: navigateType,\n                cache: {\n                    data: null,\n                    subTreeData: null,\n                    parallelRoutes: new Map()\n                },\n                mutable: {}\n            });\n        };\n        var routerInstance = {\n            back: function() {\n                return window.history.back();\n            },\n            forward: function() {\n                return window.history.forward();\n            },\n            // TODO-APP: implement prefetching of flight\n            prefetch: _async_to_generator(function(href) {\n                var url, ref, routerTree, serverResponse, err;\n                return __generator(this, function(_state) {\n                    switch(_state.label){\n                        case 0:\n                            // If prefetch has already been triggered, don't trigger it again.\n                            if (prefetched.has(href)) {\n                                return [\n                                    2\n                                ];\n                            }\n                            prefetched.add(href);\n                            url = new URL(href, location.origin);\n                            _state.label = 1;\n                        case 1:\n                            _state.trys.push([\n                                1,\n                                3,\n                                ,\n                                4\n                            ]);\n                            routerTree = ((ref = window.history.state) == null ? void 0 : ref.tree) || initialTree;\n                            return [\n                                4,\n                                fetchServerResponse(url, routerTree, true)\n                            ];\n                        case 2:\n                            serverResponse = _state.sent();\n                            // @ts-ignore startTransition exists\n                            _react[\"default\"].startTransition(function() {\n                                dispatch({\n                                    type: _reducer.ACTION_PREFETCH,\n                                    url: url,\n                                    tree: routerTree,\n                                    serverResponse: serverResponse\n                                });\n                            });\n                            return [\n                                3,\n                                4\n                            ];\n                        case 3:\n                            err = _state.sent();\n                            console.error(\"PREFETCH ERROR\", err);\n                            return [\n                                3,\n                                4\n                            ];\n                        case 4:\n                            return [\n                                2\n                            ];\n                    }\n                });\n            }),\n            replace: function(href) {\n                var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                // @ts-ignore startTransition exists\n                _react[\"default\"].startTransition(function() {\n                    navigate(href, \"replace\", Boolean(options.forceOptimisticNavigation));\n                });\n            },\n            push: function(href) {\n                var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                // @ts-ignore startTransition exists\n                _react[\"default\"].startTransition(function() {\n                    navigate(href, \"push\", Boolean(options.forceOptimisticNavigation));\n                });\n            },\n            refresh: function() {\n                // @ts-ignore startTransition exists\n                _react[\"default\"].startTransition(function() {\n                    dispatch({\n                        type: _reducer.ACTION_REFRESH,\n                        // TODO-APP: revisit if this needs to be passed.\n                        cache: {\n                            data: null,\n                            subTreeData: null,\n                            parallelRoutes: new Map()\n                        },\n                        mutable: {}\n                    });\n                });\n            }\n        };\n        return routerInstance;\n    }, [\n        dispatch,\n        initialTree\n    ]);\n    (0, _react).useEffect(function() {\n        // When mpaNavigation flag is set do a hard navigation to the new url.\n        if (pushRef.mpaNavigation) {\n            window.location.href = canonicalUrl;\n            return;\n        }\n        // Identifier is shortened intentionally.\n        // __NA is used to identify if the history entry can be handled by the app-router.\n        // __N is used to identify if the history entry can be handled by the old router.\n        var historyState = {\n            __NA: true,\n            tree: tree\n        };\n        if (pushRef.pendingPush) {\n            // This intentionally mutates React state, pushRef is overwritten to ensure additional push/replace calls do not trigger an additional history entry.\n            pushRef.pendingPush = false;\n            window.history.pushState(historyState, \"\", canonicalUrl);\n        } else {\n            window.history.replaceState(historyState, \"\", canonicalUrl);\n        }\n        sync();\n    }, [\n        tree,\n        pushRef,\n        canonicalUrl,\n        sync\n    ]);\n    // Add `window.nd` for debugging purposes.\n    // This is not meant for use in applications as concurrent rendering will affect the cache/tree/router.\n    if (true) {\n        // @ts-ignore this is for debugging\n        window.nd = {\n            router: appRouter,\n            cache: cache,\n            prefetchCache: prefetchCache,\n            tree: tree\n        };\n    }\n    /**\n   * Handle popstate event, this is used to handle back/forward in the browser.\n   * By default dispatches ACTION_RESTORE, however if the history entry was not pushed/replaced by app-router it will reload the page.\n   * That case can happen when the old router injected the history entry.\n   */ var onPopState = (0, _react).useCallback(function(param) {\n        var state = param.state;\n        if (!state) {\n            // TODO-APP: this case only happens when pushState/replaceState was called outside of Next.js. It should probably reload the page in this case.\n            return;\n        }\n        // TODO-APP: this case happens when pushState/replaceState was called outside of Next.js or when the history entry was pushed by the old router.\n        // It reloads the page in this case but we might have to revisit this as the old router ignores it.\n        if (!state.__NA) {\n            window.location.reload();\n            return;\n        }\n        // @ts-ignore useTransition exists\n        // TODO-APP: Ideally the back button should not use startTransition as it should apply the updates synchronously\n        // Without startTransition works if the cache is there for this path\n        _react[\"default\"].startTransition(function() {\n            dispatch({\n                type: _reducer.ACTION_RESTORE,\n                url: new URL(window.location.href),\n                tree: state.tree\n            });\n        });\n    }, [\n        dispatch\n    ]);\n    // Register popstate event to call onPopstate.\n    (0, _react).useEffect(function() {\n        window.addEventListener(\"popstate\", onPopState);\n        return function() {\n            window.removeEventListener(\"popstate\", onPopState);\n        };\n    }, [\n        onPopState\n    ]);\n    return /*#__PURE__*/ _react[\"default\"].createElement(_hooksClientContext.PathnameContext.Provider, {\n        value: pathname\n    }, /*#__PURE__*/ _react[\"default\"].createElement(_hooksClientContext.SearchParamsContext.Provider, {\n        value: searchParams\n    }, /*#__PURE__*/ _react[\"default\"].createElement(_appRouterContext.GlobalLayoutRouterContext.Provider, {\n        value: {\n            changeByServerResponse: changeByServerResponse,\n            tree: tree,\n            focusAndScrollRef: focusAndScrollRef\n        }\n    }, /*#__PURE__*/ _react[\"default\"].createElement(_appRouterContext.AppRouterContext.Provider, {\n        value: appRouter\n    }, /*#__PURE__*/ _react[\"default\"].createElement(_appRouterContext.LayoutRouterContext.Provider, {\n        value: {\n            childNodes: cache.parallelRoutes,\n            tree: tree,\n            // Root node always has `url`\n            // Provided in AppTreeContext to ensure it can be overwritten in layout-router\n            url: canonicalUrl\n        }\n    }, HotReloader ? /*#__PURE__*/ _react[\"default\"].createElement(HotReloader, {\n        assetPrefix: assetPrefix\n    }, initialHead, cache.subTreeData) : /*#__PURE__*/ _react[\"default\"].createElement(_react[\"default\"].Fragment, null, initialHead, cache.subTreeData))))));\n}\n_s(Router, \"yWCtvIH/OEoTmoHU249b5/prOjk=\");\n_c1 = Router;\nif ((typeof exports[\"default\"] === \"function\" || typeof exports[\"default\"] === \"object\" && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === \"undefined\") {\n    Object.defineProperty(exports[\"default\"], \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports[\"default\"], exports);\n    module.exports = exports[\"default\"];\n} //# sourceMappingURL=app-router.js.map\nvar _c, _c1;\n$RefreshReg$(_c, \"AppRouter\");\n$RefreshReg$(_c1, \"Router\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi8ueWFybi9fX3ZpcnR1YWxfXy9uZXh0LXZpcnR1YWwtMzkzZDkxYmJjZC8wL2NhY2hlL25leHQtbnBtLTEzLjAuMi1iMzlhYmQyMmQwLWY2ZmVhMmVlMzQuemlwL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvYXBwLXJvdXRlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFDYTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsa0JBQWUsR0FBR0c7QUFDbEJILDJCQUEyQixHQUFHSTtBQUM5QixJQUFJQyxzQkFBc0JDLHVNQUEwRDtBQUNwRixJQUFJQyw0QkFBNEJELG1OQUFnRTtBQUNoRyxJQUFJRSxTQUFTRCwwQkFBMEJELG1CQUFPQSxDQUFDLDJKQUFPO0FBQ3RELElBQUlHLFVBQVVILG1CQUFPQSxDQUFDLDROQUFvRDtBQUMxRSxJQUFJSSxvQkFBb0JKLG1CQUFPQSxDQUFDLGtNQUFxQztBQUNyRSxJQUFJSyxXQUFXTCxtQkFBT0EsQ0FBQyxvS0FBVztBQUNsQyxJQUFJTSxzQkFBc0JOLG1CQUFPQSxDQUFDLHNNQUF1QztBQUN6RSxJQUFJTywwQkFBMEJQLG1CQUFPQSxDQUFDLHdNQUE2QjtBQUNuRSxJQUFJUSxpQkFBaUJSLG1CQUFPQSxDQUFDLGtMQUFrQjtBQUMvQyxTQUFTSCxVQUFVWSxLQUFLLEVBQUU7SUFDdEIsT0FBTyxXQUFXLEdBQUdQLE1BQU9OLENBQUFBLFVBQU8sQ0FBQ2MsYUFBYSxDQUFDRixlQUFlRyxhQUFhLEVBQUU7UUFDNUVDLGdCQUFnQkosZUFBZUssb0JBQW9CO0lBQ3ZELEdBQUcsV0FBVyxHQUFHWCxNQUFPTixD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QUNsSjtHQTlPYS9DO01BQUFBO0FBZ1BiLElBQUksQ0FBQyxPQUFPcEIsT0FBUUUsQ0FBQUEsVUFBTyxLQUFLLGNBQWUsT0FBT0YsT0FBUUUsQ0FBQUEsVUFBTyxLQUFLLFlBQVlGLE9BQVFFLENBQUFBLFVBQU8sS0FBSyxJQUFJLEtBQU0sT0FBT0YsT0FBUUUsQ0FBQUEsVUFBTyxDQUFDc0ksVUFBVSxLQUFLLGFBQWE7SUFDcksxSSxPQUFPQyxjQUFjLENBQUNDLE9BQVFFLENBQUFBLFVBQU8sRUFBRSxjQUFjO1FBQUVELE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPdUIsTUFBTSxDQUFDckIsT0FBUUUsQ0FBQUEsVUFBTyxFQUFFRjtJQUMvQnlJLE9BQU96SSxPQUFPLEdBQUdBLE9BQVFFLENBQUFBLFVBQU87QUFDbEMsQ0FBQyxDQUVELHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi8ueWFybi9fX3ZpcnR1YWxfXy9uZXh0LXZpcnR1YWwtMzkzZDkxYmJjZC8wL2NhY2hlL25leHQtbnBtLTEzLjAuMi1iMzlhYmQyMmQwLWY2ZmVhMmVlMzQuemlwL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvYXBwLXJvdXRlci5qcz82OWY1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBBcHBSb3V0ZXI7XG5leHBvcnRzLmZldGNoU2VydmVyUmVzcG9uc2UgPSBmZXRjaFNlcnZlclJlc3BvbnNlO1xudmFyIF9hc3luY190b19nZW5lcmF0b3IgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9fYXN5bmNfdG9fZ2VuZXJhdG9yLmpzXCIpLmRlZmF1bHQ7XG52YXIgX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQuanNcIikuZGVmYXVsdDtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX2NsaWVudCA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3Qtc2VydmVyLWRvbS13ZWJwYWNrL2NsaWVudFwiKTtcbnZhciBfYXBwUm91dGVyQ29udGV4dCA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dFwiKTtcbnZhciBfcmVkdWNlciA9IHJlcXVpcmUoXCIuL3JlZHVjZXJcIik7XG52YXIgX2hvb2tzQ2xpZW50Q29udGV4dCA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvbGliL2hvb2tzLWNsaWVudC1jb250ZXh0XCIpO1xudmFyIF91c2VSZWR1Y2VyV2l0aERldnRvb2xzID0gcmVxdWlyZShcIi4vdXNlLXJlZHVjZXItd2l0aC1kZXZ0b29sc1wiKTtcbnZhciBfZXJyb3JCb3VuZGFyeSA9IHJlcXVpcmUoXCIuL2Vycm9yLWJvdW5kYXJ5XCIpO1xuZnVuY3Rpb24gQXBwUm91dGVyKHByb3BzKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfZXJyb3JCb3VuZGFyeS5FcnJvckJvdW5kYXJ5LCB7XG4gICAgICAgIGVycm9yQ29tcG9uZW50OiBfZXJyb3JCb3VuZGFyeS5HbG9iYWxFcnJvckNvbXBvbmVudFxuICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChSb3V0ZXIsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzKSkpO1xufVxuJ3VzZSBjbGllbnQnO1xuZnVuY3Rpb24gdXJsVG9VcmxXaXRob3V0RmxpZ2h0TWFya2VyKHVybCkge1xuICAgIGNvbnN0IHVybFdpdGhvdXRGbGlnaHRQYXJhbWV0ZXJzID0gbmV3IFVSTCh1cmwsIGxvY2F0aW9uLm9yaWdpbik7XG4gICAgLy8gVE9ETy1BUFA6IGhhbmRsZSAucnNjIGZvciBzdGF0aWMgZXhwb3J0IGNhc2VcbiAgICByZXR1cm4gdXJsV2l0aG91dEZsaWdodFBhcmFtZXRlcnM7XG59XG5jb25zdCBIb3RSZWxvYWRlciA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgPyBudWxsIDogcmVxdWlyZSgnLi9yZWFjdC1kZXYtb3ZlcmxheS9ob3QtcmVsb2FkZXItY2xpZW50JykuZGVmYXVsdDtcbmZ1bmN0aW9uIGZldGNoU2VydmVyUmVzcG9uc2UodXJsLCBmbGlnaHRSb3V0ZXJTdGF0ZSwgcHJlZmV0Y2gpIHtcbiAgICByZXR1cm4gX2ZldGNoU2VydmVyUmVzcG9uc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIF9mZXRjaFNlcnZlclJlc3BvbnNlKCkge1xuICAgIF9mZXRjaFNlcnZlclJlc3BvbnNlID0gX2FzeW5jX3RvX2dlbmVyYXRvcihmdW5jdGlvbioodXJsLCBmbGlnaHRSb3V0ZXJTdGF0ZSwgcHJlZmV0Y2gpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgIC8vIEVuYWJsZSBmbGlnaHQgcmVzcG9uc2VcbiAgICAgICAgICAgIF9fcnNjX186ICcxJyxcbiAgICAgICAgICAgIC8vIFByb3ZpZGUgdGhlIGN1cnJlbnQgcm91dGVyIHN0YXRlXG4gICAgICAgICAgICBfX25leHRfcm91dGVyX3N0YXRlX3RyZWVfXzogSlNPTi5zdHJpbmdpZnkoZmxpZ2h0Um91dGVyU3RhdGUpXG4gICAgICAgIH07XG4gICAgICAgIGlmIChwcmVmZXRjaCkge1xuICAgICAgICAgICAgLy8gRW5hYmxlIHByZWZldGNoIHJlc3BvbnNlXG4gICAgICAgICAgICBoZWFkZXJzLl9fbmV4dF9yb3V0ZXJfcHJlZmV0Y2hfXyA9ICcxJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXMgPSB5aWVsZCBmZXRjaCh1cmwudG9TdHJpbmcoKSwge1xuICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2Fub25pY2FsVXJsID0gcmVzLnJlZGlyZWN0ZWQgPyB1cmxUb1VybFdpdGhvdXRGbGlnaHRNYXJrZXIocmVzLnVybCkgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGlzRmxpZ2h0UmVzcG9uc2UgPSByZXMuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpID09PSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJztcbiAgICAgICAgLy8gSWYgZmV0Y2ggcmV0dXJucyBzb21ldGhpbmcgZGlmZmVyZW50IHRoYW4gZmxpZ2h0IHJlc3BvbnNlIGhhbmRsZSBpdCBsaWtlIGEgbXBhIG5hdmlnYXRpb25cbiAgICAgICAgaWYgKCFpc0ZsaWdodFJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHJlcy51cmwsXG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSB0aGUgYGZldGNoYCByZWFkYWJsZSBzdHJlYW0gdGhhdCBjYW4gYmUgdW53cmFwcGVkIGJ5IGBSZWFjdC51c2VgLlxuICAgICAgICBjb25zdCBmbGlnaHREYXRhID0geWllbGQgKDAsIF9jbGllbnQpLmNyZWF0ZUZyb21GZXRjaChQcm9taXNlLnJlc29sdmUocmVzKSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBmbGlnaHREYXRhLFxuICAgICAgICAgICAgY2Fub25pY2FsVXJsXG4gICAgICAgIF07XG4gICAgfSk7XG4gICAgcmV0dXJuIF9mZXRjaFNlcnZlclJlc3BvbnNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG4vLyBFbnN1cmUgdGhlIGluaXRpYWxQYXJhbGxlbFJvdXRlcyBhcmUgbm90IGNvbWJpbmVkIGJlY2F1c2Ugb2YgZG91YmxlLXJlbmRlcmluZyBpbiB0aGUgYnJvd3NlciB3aXRoIFN0cmljdCBNb2RlLlxuLy8gVE9ETy1BUFA6IG1vdmUgdGhpcyBiYWNrIGludG8gQXBwUm91dGVyXG5sZXQgaW5pdGlhbFBhcmFsbGVsUm91dGVzID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogbmV3IE1hcCgpO1xuY29uc3QgcHJlZmV0Y2hlZCA9IG5ldyBTZXQoKTtcbi8qKlxuICogVGhlIGdsb2JhbCByb3V0ZXIgdGhhdCB3cmFwcyB0aGUgYXBwbGljYXRpb24gY29tcG9uZW50cy5cbiAqLyBmdW5jdGlvbiBSb3V0ZXIoeyBpbml0aWFsSGVhZCAsIGluaXRpYWxUcmVlICwgaW5pdGlhbENhbm9uaWNhbFVybCAsIGNoaWxkcmVuICwgYXNzZXRQcmVmaXggIH0pIHtcbiAgICBjb25zdCBpbml0aWFsU3RhdGUgPSAoMCwgX3JlYWN0KS51c2VNZW1vKCgpPT57XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0cmVlOiBpbml0aWFsVHJlZSxcbiAgICAgICAgICAgIGNhY2hlOiB7XG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBzdWJUcmVlRGF0YTogY2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gbmV3IE1hcCgpIDogaW5pdGlhbFBhcmFsbGVsUm91dGVzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJlZmV0Y2hDYWNoZTogbmV3IE1hcCgpLFxuICAgICAgICAgICAgcHVzaFJlZjoge1xuICAgICAgICAgICAgICAgIHBlbmRpbmdQdXNoOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBtcGFOYXZpZ2F0aW9uOiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmOiB7XG4gICAgICAgICAgICAgICAgYXBwbHk6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2Fub25pY2FsVXJsOiBpbml0aWFsQ2Fub25pY2FsVXJsICsgLy8gSGFzaCBpcyByZWFkIGFzIHRoZSBpbml0aWFsIHZhbHVlIGZvciBjYW5vbmljYWxVcmwgaW4gdGhlIGJyb3dzZXJcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgc2FmZSB0byBkbyBhcyBjYW5vbmljYWxVcmwgY2FuJ3QgYmUgcmVuZGVyZWQsIGl0J3Mgb25seSB1c2VkIHRvIGNvbnRyb2wgdGhlIGhpc3RvcnkgdXBkYXRlcyB0aGUgdXNlRWZmZWN0IGZ1cnRoZXIgZG93bi5cbiAgICAgICAgICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5sb2NhdGlvbi5oYXNoIDogJycpXG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgaW5pdGlhbENhbm9uaWNhbFVybCxcbiAgICAgICAgaW5pdGlhbFRyZWVcbiAgICBdKTtcbiAgICBjb25zdCBbeyB0cmVlICwgY2FjaGUgLCBwcmVmZXRjaENhY2hlICwgcHVzaFJlZiAsIGZvY3VzQW5kU2Nyb2xsUmVmICwgY2Fub25pY2FsVXJsICB9LCBkaXNwYXRjaCwgc3luYywgXSA9ICgwLCBfdXNlUmVkdWNlcldpdGhEZXZ0b29scykudXNlUmVkdWNlcldpdGhSZWR1eERldnRvb2xzKF9yZWR1Y2VyLnJlZHVjZXIsIGluaXRpYWxTdGF0ZSk7XG4gICAgKDAsIF9yZWFjdCkudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIC8vIEVuc3VyZSBpbml0aWFsUGFyYWxsZWxSb3V0ZXMgaXMgY2xlYW5lZCB1cCBmcm9tIG1lbW9yeSBvbmNlIGl0J3MgdXNlZC5cbiAgICAgICAgaW5pdGlhbFBhcmFsbGVsUm91dGVzID0gbnVsbDtcbiAgICB9LCBbXSk7XG4gICAgLy8gQWRkIG1lbW9pemVkIHBhdGhuYW1lL3F1ZXJ5IGZvciB1c2VTZWFyY2hQYXJhbXMgYW5kIHVzZVBhdGhuYW1lLlxuICAgIGNvbnN0IHsgc2VhcmNoUGFyYW1zICwgcGF0aG5hbWUgIH0gPSAoMCwgX3JlYWN0KS51c2VNZW1vKCgpPT57XG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoY2Fub25pY2FsVXJsLCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/ICdodHRwOi8vbicgOiB3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHR1cm5lZCBpbnRvIGEgcmVhZG9ubHkgY2xhc3MgaW4gYHVzZVNlYXJjaFBhcmFtc2BcbiAgICAgICAgICAgIHNlYXJjaFBhcmFtczogdXJsLnNlYXJjaFBhcmFtcyxcbiAgICAgICAgICAgIHBhdGhuYW1lOiB1cmwucGF0aG5hbWVcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIGNhbm9uaWNhbFVybFxuICAgIF0pO1xuICAgIC8qKlxuICAgKiBTZXJ2ZXIgcmVzcG9uc2UgdGhhdCBvbmx5IHBhdGNoZXMgdGhlIGNhY2hlIGFuZCB0cmVlLlxuICAgKi8gY29uc3QgY2hhbmdlQnlTZXJ2ZXJSZXNwb25zZSA9ICgwLCBfcmVhY3QpLnVzZUNhbGxiYWNrKChwcmV2aW91c1RyZWUsIGZsaWdodERhdGEsIG92ZXJyaWRlQ2Fub25pY2FsVXJsKT0+e1xuICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiBfcmVkdWNlci5BQ1RJT05fU0VSVkVSX1BBVENILFxuICAgICAgICAgICAgZmxpZ2h0RGF0YSxcbiAgICAgICAgICAgIHByZXZpb3VzVHJlZSxcbiAgICAgICAgICAgIG92ZXJyaWRlQ2Fub25pY2FsVXJsLFxuICAgICAgICAgICAgY2FjaGU6IHtcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIHN1YlRyZWVEYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIHBhcmFsbGVsUm91dGVzOiBuZXcgTWFwKClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtdXRhYmxlOiB7fVxuICAgICAgICB9KTtcbiAgICB9LCBbXG4gICAgICAgIGRpc3BhdGNoXG4gICAgXSk7XG4gICAgLyoqXG4gICAqIFRoZSBhcHAgcm91dGVyIHRoYXQgaXMgZXhwb3NlZCB0aHJvdWdoIGB1c2VSb3V0ZXJgLiBJdCdzIG9ubHkgY29uY2VybmVkIHdpdGggZGlzcGF0Y2hpbmcgYWN0aW9ucyB0byB0aGUgcmVkdWNlciwgZG9lcyBub3QgaG9sZCBzdGF0ZS5cbiAgICovIGNvbnN0IGFwcFJvdXRlciA9ICgwLCBfcmVhY3QpLnVzZU1lbW8oKCk9PntcbiAgICAgICAgY29uc3QgbmF2aWdhdGUgPSAoaHJlZiwgbmF2aWdhdGVUeXBlLCBmb3JjZU9wdGltaXN0aWNOYXZpZ2F0aW9uKT0+e1xuICAgICAgICAgICAgcmV0dXJuIGRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBfcmVkdWNlci5BQ1RJT05fTkFWSUdBVEUsXG4gICAgICAgICAgICAgICAgdXJsOiBuZXcgVVJMKGhyZWYsIGxvY2F0aW9uLm9yaWdpbiksXG4gICAgICAgICAgICAgICAgZm9yY2VPcHRpbWlzdGljTmF2aWdhdGlvbixcbiAgICAgICAgICAgICAgICBuYXZpZ2F0ZVR5cGUsXG4gICAgICAgICAgICAgICAgY2FjaGU6IHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgc3ViVHJlZURhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFsbGVsUm91dGVzOiBuZXcgTWFwKClcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG11dGFibGU6IHt9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgcm91dGVySW5zdGFuY2UgPSB7XG4gICAgICAgICAgICBiYWNrOiAoKT0+d2luZG93Lmhpc3RvcnkuYmFjaygpLFxuICAgICAgICAgICAgZm9yd2FyZDogKCk9PndpbmRvdy5oaXN0b3J5LmZvcndhcmQoKSxcbiAgICAgICAgICAgIC8vIFRPRE8tQVBQOiBpbXBsZW1lbnQgcHJlZmV0Y2hpbmcgb2YgZmxpZ2h0XG4gICAgICAgICAgICBwcmVmZXRjaDogX2FzeW5jX3RvX2dlbmVyYXRvcihmdW5jdGlvbiooaHJlZikge1xuICAgICAgICAgICAgICAgIC8vIElmIHByZWZldGNoIGhhcyBhbHJlYWR5IGJlZW4gdHJpZ2dlcmVkLCBkb24ndCB0cmlnZ2VyIGl0IGFnYWluLlxuICAgICAgICAgICAgICAgIGlmIChwcmVmZXRjaGVkLmhhcyhocmVmKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZWZldGNoZWQuYWRkKGhyZWYpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoaHJlZiwgbG9jYXRpb24ub3JpZ2luKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVmO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByb3V0ZXJUcmVlID0gKChyZWYgPSB3aW5kb3cuaGlzdG9yeS5zdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IHJlZi50cmVlKSB8fCBpbml0aWFsVHJlZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETy1BUFA6IGhhbmRsZSBjYXNlIHdoZXJlIGhpc3Rvcnkuc3RhdGUgaXMgbm90IHRoZSBuZXcgcm91dGVyIGhpc3RvcnkgZW50cnlcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VydmVyUmVzcG9uc2UgPSB5aWVsZCBmZXRjaFNlcnZlclJlc3BvbnNlKHVybCwgLy8gaW5pdGlhbFRyZWUgaXMgdXNlZCB3aGVuIGhpc3Rvcnkuc3RhdGUudHJlZSBpcyBtaXNzaW5nIGJlY2F1c2UgdGhlIGhpc3Rvcnkgc3RhdGUgaXMgc2V0IGluIGB1c2VFZmZlY3RgIGJlbG93LCBpdCBiZWluZyBtaXNzaW5nIG1lYW5zIHRoaXMgaXMgdGhlIGh5ZHJhdGlvbiBjYXNlLlxuICAgICAgICAgICAgICAgICAgICByb3V0ZXJUcmVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBzdGFydFRyYW5zaXRpb24gZXhpc3RzXG4gICAgICAgICAgICAgICAgICAgIF9yZWFjdC5kZWZhdWx0LnN0YXJ0VHJhbnNpdGlvbigoKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IF9yZWR1Y2VyLkFDVElPTl9QUkVGRVRDSCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJlZTogcm91dGVyVHJlZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJSZXNwb25zZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdQUkVGRVRDSCBFUlJPUicsIGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICByZXBsYWNlOiAoaHJlZiwgb3B0aW9ucyA9IHt9KT0+e1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgc3RhcnRUcmFuc2l0aW9uIGV4aXN0c1xuICAgICAgICAgICAgICAgIF9yZWFjdC5kZWZhdWx0LnN0YXJ0VHJhbnNpdGlvbigoKT0+e1xuICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZShocmVmLCAncmVwbGFjZScsIEJvb2xlYW4ob3B0aW9ucy5mb3JjZU9wdGltaXN0aWNOYXZpZ2F0aW9uKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHVzaDogKGhyZWYsIG9wdGlvbnMgPSB7fSk9PntcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIHN0YXJ0VHJhbnNpdGlvbiBleGlzdHNcbiAgICAgICAgICAgICAgICBfcmVhY3QuZGVmYXVsdC5zdGFydFRyYW5zaXRpb24oKCk9PntcbiAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGUoaHJlZiwgJ3B1c2gnLCBCb29sZWFuKG9wdGlvbnMuZm9yY2VPcHRpbWlzdGljTmF2aWdhdGlvbikpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlZnJlc2g6ICgpPT57XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBzdGFydFRyYW5zaXRpb24gZXhpc3RzXG4gICAgICAgICAgICAgICAgX3JlYWN0LmRlZmF1bHQuc3RhcnRUcmFuc2l0aW9uKCgpPT57XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IF9yZWR1Y2VyLkFDVElPTl9SRUZSRVNILFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETy1BUFA6IHJldmlzaXQgaWYgdGhpcyBuZWVkcyB0byBiZSBwYXNzZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViVHJlZURhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGFibGU6IHt9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcm91dGVySW5zdGFuY2U7XG4gICAgfSwgW1xuICAgICAgICBkaXNwYXRjaCxcbiAgICAgICAgaW5pdGlhbFRyZWVcbiAgICBdKTtcbiAgICAoMCwgX3JlYWN0KS51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgLy8gV2hlbiBtcGFOYXZpZ2F0aW9uIGZsYWcgaXMgc2V0IGRvIGEgaGFyZCBuYXZpZ2F0aW9uIHRvIHRoZSBuZXcgdXJsLlxuICAgICAgICBpZiAocHVzaFJlZi5tcGFOYXZpZ2F0aW9uKSB7XG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGNhbm9uaWNhbFVybDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZGVudGlmaWVyIGlzIHNob3J0ZW5lZCBpbnRlbnRpb25hbGx5LlxuICAgICAgICAvLyBfX05BIGlzIHVzZWQgdG8gaWRlbnRpZnkgaWYgdGhlIGhpc3RvcnkgZW50cnkgY2FuIGJlIGhhbmRsZWQgYnkgdGhlIGFwcC1yb3V0ZXIuXG4gICAgICAgIC8vIF9fTiBpcyB1c2VkIHRvIGlkZW50aWZ5IGlmIHRoZSBoaXN0b3J5IGVudHJ5IGNhbiBiZSBoYW5kbGVkIGJ5IHRoZSBvbGQgcm91dGVyLlxuICAgICAgICBjb25zdCBoaXN0b3J5U3RhdGUgPSB7XG4gICAgICAgICAgICBfX05BOiB0cnVlLFxuICAgICAgICAgICAgdHJlZVxuICAgICAgICB9O1xuICAgICAgICBpZiAocHVzaFJlZi5wZW5kaW5nUHVzaCkge1xuICAgICAgICAgICAgLy8gVGhpcyBpbnRlbnRpb25hbGx5IG11dGF0ZXMgUmVhY3Qgc3RhdGUsIHB1c2hSZWYgaXMgb3ZlcndyaXR0ZW4gdG8gZW5zdXJlIGFkZGl0aW9uYWwgcHVzaC9yZXBsYWNlIGNhbGxzIGRvIG5vdCB0cmlnZ2VyIGFuIGFkZGl0aW9uYWwgaGlzdG9yeSBlbnRyeS5cbiAgICAgICAgICAgIHB1c2hSZWYucGVuZGluZ1B1c2ggPSBmYWxzZTtcbiAgICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZShoaXN0b3J5U3RhdGUsICcnLCBjYW5vbmljYWxVcmwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKGhpc3RvcnlTdGF0ZSwgJycsIGNhbm9uaWNhbFVybCk7XG4gICAgICAgIH1cbiAgICAgICAgc3luYygpO1xuICAgIH0sIFtcbiAgICAgICAgdHJlZSxcbiAgICAgICAgcHVzaFJlZixcbiAgICAgICAgY2Fub25pY2FsVXJsLFxuICAgICAgICBzeW5jXG4gICAgXSk7XG4gICAgLy8gQWRkIGB3aW5kb3cubmRgIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMuXG4gICAgLy8gVGhpcyBpcyBub3QgbWVhbnQgZm9yIHVzZSBpbiBhcHBsaWNhdGlvbnMgYXMgY29uY3VycmVudCByZW5kZXJpbmcgd2lsbCBhZmZlY3QgdGhlIGNhY2hlL3RyZWUvcm91dGVyLlxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBAdHMtaWdub3JlIHRoaXMgaXMgZm9yIGRlYnVnZ2luZ1xuICAgICAgICB3aW5kb3cubmQgPSB7XG4gICAgICAgICAgICByb3V0ZXI6IGFwcFJvdXRlcixcbiAgICAgICAgICAgIGNhY2hlLFxuICAgICAgICAgICAgcHJlZmV0Y2hDYWNoZSxcbiAgICAgICAgICAgIHRyZWVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAqIEhhbmRsZSBwb3BzdGF0ZSBldmVudCwgdGhpcyBpcyB1c2VkIHRvIGhhbmRsZSBiYWNrL2ZvcndhcmQgaW4gdGhlIGJyb3dzZXIuXG4gICAqIEJ5IGRlZmF1bHQgZGlzcGF0Y2hlcyBBQ1RJT05fUkVTVE9SRSwgaG93ZXZlciBpZiB0aGUgaGlzdG9yeSBlbnRyeSB3YXMgbm90IHB1c2hlZC9yZXBsYWNlZCBieSBhcHAtcm91dGVyIGl0IHdpbGwgcmVsb2FkIHRoZSBwYWdlLlxuICAgKiBUaGF0IGNhc2UgY2FuIGhhcHBlbiB3aGVuIHRoZSBvbGQgcm91dGVyIGluamVjdGVkIHRoZSBoaXN0b3J5IGVudHJ5LlxuICAgKi8gY29uc3Qgb25Qb3BTdGF0ZSA9ICgwLCBfcmVhY3QpLnVzZUNhbGxiYWNrKCh7IHN0YXRlICB9KT0+e1xuICAgICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgICAgICAvLyBUT0RPLUFQUDogdGhpcyBjYXNlIG9ubHkgaGFwcGVucyB3aGVuIHB1c2hTdGF0ZS9yZXBsYWNlU3RhdGUgd2FzIGNhbGxlZCBvdXRzaWRlIG9mIE5leHQuanMuIEl0IHNob3VsZCBwcm9iYWJseSByZWxvYWQgdGhlIHBhZ2UgaW4gdGhpcyBjYXNlLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8tQVBQOiB0aGlzIGNhc2UgaGFwcGVucyB3aGVuIHB1c2hTdGF0ZS9yZXBsYWNlU3RhdGUgd2FzIGNhbGxlZCBvdXRzaWRlIG9mIE5leHQuanMgb3Igd2hlbiB0aGUgaGlzdG9yeSBlbnRyeSB3YXMgcHVzaGVkIGJ5IHRoZSBvbGQgcm91dGVyLlxuICAgICAgICAvLyBJdCByZWxvYWRzIHRoZSBwYWdlIGluIHRoaXMgY2FzZSBidXQgd2UgbWlnaHQgaGF2ZSB0byByZXZpc2l0IHRoaXMgYXMgdGhlIG9sZCByb3V0ZXIgaWdub3JlcyBpdC5cbiAgICAgICAgaWYgKCFzdGF0ZS5fX05BKSB7XG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQHRzLWlnbm9yZSB1c2VUcmFuc2l0aW9uIGV4aXN0c1xuICAgICAgICAvLyBUT0RPLUFQUDogSWRlYWxseSB0aGUgYmFjayBidXR0b24gc2hvdWxkIG5vdCB1c2Ugc3RhcnRUcmFuc2l0aW9uIGFzIGl0IHNob3VsZCBhcHBseSB0aGUgdXBkYXRlcyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIFdpdGhvdXQgc3RhcnRUcmFuc2l0aW9uIHdvcmtzIGlmIHRoZSBjYWNoZSBpcyB0aGVyZSBmb3IgdGhpcyBwYXRoXG4gICAgICAgIF9yZWFjdC5kZWZhdWx0LnN0YXJ0VHJhbnNpdGlvbigoKT0+e1xuICAgICAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IF9yZWR1Y2VyLkFDVElPTl9SRVNUT1JFLFxuICAgICAgICAgICAgICAgIHVybDogbmV3IFVSTCh3aW5kb3cubG9jYXRpb24uaHJlZiksXG4gICAgICAgICAgICAgICAgdHJlZTogc3RhdGUudHJlZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sIFtcbiAgICAgICAgZGlzcGF0Y2hcbiAgICBdKTtcbiAgICAvLyBSZWdpc3RlciBwb3BzdGF0ZSBldmVudCB0byBjYWxsIG9uUG9wc3RhdGUuXG4gICAgKDAsIF9yZWFjdCkudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIG9uUG9wU3RhdGUpO1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIG9uUG9wU3RhdGUpO1xuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgb25Qb3BTdGF0ZVxuICAgIF0pO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX2hvb2tzQ2xpZW50Q29udGV4dC5QYXRobmFtZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IHBhdGhuYW1lXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9ob29rc0NsaWVudENvbnRleHQuU2VhcmNoUGFyYW1zQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogc2VhcmNoUGFyYW1zXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9hcHBSb3V0ZXJDb250ZXh0Lkdsb2JhbExheW91dFJvdXRlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIGNoYW5nZUJ5U2VydmVyUmVzcG9uc2UsXG4gICAgICAgICAgICB0cmVlLFxuICAgICAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWZcbiAgICAgICAgfVxuICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfYXBwUm91dGVyQ29udGV4dC5BcHBSb3V0ZXJDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiBhcHBSb3V0ZXJcbiAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX2FwcFJvdXRlckNvbnRleHQuTGF5b3V0Um91dGVyQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgY2hpbGROb2RlczogY2FjaGUucGFyYWxsZWxSb3V0ZXMsXG4gICAgICAgICAgICB0cmVlOiB0cmVlLFxuICAgICAgICAgICAgLy8gUm9vdCBub2RlIGFsd2F5cyBoYXMgYHVybGBcbiAgICAgICAgICAgIC8vIFByb3ZpZGVkIGluIEFwcFRyZWVDb250ZXh0IHRvIGVuc3VyZSBpdCBjYW4gYmUgb3ZlcndyaXR0ZW4gaW4gbGF5b3V0LXJvdXRlclxuICAgICAgICAgICAgdXJsOiBjYW5vbmljYWxVcmxcbiAgICAgICAgfVxuICAgIH0sIEhvdFJlbG9hZGVyID8gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEhvdFJlbG9hZGVyLCB7XG4gICAgICAgIGFzc2V0UHJlZml4OiBhc3NldFByZWZpeFxuICAgIH0sIGluaXRpYWxIZWFkLCBjYWNoZS5zdWJUcmVlRGF0YSkgOiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsIGluaXRpYWxIZWFkLCBjYWNoZS5zdWJUcmVlRGF0YSkpKSkpKTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwLXJvdXRlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWZhdWx0IiwiQXBwUm91dGVyIiwiZmV0Y2hTZXJ2ZXJSZXNwb25zZSIsIl9hc3luY190b19nZW5lcmF0b3IiLCJyZXF1aXJlIiwiX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCIsIl9yZWFjdCIsIl9jbGllbnQiLCJfYXBwUm91dGVyQ29udGV4dCIsIl9yZWR1Y2VyIiwiX2hvb2tzQ2xpZW50Q29udGV4dCIsIl91c2VSZWR1Y2VyV2l0aERldnRvb2xzIiwiX2Vycm9yQm91bmRhcnkiLCJwcm9wcyIsImNyZWF0ZUVsZW1lbnQiLCJFcnJvckJvdW5kYXJ5IiwiZXJyb3JDb21wb25lbnQiLCJHbG9iYWxFcnJvckNvbXBvbmVudCIsIlJvdXRlciIsImFzc2lnbiIsInVybFRvVXJsV2l0aG91dEZsaWdodE1hcmtlciIsInVybCIsInVybFdpdGhvdXRGbGlnaHRQYXJhbWV0ZXJzIiwiVVJMIiwibG9jYXRpb24iLCJvcmlnaW4iLCJIb3RSZWxvYWRlciIsInByb2Nlc3MiLCJmbGlnaHRSb3V0ZXJTdGF0ZSIsInByZWZldGNoIiwiX2ZldGNoU2VydmVyUmVzcG9uc2UiLCJhcHBseSIsImFyZ3VtZW50cyIsImhlYWRlcnMiLCJyZXMiLCJjYW5vbmljYWxVcmwiLCJpc0ZsaWdodFJlc3BvbnNlIiwiZmxpZ2h0RGF0YSIsIl9fcnNjX18iLCJfX25leHRfcm91dGVyX3N0YXRlX3RyZWVfXyIsIkpTT04iLCJzdHJpbmdpZnkiLCJfX25leHRfcm91dGVyX3ByZWZldGNoX18iLCJmZXRjaCIsInRvU3RyaW5nIiwicmVkaXJlY3RlZCIsInVuZGVmaW5lZCIsImdldCIsImNyZWF0ZUZyb21GZXRjaCIsIlByb21pc2UiLCJyZXNvbHZlIiwiaW5pdGlhbFBhcmFsbGVsUm91dGVzIiwiTWFwIiwicHJlZmV0Y2hlZCIsIlNldCIsImluaXRpYWxIZWFkIiwiaW5pdGlhbFRyZWUiLCJpbml0aWFsQ2Fub25pY2FsVXJsIiwiY2hpbGRyZW4iLCJhc3NldFByZWZpeCIsImluaXRpYWxTdGF0ZSIsInVzZU1lbW8iLCJ0cmVlIiwiY2FjaGUiLCJkYXRhIiwic3ViVHJlZURhdGEiLCJwYXJhbGxlbFJvdXRlcyIsInByZWZldGNoQ2FjaGUiLCJwdXNoUmVmIiwicGVuZGluZ1B1c2giLCJtcGFOYXZpZ2F0aW9uIiwiZm9jdXNBbmRTY3JvbGxSZWYiLCJ3aW5kb3ciLCJoYXNoIiwidXNlUmVkdWNlcldpdGhSZWR1eERldnRvb2xzIiwicmVkdWNlciIsImRpc3BhdGNoIiwic3luYyIsInVzZUVmZmVjdCIsImhyZWYiLCJzZWFyY2hQYXJhbXMiLCJwYXRobmFtZSIsImNoYW5nZUJ5U2VydmVyUmVzcG9uc2UiLCJ1c2VDYWxsYmFjayIsInByZXZpb3VzVHJlZSIsIm92ZXJyaWRlQ2Fub25pY2FsVXJsIiwidHlwZSIsIkFDVElPTl9TRVJWRVJfUEFUQ0giLCJtdXRhYmxlIiwiYXBwUm91dGVyIiwibmF2aWdhdGUiLCJuYXZpZ2F0ZVR5cGUiLCJmb3JjZU9wdGltaXN0aWNOYXZpZ2F0aW9uIiwiQUNUSU9OX05BVklHQVRFIiwicm91dGVySW5zdGFuY2UiLCJiYWNrIiwiaGlzdG9yeSIsImZvcndhcmQiLCJyZWYiLCJyb3V0ZXJUcmVlIiwic2VydmVyUmVzcG9uc2UiLCJlcnIiLCJoYXMiLCJhZGQiLCJzdGF0ZSIsInN0YXJ0VHJhbnNpdGlvbiIsIkFDVElPTl9QUkVGRVRDSCIsImNvbnNvbGUiLCJlcnJvciIsInJlcGxhY2UiLCJvcHRpb25zIiwiQm9vbGVhbiIsInB1c2giLCJyZWZyZXNoIiwiQUNUSU9OX1JFRlJFU0giLCJoaXN0b3J5U3RhdGUiLCJfX05BIiwicHVzaFN0YXRlIiwicmVwbGFjZVN0YXRlIiwibmQiLCJyb3V0ZXIiLCJvblBvcFN0YXRlIiwicmVsb2FkIiwiQUNUSU9OX1JFU1RPUkUiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIlBhdGhuYW1lQ29udGV4dCIsIlByb3ZpZGVyIiwiU2VhcmNoUGFyYW1zQ29udGV4dCIsIkdsb2JhbExheW91dFJvdXRlckNvbnRleHQiLCJBcHBSb3V0ZXJDb250ZXh0IiwiTGF5b3V0Um91dGVyQ29udGV4dCIsImNoaWxkTm9kZXMiLCJGcmFnbWVudCIsIl9fZXNNb2R1bGUiLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./.yarn/__virtual__/next-virtual-393d91bbcd/0/cache/next-npm-13.0.2-b39abd22d0-f6fea2ee34.zip/node_modules/next/dist/client/components/app-router.js\n"));

/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-393d91bbcd/0/cache/next-npm-13.0.2-b39abd22d0-f6fea2ee34.zip/node_modules/next/dist/client/components/error-boundary.js":
/*!****************************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-393d91bbcd/0/cache/next-npm-13.0.2-b39abd22d0-f6fea2ee34.zip/node_modules/next/dist/client/components/error-boundary.js ***!
  \****************************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    }\n    return _assertThisInitialized(self);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nvar _typeof = function(obj) {\n    \"@swc/helpers - typeof\";\n    return obj && typeof Symbol !== \"undefined\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n};\nfunction _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction _createSuper(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf(Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf(this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn(this, result);\n    };\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ErrorBoundary = ErrorBoundary;\nexports.GlobalErrorComponent = GlobalErrorComponent;\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./.yarn/cache/@swc-helpers-npm-0.4.11-d20747f9c8-736857d524.zip/node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _react = _interop_require_default(__webpack_require__(/*! react */ \"./.yarn/__virtual__/next-virtual-393d91bbcd/0/cache/next-npm-13.0.2-b39abd22d0-f6fea2ee34.zip/node_modules/next/dist/compiled/react/index.js\"));\n/**\n * Handles errors through `getDerivedStateFromError`.\n * Renders the provided error component and provides a way to `reset` the error boundary state.\n */ var ErrorBoundaryHandler = /*#__PURE__*/ function(_Component) {\n    _inherits(ErrorBoundaryHandler, _Component);\n    var _super = _createSuper(ErrorBoundaryHandler);\n    function ErrorBoundaryHandler(props) {\n        _classCallCheck(this, ErrorBoundaryHandler);\n        var _this;\n        _this = _super.call(this, props);\n        _this.reset = function() {\n            _this.setState({\n                error: null\n            });\n        };\n        _this.state = {\n            error: null\n        };\n        return _this;\n    }\n    _createClass(ErrorBoundaryHandler, [\n        {\n            key: \"render\",\n            value: function render() {\n                if (this.state.error) {\n                    return /*#__PURE__*/ _react[\"default\"].createElement(this.props.errorComponent, {\n                        error: this.state.error,\n                        reset: this.reset\n                    });\n                }\n                return this.props.children;\n            }\n        }\n    ], [\n        {\n            key: \"getDerivedStateFromError\",\n            value: function getDerivedStateFromError(error) {\n                return {\n                    error: error\n                };\n            }\n        }\n    ]);\n    return ErrorBoundaryHandler;\n}(_react[\"default\"].Component);\nfunction ErrorBoundary(param) {\n    var errorComponent = param.errorComponent, children = param.children;\n    if (errorComponent) {\n        return /*#__PURE__*/ _react[\"default\"].createElement(ErrorBoundaryHandler, {\n            errorComponent: errorComponent\n        }, children);\n    }\n    return /*#__PURE__*/ _react[\"default\"].createElement(_react[\"default\"].Fragment, null, children);\n}\n_c = ErrorBoundary;\nvar styles = {\n    error: {\n        fontFamily: '-apple-system, BlinkMacSystemFont, Roboto, \"Segoe UI\", \"Fira Sans\", Avenir, \"Helvetica Neue\", \"Lucida Grande\", sans-serif',\n        height: \"100vh\",\n        textAlign: \"center\",\n        display: \"flex\",\n        flexDirection: \"column\",\n        alignItems: \"center\",\n        justifyContent: \"center\"\n    },\n    desc: {\n        display: \"inline-block\",\n        textAlign: \"left\",\n        lineHeight: \"49px\",\n        height: \"49px\",\n        verticalAlign: \"middle\"\n    },\n    h2: {\n        fontSize: \"14px\",\n        fontWeight: \"normal\",\n        lineHeight: \"49px\",\n        margin: 0,\n        padding: 0\n    }\n};\nfunction GlobalErrorComponent() {\n    return /*#__PURE__*/ _react[\"default\"].createElement(\"html\", null, /*#__PURE__*/ _react[\"default\"].createElement(\"body\", null, /*#__PURE__*/ _react[\"default\"].createElement(\"div\", {\n        style: styles.error\n    }, /*#__PURE__*/ _react[\"default\"].createElement(\"div\", {\n        style: styles.desc\n    }, /*#__PURE__*/ _react[\"default\"].createElement(\"h2\", {\n        style: styles.h2\n    }, \"Application error: a client-side exception has occurred (see the browser console for more information).\")))));\n}\n_c1 = GlobalErrorComponent;\nif ((typeof exports[\"default\"] === \"function\" || typeof exports[\"default\"] === \"object\" && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === \"undefined\") {\n    Object.defineProperty(exports[\"default\"], \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports[\"default\"], exports);\n    module.exports = exports[\"default\"];\n} //# sourceMappingURL=error-boundary.js.map\nvar _c, _c1;\n$RefreshReg$(_c, \"ErrorBoundary\");\n$RefreshReg$(_c1, \"GlobalErrorComponent\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi8ueWFybi9fX3ZpcnR1YWxfXy9uZXh0LXZpcnR1YWwtMzkzZDkxYmJjZC8wL2NhY2hlL25leHQtbnBtLTEzLjAuMi1iMzlhYmQyMmQwLWY2ZmVhMmVlMzQuemlwL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvZXJyb3ItYm91bmRhcnkuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELHFCQUFxQixHQUFHRTtBQUN4QkYsNEJBQTRCLEdBQUdHO0FBQy9CLElBQUlDLDJCQUEyQkMsaU5BQStEO0FBQzlGLElBQUlFLFNBQVNILHlCQUF5QkMsbUJBQU9BLENBQUMsMkpBQU87QUFDckQ7OztDQUdDLEdBQUcseUNBMkJBO2NBM0JNRzs4QkFBQUE7YUFBQUEscUJBZU1DLEtBQUs7OEJBZlhEOztrQ0FnQklDO1FBQ04sTUFBS0MsS0FBSyxHQUFHLFdBQUk7WUFDYixNQUFLQyxRQUFRLENBQUM7Z0JBQ1ZDLE9BQU8sSUFBSTtZQUNmO1FBQ0o7UUFDQSxNQUFLQyxLQUFLLEdBQUc7WUFDVEQsT0FBTyxJQUFJO1FBQ2Y7OztpQkF4QkVKOztZQU1OTSxLQUFBQTttQkFBQUEsU0FBQUEsU0FBUztnQkFDTCxJQUFJLElBQUksQ0FBQ0QsS0FBSyxDQUFDRCxLQUFLLEVBQUU7b0JBQ2xCLE9BQU8sV0FBVyxHQUFHTCxNQUFPRCxDQUFBQSxVQUFPLENBQUNTLGFBQWEsQ0FBQyxJQUFJLENBQUNOLEtBQUssQ0FBQ08sY0FBYyxFQUFFO3dCQUN6RUosT0FBTyxJQUFJLENBQUNDLEtBQUssQ0FBQ0QsS0FBSzt3QkFDdkJGLE9BQU8sSUFBSSxDQUFDQSxLQUFLO29CQUNyQjtnQkFDSixDQUFDO2dCQUNELE9BQU8sSUFBSSxDQUFDRCxLQUFLLENBQUNRLFFBQVE7WUFDOUI7Ozs7WUFiT0MsS0FBQUE7bUJBQVAsU0FBT0EseUJBQXlCTixLQUFLLEVBQUU7Z0JBQ25DLE9BQU87b0JBQ0hBLE9BQUFBO2dCQUNKO1lBQ0o7OztXQUxNSjtFQUE2QkQsTUFBT0QsQ0FBQUEsVUFBTyxDQUFDYSxTQUFTO0FBMkIvRCxTQUFTakIsY0FBYyxLQUE4QixFQUFFO1FBQTlCYyxpQkFBRixNQUFFQSxnQkFBaUJDLFdBQW5CLE1BQW1CQTtJQUN0QyxJQUFJRCxnQkFBZ0I7UUFDaEIsT0FBTyxXQUFXLEdBQUdULE1BQU9ELENBQUFBLFVBQU8sQ0FBQ1MsYUFBYSxDQUFDUCxzQkFBc0I7WUFDcEVRLGdCQUFnQkE7UUFDcEIsR0FBR0M7SUFDUCxDQUFDO0lBQ0QsT0FBTyxXQUFXLEdBQUdWLE1BQU9ELENBQUFBLFVBQU8sQ0FBQ1MsYUFBYSxDQUFDUixNQUFPRCxDQUFBQSxVQUFPLENBQUNjLFFBQVEsRUFBRSxJQUFJLEVBQUVIO0FBQ3JGO0tBUFNmO0FBUVQsSUFBTW1CLFNBQVM7SUFDWFQsT0FBTztRQUNIVSxZQUFZO1FBQ1pDLFFBQVE7UUFDUkMsV0FBVztRQUNYQyxTQUFTO1FBQ1RDLGVBQWU7UUFDZkMsWUFBWTtRQUNaQyxnQkFBZ0I7SUFDcEI7SUFDQUMsTUFBTTtRQUNGSixTQUFTO1FBQ1RELFdBQVc7UUFDWE0sWUFBWTtRQUNaUCxRQUFRO1FBQ1JRLGVBQWU7SUFDbkI7SUFDQUMsSUFBSTtRQUNBQyxVQUFVO1FBQ1ZDLFlBQVk7UUFDWkosWUFBWTtRQUNaSyxRQUFRO1FBQ1JDLFNBQVM7SUFDYjtBQUNKO0FBQ0EsU0FBU2pDLHVCQUF1QjtJQUM1QixPQUFPLFdBQVcsR0FBR0ksTUFBT0QsQ0FBQUEsVUFBTyxDQUFDUyxhQUFhLENBQUMsUUFBUSxJQUFJLEVBQUUsV0FBVyxHQUFHUixNQUFPRCxDQUFBQSxVQUFPLENBQUNTLGFBQWEsQ0FBQyxRQUFRLElBQUksRUFBRSxXQUFXLEdBQUdSLE1BQU9ELENBQUFBLFVBQU8sQ0FBQ1MsYUFBYSxDQUFDLE9BQU87UUFDdktzQixPQUFPaEIsT0FBT1QsS0FBSztJQUN2QixHQUFHLFdBQVcsR0FBR0wsTUFBT0QsQ0FBQUEsVUFBTyxDQUFDUyxhQUFhLENBQUMsT0FBTztRQUNqRHNCLE9BQU9oQixPQUFPUSxJQUFJO0lBQ3RCLEdBQUcsV0FBVyxHQUFHdEIsTUFBT0QsQ0FBQUEsVUFBTyxDQUFDUyxhQUFhLENBQUMsTUFBTTtRQUNoRHNCLE9BQU9oQixPQUFPVyxFQUFFO0lBQ3BCLEdBQUc7QUFDUDtNQVJTN0I7QUFVVCxJQUFJLENBQUMsT0FBT0gsT0FBUU0sQ0FBQUEsVUFBTyxLQUFLLGNBQWUsT0FBT04sT0FBUU0sQ0FBQUEsVUFBTyxLQUFLLFlBQVlOLE9BQVFNLENBQUFBLFVBQU8sS0FBSyxJQUFJLEtBQU0sT0FBT04sT0FBUU0sQ0FBQUEsVUFBTyxDQUFDZ0MsVUFBVSxLQUFLLGFBQWE7SUFDckt4QyxPQUFPQyxjQUFjLENBQUNDLE9BQVFNLENBQUFBLFVBQU8sRUFBRSxjQUFjO1FBQUVMLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPeUMsTUFBTSxDQUFDdkMsT0FBUU0sQ0FBQUEsVUFBTyxFQUFFTjtJQUMvQndDLE9BQU94QyxPQUFPLEdBQUdBLE9BQVFNLENBQUFBLFVBQU87QUFDbEMsQ0FBQyxDQUVELDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi8ueWFybi9fX3ZpcnR1YWxfXy9uZXh0LXZpcnR1YWwtMzkzZDkxYmJjZC8wL2NhY2hlL25leHQtbnBtLTEzLjAuMi1iMzlhYmQyMmQwLWY2ZmVhMmVlMzQuemlwL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvZXJyb3ItYm91bmRhcnkuanM/YjUxMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuRXJyb3JCb3VuZGFyeSA9IEVycm9yQm91bmRhcnk7XG5leHBvcnRzLkdsb2JhbEVycm9yQ29tcG9uZW50ID0gR2xvYmFsRXJyb3JDb21wb25lbnQ7XG52YXIgX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0ID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0LmpzXCIpLmRlZmF1bHQ7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG4vKipcbiAqIEhhbmRsZXMgZXJyb3JzIHRocm91Z2ggYGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcmAuXG4gKiBSZW5kZXJzIHRoZSBwcm92aWRlZCBlcnJvciBjb21wb25lbnQgYW5kIHByb3ZpZGVzIGEgd2F5IHRvIGByZXNldGAgdGhlIGVycm9yIGJvdW5kYXJ5IHN0YXRlLlxuICovIGNsYXNzIEVycm9yQm91bmRhcnlIYW5kbGVyIGV4dGVuZHMgX3JlYWN0LmRlZmF1bHQuQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcnJvclxuICAgICAgICB9O1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KHRoaXMucHJvcHMuZXJyb3JDb21wb25lbnQsIHtcbiAgICAgICAgICAgICAgICBlcnJvcjogdGhpcy5zdGF0ZS5lcnJvcixcbiAgICAgICAgICAgICAgICByZXNldDogdGhpcy5yZXNldFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW47XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHByb3BzKXtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICB0aGlzLnJlc2V0ID0gKCk9PntcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGVycm9yOiBudWxsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGVycm9yOiBudWxsXG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gRXJyb3JCb3VuZGFyeSh7IGVycm9yQ29tcG9uZW50ICwgY2hpbGRyZW4gIH0pIHtcbiAgICBpZiAoZXJyb3JDb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChFcnJvckJvdW5kYXJ5SGFuZGxlciwge1xuICAgICAgICAgICAgZXJyb3JDb21wb25lbnQ6IGVycm9yQ29tcG9uZW50XG4gICAgICAgIH0sIGNoaWxkcmVuKTtcbiAgICB9XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcmVhY3QuZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4pO1xufVxuY29uc3Qgc3R5bGVzID0ge1xuICAgIGVycm9yOiB7XG4gICAgICAgIGZvbnRGYW1pbHk6ICctYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsIFJvYm90bywgXCJTZWdvZSBVSVwiLCBcIkZpcmEgU2Fuc1wiLCBBdmVuaXIsIFwiSGVsdmV0aWNhIE5ldWVcIiwgXCJMdWNpZGEgR3JhbmRlXCIsIHNhbnMtc2VyaWYnLFxuICAgICAgICBoZWlnaHQ6ICcxMDB2aCcsXG4gICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgZmxleERpcmVjdGlvbjogJ2NvbHVtbicsXG4gICAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgICAgICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcidcbiAgICB9LFxuICAgIGRlc2M6IHtcbiAgICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgICAgIHRleHRBbGlnbjogJ2xlZnQnLFxuICAgICAgICBsaW5lSGVpZ2h0OiAnNDlweCcsXG4gICAgICAgIGhlaWdodDogJzQ5cHgnLFxuICAgICAgICB2ZXJ0aWNhbEFsaWduOiAnbWlkZGxlJ1xuICAgIH0sXG4gICAgaDI6IHtcbiAgICAgICAgZm9udFNpemU6ICcxNHB4JyxcbiAgICAgICAgZm9udFdlaWdodDogJ25vcm1hbCcsXG4gICAgICAgIGxpbmVIZWlnaHQ6ICc0OXB4JyxcbiAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICBwYWRkaW5nOiAwXG4gICAgfVxufTtcbmZ1bmN0aW9uIEdsb2JhbEVycm9yQ29tcG9uZW50KCkge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJodG1sXCIsIG51bGwsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImJvZHlcIiwgbnVsbCwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgc3R5bGU6IHN0eWxlcy5lcnJvclxuICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIHN0eWxlOiBzdHlsZXMuZGVzY1xuICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImgyXCIsIHtcbiAgICAgICAgc3R5bGU6IHN0eWxlcy5oMlxuICAgIH0sIFwiQXBwbGljYXRpb24gZXJyb3I6IGEgY2xpZW50LXNpZGUgZXhjZXB0aW9uIGhhcyBvY2N1cnJlZCAoc2VlIHRoZSBicm93c2VyIGNvbnNvbGUgZm9yIG1vcmUgaW5mb3JtYXRpb24pLlwiKSkpKSk7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9yLWJvdW5kYXJ5LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkVycm9yQm91bmRhcnkiLCJHbG9iYWxFcnJvckNvbXBvbmVudCIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsInJlcXVpcmUiLCJkZWZhdWx0IiwiX3JlYWN0IiwiRXJyb3JCb3VuZGFyeUhhbmRsZXIiLCJwcm9wcyIsInJlc2V0Iiwic2V0U3RhdGUiLCJlcnJvciIsInN0YXRlIiwicmVuZGVyIiwiY3JlYXRlRWxlbWVudCIsImVycm9yQ29tcG9uZW50IiwiY2hpbGRyZW4iLCJnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IiLCJDb21wb25lbnQiLCJGcmFnbWVudCIsInN0eWxlcyIsImZvbnRGYW1pbHkiLCJoZWlnaHQiLCJ0ZXh0QWxpZ24iLCJkaXNwbGF5IiwiZmxleERpcmVjdGlvbiIsImFsaWduSXRlbXMiLCJqdXN0aWZ5Q29udGVudCIsImRlc2MiLCJsaW5lSGVpZ2h0IiwidmVydGljYWxBbGlnbiIsImgyIiwiZm9udFNpemUiLCJmb250V2VpZ2h0IiwibWFyZ2luIiwicGFkZGluZyIsInN0eWxlIiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./.yarn/__virtual__/next-virtual-393d91bbcd/0/cache/next-npm-13.0.2-b39abd22d0-f6fea2ee34.zip/node_modules/next/dist/client/components/error-boundary.js\n"));

/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-393d91bbcd/0/cache/next-npm-13.0.2-b39abd22d0-f6fea2ee34.zip/node_modules/next/dist/client/components/infinite-promise.js":
/*!******************************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-393d91bbcd/0/cache/next-npm-13.0.2-b39abd22d0-f6fea2ee34.zip/node_modules/next/dist/client/components/infinite-promise.js ***!
  \******************************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.createInfinitePromise = createInfinitePromise;\n/**\n * Used to cache in createInfinitePromise\n */ var infinitePromise;\nfunction createInfinitePromise() {\n    if (!infinitePromise) {\n        // Only create the Promise once\n        infinitePromise = new Promise(function() {\n        // This is used to debug when the rendering is never updated.\n        // setTimeout(() => {\n        //   infinitePromise = new Error('Infinite promise')\n        //   resolve()\n        // }, 5000)\n        });\n    }\n    return infinitePromise;\n}\nif ((typeof exports[\"default\"] === \"function\" || typeof exports[\"default\"] === \"object\" && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === \"undefined\") {\n    Object.defineProperty(exports[\"default\"], \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports[\"default\"], exports);\n    module.exports = exports[\"default\"];\n} //# sourceMappingURL=infinite-promise.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi8ueWFybi9fX3ZpcnR1YWxfXy9uZXh0LXZpcnR1YWwtMzkzZDkxYmJjZC8wL2NhY2hlL25leHQtbnBtLTEzLjAuMi1iMzlhYmQyMmQwLWY2ZmVhMmVlMzQuemlwL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvaW5maW5pdGUtcHJvbWlzZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCw2QkFBNkIsR0FBR0U7QUFDaEM7O0NBRUMsR0FBRyxJQUFJQztBQUNSLFNBQVNELHdCQUF3QjtJQUM3QixJQUFJLENBQUNDLGlCQUFpQjtRQUNsQiwrQkFBK0I7UUFDL0JBLGtCQUFrQixJQUFJQyxRQUFRLFdBQUk7UUFDbEMsNkRBQTZEO1FBQzdELHFCQUFxQjtRQUNyQixvREFBb0Q7UUFDcEQsY0FBYztRQUNkLFdBQVc7UUFDWDtJQUNKLENBQUM7SUFDRCxPQUFPRDtBQUNYO0FBRUEsSUFBSSxDQUFDLE9BQU9ILE9BQVFLLENBQUFBLFVBQU8sS0FBSyxjQUFlLE9BQU9MLE9BQVFLLENBQUFBLFVBQU8sS0FBSyxZQUFZTCxPQUFRSyxDQUFBQSxVQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9MLE9BQVFLLENBQUFBLFVBQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktSLE9BQU9DLGNBQWMsQ0FBQ0MsT0FBUUssQ0FBQUEsVUFBTyxFQUFFLGNBQWM7UUFBRUosT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9TLE1BQU0sQ0FBQ1AsT0FBUUssQ0FBQUEsVUFBTyxFQUFFTDtJQUMvQlEsT0FBT1IsT0FBTyxHQUFHQSxPQUFRSyxDQUFBQSxVQUFPO0FBQ2xDLENBQUMsQ0FFRCw0Q0FBNEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vX192aXJ0dWFsX18vbmV4dC12aXJ0dWFsLTM5M2Q5MWJiY2QvMC9jYWNoZS9uZXh0LW5wbS0xMy4wLjItYjM5YWJkMjJkMC1mNmZlYTJlZTM0LnppcC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2luZmluaXRlLXByb21pc2UuanM/YjZmYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY3JlYXRlSW5maW5pdGVQcm9taXNlID0gY3JlYXRlSW5maW5pdGVQcm9taXNlO1xuLyoqXG4gKiBVc2VkIHRvIGNhY2hlIGluIGNyZWF0ZUluZmluaXRlUHJvbWlzZVxuICovIGxldCBpbmZpbml0ZVByb21pc2U7XG5mdW5jdGlvbiBjcmVhdGVJbmZpbml0ZVByb21pc2UoKSB7XG4gICAgaWYgKCFpbmZpbml0ZVByb21pc2UpIHtcbiAgICAgICAgLy8gT25seSBjcmVhdGUgdGhlIFByb21pc2Ugb25jZVxuICAgICAgICBpbmZpbml0ZVByb21pc2UgPSBuZXcgUHJvbWlzZSgoKT0+e1xuICAgICAgICAvLyBUaGlzIGlzIHVzZWQgdG8gZGVidWcgd2hlbiB0aGUgcmVuZGVyaW5nIGlzIG5ldmVyIHVwZGF0ZWQuXG4gICAgICAgIC8vIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAvLyAgIGluZmluaXRlUHJvbWlzZSA9IG5ldyBFcnJvcignSW5maW5pdGUgcHJvbWlzZScpXG4gICAgICAgIC8vICAgcmVzb2x2ZSgpXG4gICAgICAgIC8vIH0sIDUwMDApXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gaW5maW5pdGVQcm9taXNlO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmZpbml0ZS1wcm9taXNlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImNyZWF0ZUluZmluaXRlUHJvbWlzZSIsImluZmluaXRlUHJvbWlzZSIsIlByb21pc2UiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./.yarn/__virtual__/next-virtual-393d91bbcd/0/cache/next-npm-13.0.2-b39abd22d0-f6fea2ee34.zip/node_modules/next/dist/client/components/infinite-promise.js\n"));

/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-393d91bbcd/0/cache/next-npm-13.0.2-b39abd22d0-f6fea2ee34.zip/node_modules/next/dist/client/components/layout-router.js":
/*!***************************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-393d91bbcd/0/cache/next-npm-13.0.2-b39abd22d0-f6fea2ee34.zip/node_modules/next/dist/client/components/layout-router.js ***!
  \***************************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _assertThisInitialized(self) {\n    if (self === void 0) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n}\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _iterableToArrayLimit(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _possibleConstructorReturn(self, call) {\n    if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n        return call;\n    }\n    return _assertThisInitialized(self);\n}\nfunction _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _setPrototypeOf(o, p);\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nvar _typeof = function(obj) {\n    \"@swc/helpers - typeof\";\n    return obj && typeof Symbol !== \"undefined\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n};\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction _createSuper(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf(Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf(this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn(this, result);\n    };\n}\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$(), _s3 = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = OuterLayoutRouter;\nexports.InnerLayoutRouter = InnerLayoutRouter;\nvar _extends = (__webpack_require__(/*! @swc/helpers/lib/_extends.js */ \"./.yarn/cache/@swc-helpers-npm-0.4.11-d20747f9c8-736857d524.zip/node_modules/@swc/helpers/lib/_extends.js\")[\"default\"]);\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"./.yarn/cache/@swc-helpers-npm-0.4.11-d20747f9c8-736857d524.zip/node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar _react = _interop_require_wildcard(__webpack_require__(/*! react */ \"./.yarn/__virtual__/next-virtual-393d91bbcd/0/cache/next-npm-13.0.2-b39abd22d0-f6fea2ee34.zip/node_modules/next/dist/compiled/react/index.js\"));\nvar _appRouterContext = __webpack_require__(/*! ../../shared/lib/app-router-context */ \"./.yarn/__virtual__/next-virtual-393d91bbcd/0/cache/next-npm-13.0.2-b39abd22d0-f6fea2ee34.zip/node_modules/next/dist/shared/lib/app-router-context.js\");\nvar _appRouter = __webpack_require__(/*! ./app-router */ \"./.yarn/__virtual__/next-virtual-393d91bbcd/0/cache/next-npm-13.0.2-b39abd22d0-f6fea2ee34.zip/node_modules/next/dist/client/components/app-router.js\");\nvar _infinitePromise = __webpack_require__(/*! ./infinite-promise */ \"./.yarn/__virtual__/next-virtual-393d91bbcd/0/cache/next-npm-13.0.2-b39abd22d0-f6fea2ee34.zip/node_modules/next/dist/client/components/infinite-promise.js\");\nvar _errorBoundary = __webpack_require__(/*! ./error-boundary */ \"./.yarn/__virtual__/next-virtual-393d91bbcd/0/cache/next-npm-13.0.2-b39abd22d0-f6fea2ee34.zip/node_modules/next/dist/client/components/error-boundary.js\");\nvar _matchSegments = __webpack_require__(/*! ./match-segments */ \"./.yarn/__virtual__/next-virtual-393d91bbcd/0/cache/next-npm-13.0.2-b39abd22d0-f6fea2ee34.zip/node_modules/next/dist/client/components/match-segments.js\");\nvar _navigation = __webpack_require__(/*! ./navigation */ \"./.yarn/__virtual__/next-virtual-393d91bbcd/0/cache/next-npm-13.0.2-b39abd22d0-f6fea2ee34.zip/node_modules/next/dist/client/components/navigation.js\");\nfunction OuterLayoutRouter(param) {\n    var parallelRouterKey = param.parallelRouterKey, segmentPath = param.segmentPath, childProp = param.childProp, error = param.error, loading = param.loading, hasLoading = param.hasLoading, template = param.template, notFound = param.notFound, rootLayoutIncluded = param.rootLayoutIncluded;\n    _s();\n    var context = (0, _react).useContext(_appRouterContext.LayoutRouterContext);\n    if (!context) {\n        throw new Error(\"invariant expected layout router to be mounted\");\n    }\n    var childNodes = context.childNodes, tree = context.tree, url = context.url;\n    // Get the current parallelRouter cache node\n    var childNodesForParallelRouter = childNodes.get(parallelRouterKey);\n    // If the parallel router cache node does not exist yet, create it.\n    // This writes to the cache when there is no item in the cache yet. It never *overwrites* existing cache items which is why it's safe in concurrent mode.\n    if (!childNodesForParallelRouter) {\n        childNodes.set(parallelRouterKey, new Map());\n        childNodesForParallelRouter = childNodes.get(parallelRouterKey);\n    }\n    // Get the active segment in the tree\n    // The reason arrays are used in the data format is that these are transferred from the server to the browser so it's optimized to save bytes.\n    var treeSegment = tree[1][parallelRouterKey][0];\n    var childPropSegment = Array.isArray(childProp.segment) ? childProp.segment[1] : childProp.segment;\n    // If segment is an array it's a dynamic route and we want to read the dynamic route value as the segment to get from the cache.\n    var currentChildSegment = Array.isArray(treeSegment) ? treeSegment[1] : treeSegment;\n    /**\n   * Decides which segments to keep rendering, all segments that are not active will be wrapped in `<Offscreen>`.\n   */ // TODO-APP: Add handling of `<Offscreen>` when it's available.\n    var preservedSegments = [\n        currentChildSegment\n    ];\n    return /*#__PURE__*/ _react[\"default\"].createElement(_react[\"default\"].Fragment, null, preservedSegments.map(function(preservedSegment) {\n        return(/*\n            - Error boundary\n              - Only renders error boundary if error component is provided.\n              - Rendered for each segment to ensure they have their own error state.\n            - Loading boundary\n              - Only renders suspense boundary if loading components is provided.\n              - Rendered for each segment to ensure they have their own loading state.\n              - Passed to the router during rendering to ensure it can be immediately rendered when suspending on a Flight fetch.\n          */ /*#__PURE__*/ _react[\"default\"].createElement(_appRouterContext.TemplateContext.Provider, {\n            key: preservedSegment,\n            value: /*#__PURE__*/ _react[\"default\"].createElement(_errorBoundary.ErrorBoundary, {\n                errorComponent: error\n            }, /*#__PURE__*/ _react[\"default\"].createElement(LoadingBoundary, {\n                hasLoading: hasLoading,\n                loading: loading\n            }, /*#__PURE__*/ _react[\"default\"].createElement(NotFoundBoundary, {\n                notFound: notFound\n            }, /*#__PURE__*/ _react[\"default\"].createElement(RedirectBoundary, null, /*#__PURE__*/ _react[\"default\"].createElement(InnerLayoutRouter, {\n                parallelRouterKey: parallelRouterKey,\n                url: url,\n                tree: tree,\n                childNodes: childNodesForParallelRouter,\n                childProp: childPropSegment === preservedSegment ? childProp : null,\n                segmentPath: segmentPath,\n                path: preservedSegment,\n                isActive: currentChildSegment === preservedSegment,\n                rootLayoutIncluded: rootLayoutIncluded\n            })))))\n        }, template));\n    }));\n}\n_s(OuterLayoutRouter, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\n_c = OuterLayoutRouter;\n\"use client\";\n/**\n * Add refetch marker to router state at the point of the current layout segment.\n * This ensures the response returned is not further down than the current layout segment.\n */ function walkAddRefetch(segmentPathToWalk, treeToRecreate) {\n    if (segmentPathToWalk) {\n        var _segmentPathToWalk = _slicedToArray(segmentPathToWalk, 2), segment = _segmentPathToWalk[0], parallelRouteKey = _segmentPathToWalk[1];\n        var isLast = segmentPathToWalk.length === 2;\n        if ((0, _matchSegments).matchSegment(treeToRecreate[0], segment)) {\n            if (treeToRecreate[1].hasOwnProperty(parallelRouteKey)) {\n                if (isLast) {\n                    var subTree = walkAddRefetch(undefined, treeToRecreate[1][parallelRouteKey]);\n                    return [\n                        treeToRecreate[0],\n                        _extends({}, treeToRecreate[1], _defineProperty({}, parallelRouteKey, [\n                            subTree[0],\n                            subTree[1],\n                            subTree[2],\n                            \"refetch\"\n                        ]))\n                    ];\n                }\n                return [\n                    treeToRecreate[0],\n                    _extends({}, treeToRecreate[1], _defineProperty({}, parallelRouteKey, walkAddRefetch(segmentPathToWalk.slice(2), treeToRecreate[1][parallelRouteKey])))\n                ];\n            }\n        }\n    }\n    return treeToRecreate;\n}\n/**\n * Check if the top of the HTMLElement is in the viewport.\n */ function topOfElementInViewport(element) {\n    var rect = element.getBoundingClientRect();\n    return rect.top >= 0;\n}\nfunction InnerLayoutRouter(param) {\n    var parallelRouterKey = param.parallelRouterKey, url = param.url, childNodes = param.childNodes, childProp = param.childProp, segmentPath = param.segmentPath, tree = param.tree, // isActive,\n    path = param.path, rootLayoutIncluded = param.rootLayoutIncluded;\n    _s1();\n    var context = (0, _react).useContext(_appRouterContext.GlobalLayoutRouterContext);\n    if (!context) {\n        throw new Error(\"invariant global layout router not mounted\");\n    }\n    var changeByServerResponse = context.changeByServerResponse, fullTree = context.tree, focusAndScrollRef = context.focusAndScrollRef;\n    var focusAndScrollElementRef = (0, _react).useRef(null);\n    (0, _react).useEffect(function() {\n        // Handle scroll and focus, it's only applied once in the first useEffect that triggers that changed.\n        if (focusAndScrollRef.apply && focusAndScrollElementRef.current) {\n            // State is mutated to ensure that the focus and scroll is applied only once.\n            focusAndScrollRef.apply = false;\n            // Set focus on the element\n            focusAndScrollElementRef.current.focus();\n            // Only scroll into viewport when the layout is not visible currently.\n            if (!topOfElementInViewport(focusAndScrollElementRef.current)) {\n                var htmlElement = document.documentElement;\n                var existing = htmlElement.style.scrollBehavior;\n                htmlElement.style.scrollBehavior = \"auto\";\n                focusAndScrollElementRef.current.scrollIntoView();\n                htmlElement.style.scrollBehavior = existing;\n            }\n        }\n    }, [\n        focusAndScrollRef\n    ]);\n    // Read segment path from the parallel router cache node.\n    var childNode = childNodes.get(path);\n    // If childProp is available this means it's the Flight / SSR case.\n    if (childProp && // TODO-APP: verify if this can be null based on user code\n    childProp.current !== null && !childNode /*&&\n    !childProp.partial*/ ) {\n        // Add the segment's subTreeData to the cache.\n        // This writes to the cache when there is no item in the cache yet. It never *overwrites* existing cache items which is why it's safe in concurrent mode.\n        childNodes.set(path, {\n            data: null,\n            subTreeData: childProp.current,\n            parallelRoutes: new Map()\n        });\n        // Mutates the prop in order to clean up the memory associated with the subTreeData as it is now part of the cache.\n        childProp.current = null;\n        // In the above case childNode was set on childNodes, so we have to get it from the cacheNodes again.\n        childNode = childNodes.get(path);\n    }\n    // When childNode is not available during rendering client-side we need to fetch it from the server.\n    if (!childNode) {\n        /**\n     * Router state with refetch marker added\n     */ // TODO-APP: remove ''\n        var refetchTree = walkAddRefetch([\n            \"\"\n        ].concat(_toConsumableArray(segmentPath)), fullTree);\n        /**\n     * Flight data fetch kicked off during render and put into the cache.\n     */ childNodes.set(path, {\n            data: (0, _appRouter).fetchServerResponse(new URL(url, location.origin), refetchTree),\n            subTreeData: null,\n            parallelRoutes: new Map()\n        });\n        // In the above case childNode was set on childNodes, so we have to get it from the cacheNodes again.\n        childNode = childNodes.get(path);\n    }\n    // This case should never happen so it throws an error. It indicates there's a bug in the Next.js.\n    if (!childNode) {\n        throw new Error(\"Child node should always exist\");\n    }\n    // This case should never happen so it throws an error. It indicates there's a bug in the Next.js.\n    if (childNode.subTreeData && childNode.data) {\n        throw new Error(\"Child node should not have both subTreeData and data\");\n    }\n    // If cache node has a data request we have to unwrap response by `use` and update the cache.\n    if (childNode.data) {\n        // TODO-APP: error case\n        /**\n     * Flight response data\n     */ // When the data has not resolved yet `use` will suspend here.\n        var ref = _slicedToArray((0, _react).use(childNode.data), 2), flightData = ref[0], overrideCanonicalUrl = ref[1];\n        // Handle case when navigating to page in `pages` from `app`\n        if (typeof flightData === \"string\") {\n            window.location.href = url;\n            return null;\n        }\n        // segmentPath from the server does not match the layout's segmentPath\n        childNode.data = null;\n        // setTimeout is used to start a new transition during render, this is an intentional hack around React.\n        setTimeout(function() {\n            // @ts-ignore startTransition exists\n            _react[\"default\"].startTransition(function() {\n                // TODO-APP: handle redirect\n                changeByServerResponse(fullTree, flightData, overrideCanonicalUrl);\n            });\n        });\n        // Suspend infinitely as `changeByServerResponse` will cause a different part of the tree to be rendered.\n        (0, _react).use((0, _infinitePromise).createInfinitePromise());\n    }\n    // If cache node has no subTreeData and no data request we have to infinitely suspend as the data will likely flow in from another place.\n    // TODO-APP: double check users can't return null in a component that will kick in here.\n    if (!childNode.subTreeData) {\n        (0, _react).use((0, _infinitePromise).createInfinitePromise());\n    }\n    var subtree = /*#__PURE__*/ _react[\"default\"].createElement(_appRouterContext.LayoutRouterContext.Provider, {\n        value: {\n            tree: tree[1][parallelRouterKey],\n            childNodes: childNode.parallelRoutes,\n            // TODO-APP: overriding of url for parallel routes\n            url: url\n        }\n    }, childNode.subTreeData);\n    // Ensure root layout is not wrapped in a div as the root layout renders `<html>`\n    return rootLayoutIncluded ? /*#__PURE__*/ _react[\"default\"].createElement(\"div\", {\n        ref: focusAndScrollElementRef,\n        \"data-nextjs-scroll-focus-boundary\": \"\"\n    }, subtree) : subtree;\n}\n_s1(InnerLayoutRouter, \"JQanpc2hF1A904pZOh54fuThoYw=\");\n_c1 = InnerLayoutRouter;\n/**\n * Renders suspense boundary with the provided \"loading\" property as the fallback.\n * If no loading property is provided it renders the children without a suspense boundary.\n */ function LoadingBoundary(param) {\n    var children = param.children, loading = param.loading, hasLoading = param.hasLoading;\n    if (hasLoading) {\n        // @ts-expect-error TODO-APP: React.Suspense fallback type is wrong\n        return /*#__PURE__*/ _react[\"default\"].createElement(_react[\"default\"].Suspense, {\n            fallback: loading\n        }, children);\n    }\n    return /*#__PURE__*/ _react[\"default\"].createElement(_react[\"default\"].Fragment, null, children);\n}\n_c2 = LoadingBoundary;\nfunction HandleRedirect(param) {\n    var redirect = param.redirect;\n    _s2();\n    var router = (0, _navigation).useRouter();\n    (0, _react).useEffect(function() {\n        router.replace(redirect, {});\n    }, [\n        redirect,\n        router\n    ]);\n    return null;\n}\n_s2(HandleRedirect, \"vQduR7x+OPXj6PSmJyFnf+hU7bg=\");\n_c3 = HandleRedirect;\nvar RedirectErrorBoundary = /*#__PURE__*/ function(_Component) {\n    \"use strict\";\n    _inherits(RedirectErrorBoundary, _Component);\n    var _super = _createSuper(RedirectErrorBoundary);\n    function RedirectErrorBoundary(props) {\n        _classCallCheck(this, RedirectErrorBoundary);\n        var _this;\n        _this = _super.call(this, props);\n        _this.state = {\n            redirect: null\n        };\n        return _this;\n    }\n    _createClass(RedirectErrorBoundary, [\n        {\n            key: \"render\",\n            value: function render() {\n                var redirect = this.state.redirect;\n                if (redirect !== null) {\n                    return /*#__PURE__*/ _react[\"default\"].createElement(HandleRedirect, {\n                        redirect: redirect\n                    });\n                }\n                return this.props.children;\n            }\n        }\n    ], [\n        {\n            key: \"getDerivedStateFromError\",\n            value: function getDerivedStateFromError(error) {\n                var ref;\n                if ((ref = error.digest) == null ? void 0 : ref.startsWith(\"NEXT_REDIRECT\")) {\n                    var url = error.digest.split(\";\")[1];\n                    return {\n                        redirect: url\n                    };\n                }\n                // Re-throw if error is not for redirect\n                throw error;\n            }\n        }\n    ]);\n    return RedirectErrorBoundary;\n}(_react[\"default\"].Component);\nfunction RedirectBoundary(param) {\n    var children = param.children;\n    _s3();\n    var router = (0, _navigation).useRouter();\n    return /*#__PURE__*/ _react[\"default\"].createElement(RedirectErrorBoundary, {\n        router: router\n    }, children);\n}\n_s3(RedirectBoundary, \"fN7XvhJ+p5oE6+Xlo0NJmXpxjC8=\");\n_c4 = RedirectBoundary;\nvar NotFoundErrorBoundary = /*#__PURE__*/ function(_Component) {\n    \"use strict\";\n    _inherits(NotFoundErrorBoundary, _Component);\n    var _super = _createSuper(NotFoundErrorBoundary);\n    function NotFoundErrorBoundary(props) {\n        _classCallCheck(this, NotFoundErrorBoundary);\n        var _this;\n        _this = _super.call(this, props);\n        _this.state = {\n            notFoundTriggered: false\n        };\n        return _this;\n    }\n    _createClass(NotFoundErrorBoundary, [\n        {\n            key: \"render\",\n            value: function render() {\n                if (this.state.notFoundTriggered) {\n                    return /*#__PURE__*/ _react[\"default\"].createElement(_react[\"default\"].Fragment, null, /*#__PURE__*/ _react[\"default\"].createElement(\"meta\", {\n                        name: \"robots\",\n                        content: \"noindex\"\n                    }), this.props.notFound);\n                }\n                return this.props.children;\n            }\n        }\n    ], [\n        {\n            key: \"getDerivedStateFromError\",\n            value: function getDerivedStateFromError(error) {\n                if (error.digest === \"NEXT_NOT_FOUND\") {\n                    return {\n                        notFoundTriggered: true\n                    };\n                }\n                // Re-throw if error is not for 404\n                throw error;\n            }\n        }\n    ]);\n    return NotFoundErrorBoundary;\n}(_react[\"default\"].Component);\nfunction NotFoundBoundary(param) {\n    var notFound = param.notFound, children = param.children;\n    return notFound ? /*#__PURE__*/ _react[\"default\"].createElement(NotFoundErrorBoundary, {\n        notFound: notFound\n    }, children) : /*#__PURE__*/ _react[\"default\"].createElement(_react[\"default\"].Fragment, null, children);\n}\n_c5 = NotFoundBoundary;\nif ((typeof exports[\"default\"] === \"function\" || typeof exports[\"default\"] === \"object\" && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === \"undefined\") {\n    Object.defineProperty(exports[\"default\"], \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports[\"default\"], exports);\n    module.exports = exports[\"default\"];\n} //# sourceMappingURL=layout-router.js.map\nvar _c, _c1, _c2, _c3, _c4, _c5;\n$RefreshReg$(_c, \"OuterLayoutRouter\");\n$RefreshReg$(_c1, \"InnerLayoutRouter\");\n$RefreshReg$(_c2, \"LoadingBoundary\");\n$RefreshReg$(_c3, \"HandleRedirect\");\n$RefreshReg$(_c4, \"RedirectBoundary\");\n$RefreshReg$(_c5, \"NotFoundBoundary\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi8ueWFybi9fX3ZpcnR1YWxfXy9uZXh0LXZpcnR1YWwtMzkzZDkxYmJjZC8wL2NhY2hlL25leHQtbnBtLTEzLjAuMi1iMzlhYmQyMmQwLWY2ZmVhMmVlMzQuemlwL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvbGF5b3V0LXJvdXRlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFDYTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsa0JBQWUsR0FBR0c7QUFDbEJILHlCQUF5QixHQUFHSTtBQUM1QixJQUFJQyxXQUFXQyxpTEFBK0M7QUFDOUQsSUFBSUMsNEJBQTRCRCxtTkFBZ0U7QUFDaEcsSUFBSUUsU0FBU0QsMEJBQTBCRCxtQkFBT0EsQ0FBQywySkFBTztBQUN0RCxJQUFJRyxvQkFBb0JILG1CQUFPQSxDQUFDLGtNQUFxQztBQUNyRSxJQUFJSSxhQUFhSixtQkFBT0EsQ0FBQywwS0FBYztBQUN2QyxJQUFJSyxtQkFBbUJMLG1CQUFPQSxDQUFDLHNMQUFvQjtBQUNuRCxJQUFJTSxpQkFBaUJOLG1CQUFPQSxDQUFDLGtMQUFrQjtBQUMvQyxJQUFJTyxpQkFBaUJQLG1CQUFPQSxDQUFDLGtMQUFrQjtBQUMvQyxJQUFJUSxjQUFjUixtQkFBT0EsQ0FBQywwS0FBYztBQUN4QyxTQUFTSCxrQkFBa0IsS0FBMEgsRUFBRTtRQUExSFksb0JBQUYsTUFBRUEsbUJBQW9CQyxjQUF0QixNQUFzQkEsYUFBY0MsWUFBcEMsTUFBb0NBLFdBQVlDLFFBQWhELE1BQWdEQSxPQUFRQyxVQUF4RCxNQUF3REEsU0FBVUMsYUFBbEUsTUFBa0VBLFlBQWFDLFdBQS9FLE1BQStFQSxVQUFXQyxXQUExRixNQUEwRkEsVUFBV0MscUJBQXJHLE1BQXFHQTs7SUFDNUgsSUFBTUMsVUFBVSxDQUFDLEdBQUdoQixNQUFNLEVBQUVpQixVQUFVLENBQUNoQixrQkFBa0JpQixtQkFBbUI7SUFDNUUsSUFBSSxDQUFDRixTQUFTO1FBQ1YsTUFBTSxJQUFJRyxNQUFNLGtEQUFrRDtJQUN0RSxDQUFDO0lBQ0QsSUFBUUMsYUFBNkJKLFFBQTdCSSxZQUFhQyxPQUFnQkwsUUFBaEJLLE1BQU9DLE1BQVNOLFFBQVRNO0lBQzVCLDRDQUE0QztJQUM1QyxJQUFJQyw4QkFBOEJILFdBQVdJLEdBQUcsQ0FBQ2pCO0lBQ2pELG1FQUFtRTtJQUNuRSx5SkFBeUo7SUFDekosSUFBSSxDQUFDZ0IsNkJBQTZCO1FBQzlCSCxXQUFXSyxHQUFHLENBQUNsQixtQkFBbUIsSUFBSW1CO1FBQ3RDSCw4QkFBOEJILFdBQVdJLEdBQUcsQ0FBQ2pCO0lBQ2pELENBQUM7SUFDRCxxQ0FBcUM7SUFDckMsOElBQThJO0lBQzlJLElBQU1vQixjQUFjTixJQUFJLENBQUMsRUFBRSxDQUFDZCxrQkFBa0IsQ0FBQyxFQUFFO0lBQ2pELElBQU1xQixtQkFBbUJDLE1BQU1DLE9BQU8sQ0FBQ3JCLFVBQVVzQixPQUFPLElBQUl0QixVQUFVc0IsT0FBTyxDQUFDLEVBQUUsR0FBR3RCLFVBQVVzQixPQUFPO0lBQ3BHLGdJQUFnSTtJQUNoSSxJQUFNQyxzQkFBc0JILE1BQU1DLE9BQU8sQ0FBQ0gsZUFBZUEsV0FBVyxDQUFDLEVBQUUsR0FBR0EsV0FBVztJQUNyRjs7R0FFRCxHQUFHLCtEQUErRDtJQUNqRSxJQUFNTSxvQkFBb0I7UUFDdEJEO0tBQ0g7SUFDRCxPQUFPLFdBQVcsR0FBR2hDLE1BQU9OLENBQUFBLFVBQU8sQ0FBQ3dDLGFBQWEsQ0FBQ2xDLE1BQU9OLENBQUFBLFVBQU8sQ0FBQ3lDLFFBQVEsRUFBRSxJQUFJLEVBQUVGLGtCQUFrQkcsR0FBRyxDQUFDLFNBQUNDLGtCQUFtQjtRQUN2SCxPQUFPOzs7Ozs7OztVQVFMLEdBQUcsV0FBVyxHQUFHckMsTUFBT04sQ0FBQUEsVUFBTyxDQUFDd0MsYUFBYSxDQUFDakMsa0JBQWtCcUMsZUFBZSxDQUFDQyxRQUFRLEVBQUU7WUFDeEZDLEtBQUtIO1lBQ0w1QyxPQUFPLFdBQVcsR0FBR08sTUFBT04sQ0FBQUEsVUFBTyxDQUFDd0MsYUFBYSxDQUFDOUIsZUFBZXFDLGFBQWEsRUFBRTtnQkFDNUVDLGdCQUFnQmhDO1lBQ3BCLEdBQUcsV0FBVyxHQUFHVixNQUFPTixDQUFBQSxVQUFPLENBQUN3QyxhQUFhLENBQUNTLGlCQUFpQjtnQkFDM0QvQixZQUFZQTtnQkFDWkQsU0FBU0E7WUFDYixHQUFHLFdBQVcsR0FBR1gsTUFBT04sQ0FBQUEsVUFBTyxDQUFDd0MsYUFBYSxDQUFDVSxrQkFBa0I7Z0JBQzVEOUIsVUFBVUE7WUFDZCxHQUFHLFdBQVcsR0FBR2QsTUFBT04sQ0FBQUEsVUFBTyxDQUFDd0MsYUFBYSxDQUFDVyxrQkFBa0IsSUFBSSxFQUFFLFdBQVcsR0FBRzdDLE1BQU9OLENBQUFBLFVBQU8sQ0FBQ3dDLGFBQWEsQ0FBQ3RDLG1CQUFtQjtnQkFDaElXLG1CQUFtQkE7Z0JBQ25CZSxLQUFLQTtnQkFDTEQsTUFBTUE7Z0JBQ05ELFlBQVlHO2dCQUNaZCxXQUFXbUIscUJBQXFCUyxtQkFBbUI1QixZQUFZLElBQUk7Z0JBQ25FRCxhQUFhQTtnQkFDYnNDLE1BQU1UO2dCQUNOVSxVQUFVZix3QkFBd0JLO2dCQUNsQ3RCLG9CQUFvQkE7WUFDeEI7UUFDSixHQUFHRjtJQUNQO0FBQ0o7R0F6RFNsQjtLQUFBQTtBQTBEVDtBQUNBOzs7Q0FHQyxHQUFHLFNBQVNxRCxlQUFlQyxpQkFBaUIsRUFBRUMsY0FBYyxFQUFFO0lBQzNELElBQUlELG1CQUFtQjtRQUNuQixJQUFvQ0Esb0NBQUFBLHVCQUE3QmxCLFVBQTZCa0IsdUJBQXBCRSxtQkFBb0JGO1FBQ3BDLElBQU1HLFNBQVNILGtCQUFrQkksTUFBTSxLQUFLO1FBQzVDLElBQUksQ0FBQyxHQUFHaEQsY0FBYyxFQUFFaUQsWUFBWSxDQUFDSixjQUFjLENBQUMsRUFBRSxFQUFFbkIsVUFBVTtZQUM5RCxJQUFJbUIsY0FBYyxDQUFDLEVBQUUsQ0FBQ0ssY0FBYyxDQUFDSixtQkFBbUI7Z0JBQ3BELElBQUlDLFFBQVE7b0JBQ1IsSUFBTUksVUFBVVIsZUFBZVMsV0FBV1AsY0FBYyxDQUFDLEVBQUUsQ0FBQ0MsaUJBQWlCO29CQUM3RSxPQUFPO3dCQUNIRCxjQUFjLENBQUMsRUFBRTt3QkFDakJyRCxTQUFTLENBQUMsR0FBR3FELGNBQWMsQ0FBQyxFQUFFLEVBQzFCLG9CQUFDQyxrQkFBbUI7NEJBQ2hCSyxPQUFPLENBQUMsRUFBRTs0QkFDVkEsT0FBTyxDQUFDLEVBQUU7NEJBQ1ZBLE9BQU8sQ0FBQyxFQUFFOzRCQUNWO3lCQUNIO3FCQUVSO2dCQUNMLENBQUM7Z0JBQ0QsT0FBTztvQkFDSE4sY0FBYyxDQUFDLEVBQUU7b0JBQ2pCckQsU0FBUyxDQUFDLEdBQUdxRCxjQUFjLENBQUMsRUFBRSxFQUMxQixvQkFBQ0Msa0JBQW1CSCxlQUFlQyxrQkFBa0JTLEtBQUssQ0FBQyxJQUFJUixjQUFjLENBQUMsRUFBRSxDQUFDQyxpQkFBaUI7aUJBRXpHO1lBQ0wsQ0FBQztRQUNMLENBQUM7SUFDTCxDQUFDO0lBQ0QsT0FBT0Q7QUFDWDtBQUNBOztDQUVDLEdBQUcsU0FBU1MsdUJBQXVCQyxPQUFPLEVBQUU7SUFDekMsSUFBTUMsT0FBT0QsUUFBUUUscUJBQXFCO0lBQzFDLE9BQU9ELEtBQUtFLEdBQUcsSUFBSTtBQUN2QjtBQUNBLFNBQVNuRSxrQkFBa0IsS0FFQyxFQUFFO1FBRkRXLG9CQUFGLE1BQUVBLG1CQUFvQmUsTUFBdEIsTUFBc0JBLEtBQU1GLGFBQTVCLE1BQTRCQSxZQUFhWCxZQUF6QyxNQUF5Q0EsV0FBWUQsY0FBckQsTUFBcURBLGFBQWNhLE9BQW5FLE1BQW1FQSxNQUM5RixZQUFZO0lBQ1p5QixPQUYyQixNQUUzQkEsTUFBTy9CLHFCQUZvQixNQUVwQkE7O0lBQ0gsSUFBTUMsVUFBVSxDQUFDLEdBQUdoQixNQUFNLEVBQUVpQixVQUFVLENBQUNoQixrQkFBa0IrRCx5QkFBeUI7SUFDbEYsSUFBSSxDQUFDaEQsU0FBUztRQUNWLE1BQU0sSUFBSUcsTUFBTSw4Q0FBOEM7SUFDbEUsQ0FBQztJQUNELElBQVE4Qyx5QkFBaUVqRCxRQUFqRWlELHdCQUF5QjVDLFdBQXdDTCxRQUF4Q0ssTUFBaUI4QyxvQkFBdUJuRCxRQUF2Qm1EO0lBQ2xELElBQU1DLDJCQUEyQixDQUFDLEdBQUdwRSxNQUFNLEVBQUVxRSxNQUFNLENBQUMsSUFBSTtJQUN2RCxJQUFHckUsTUFBTSxFQUFFc0UsU0FBUyxDQUFDLFdBQUk7UUFDdEIscUdBQXFHO1FBQ3JHLElBQUlILGtCQUFrQkksS0FBSyxJQUFJSCx5QkFBeUJJLE9BQU8sRUFBRTtZQUM3RCw2RUFBNkU7WUFDN0VMLGtCQUFrQkksS0FBSyxHQUFHLEtBQUs7WUFDL0IsMkJBQTJCO1lBQzNCSCx5QkFBeUJJLE9BQU8sQ0FBQ0MsS0FBSztZQUN0QyxzRUFBc0U7WUFDdEUsSUFBSSxDQUFDZCx1QkFBdUJTLHlCQUF5QkksT0FBTyxHQUFHO2dCQUMzRCxJQUFNRSxjQUFjQyxTQUFTQyxlQUFlO2dCQUM1QyxJQUFNQyxXQUFXSCxZQUFZSSxLQUFLLENBQUNDLGNBQWM7Z0JBQ2pETCxZQUFZSSxLQUFLLENBQUNDLGNBQWMsR0FBRztnQkFDbkNYLHlCQUF5QkksT0FBTyxDQUFDUSxjQUFjO2dCQUMvQ04sWUFBWUksS0FBSyxDQUFDQyxjQUFjLEdBQUdGO1lBQ3ZDLENBQUM7UUFDTCxDQUFDO0lBQ0wsR0FBRztRQUNDVjtLQUNIO0lBQ0QseURBQXlEO0lBQ3pELElBQUljLFlBQVk3RCxXQUFXSSxHQUFHLENBQUNzQjtJQUMvQixtRUFBbUU7SUFDbkUsSUFBSXJDLGFBQWEsMERBQTBEO0lBQzNFQSxVQUFVK0QsT0FBTyxLQUFLLElBQUksSUFBSSxDQUFDUyxVQUFVO3NCQUN2QixLQUFLO1FBQ25CLDhDQUE4QztRQUM5Qyx5SkFBeUo7UUFDeko3RCxXQUFXSyxHQUFHLENBQUNxQixNQUFNO1lBQ2pCb0MsTUFBTSxJQUFJO1lBQ1ZDLGFBQWExRSxVQUFVK0QsT0FBTztZQUM5QlksZ0JBQWdCLElBQUkxRDtRQUN4QjtRQUNBLG1IQUFtSDtRQUNuSGpCLFVBQVUrRCxPQUFPLEdBQUcsSUFBSTtRQUN4QixxR0FBcUc7UUFDckdTLFlBQVk3RCxXQUFXSSxHQUFHLENBQUNzQjtJQUMvQixDQUFDO0lBQ0Qsb0dBQW9HO0lBQ3BHLElBQUksQ0FBQ21DLFdBQVc7UUFDWjs7S0FFSCxHQUFHLHNCQUFzQjtRQUN0QixJQUFNSSxjQUFjckMsZUFBZTtZQUMvQjtTQUVILENBSGtDLE9BRS9CLG1CQUFHeEMsZUFDSjBEO1FBQ0g7O0tBRUgsR0FBRzlDLFdBQVdLLEdBQUcsQ0FBQ3FCLE1BQU07WUFDakJvQyxNQUFNLENBQUMsR0FBR2hGLFVBQVUsRUFBRW9GLG1CQUFtQixDQUFDLElBQUlDLElBQUlqRSxLQUFLa0UsU0FBU0MsTUFBTSxHQUFHSjtZQUN6RUYsYUFBYSxJQUFJO1lBQ2pCQyxnQkFBZ0IsSUFBSTFEO1FBQ3hCO1FBQ0EscUdBQXFHO1FBQ3JHdUQsWUFBWTdELFdBQVdJLEdBQUcsQ0FBQ3NCO0lBQy9CLENBQUM7SUFDRCxrR0FBa0c7SUFDbEcsSUFBSSxDQUFDbUMsV0FBVztRQUNaLE1BQU0sSUFBSTlELE1BQU0sa0NBQWtDO0lBQ3RELENBQUM7SUFDRCxrR0FBa0c7SUFDbEcsSUFBSThELFVBQVVFLFdBQVcsSUFBSUYsVUFBVUMsSUFBSSxFQUFFO1FBQ3pDLE1BQU0sSUFBSS9ELE1BQU0sd0RBQXdEO0lBQzVFLENBQUM7SUFDRCw2RkFBNkY7SUFDN0YsSUFBSThELFVBQVVDLElBQUksRUFBRTtRQUNoQix1QkFBdUI7UUFDdkI7O0tBRUgsR0FBRyw4REFBOEQ7UUFDOUQsSUFBMkMsc0JBQUMsR0FBR2xGLE1BQU0sRUFBRTBGLEdBQUcsQ0FBQ1QsVUFBVUMsSUFBSSxPQUFsRVMsYUFBb0MsUUFBeEJDLHVCQUF3QjtRQUMzQyw0REFBNEQ7UUFDNUQsSUFBSSxPQUFPRCxlQUFlLFVBQVU7WUFDaENFLE9BQU9MLFFBQVEsQ0FBQ00sSUFBSSxHQUFHeEU7WUFDdkIsT0FBTyxJQUFJO1FBQ2YsQ0FBQztRQUNELHNFQUFzRTtRQUN0RTJELFVBQVVDLElBQUksR0FBRyxJQUFJO1FBQ3JCLHdHQUF3RztRQUN4R2EsV0FBVyxXQUFJO1lBQ1gsb0NBQW9DO1lBQ3BDL0YsTUFBT04sQ0FBQUEsVUFBTyxDQUFDc0csZUFBZSxDQUFDLFdBQUk7Z0JBQy9CLDRCQUE0QjtnQkFDNUIvQix1QkFBdUJDLFVBQVV5QixZQUFZQztZQUNqRDtRQUNKO1FBQ0EseUdBQXlHO1FBQ3hHLElBQUc1RixNQUFNLEVBQUUwRixHQUFHLENBQUMsQ0FBQyxHQUFHdkYsZ0JBQWdCLEVBQUU4RixxQkFBcUI7SUFDL0QsQ0FBQztJQUNELHlJQUF5STtJQUN6SSx3RkFBd0Y7SUFDeEYsSUFBSSxDQUFDaEIsVUFBVUUsV0FBVyxFQUFFO1FBQ3ZCLElBQUduRixNQUFNLEVBQUUwRixHQUFHLENBQUMsQ0FBQyxHQUFHdkYsZ0JBQWdCLEVBQUU4RixxQkFBcUI7SUFDL0QsQ0FBQztJQUNELElBQU1DLFVBQ04sV0FBVyxHQUFHbEcsTUFBT04sQ0FBQUEsVUFBTyxDQUFDd0MsYUFBYSxDQUFDakMsa0JBQWtCaUIsbUJBQW1CLENBQUNxQixRQUFRLEVBQUU7UUFDdkY5QyxPQUFPO1lBQ0g0QixNQUFNQSxJQUFJLENBQUMsRUFBRSxDQUFDZCxrQkFBa0I7WUFDaENhLFlBQVk2RCxVQUFVRyxjQUFjO1lBQ3BDLGtEQUFrRDtZQUNsRDlELEtBQUtBO1FBQ1Q7SUFDSixHQUFHMkQsVUFBVUUsV0FBVztJQUN4QixpRkFBaUY7SUFDakYsT0FBT3BFLHFCQUFxQixXQUFXLEdBQUdmLE1BQU9OLENBQUFBLFVBQU8sQ0FBQ3dDLGFBQWEsQ0FBQyxPQUFPO1FBQzFFaUUsS0FBSy9CO1FBQ0wscUNBQXFDO0lBQ3pDLEdBQUc4QixXQUFXQSxPQUFPO0FBQ3pCO0lBckhTdEc7TUFBQUE7QUFzSFQ7OztDQUdDLEdBQUcsU0FBUytDLGdCQUFnQixLQUFvQyxFQUFFO1FBQXBDeUQsV0FBRixNQUFFQSxVQUFXekYsVUFBYixNQUFhQSxTQUFVQyxhQUF2QixNQUF1QkE7SUFDaEQsSUFBSUEsWUFBWTtRQUNaLG1FQUFtRTtRQUNuRSxPQUFPLFdBQVcsR0FBR1osTUFBT04sQ0FBQUEsVUFBTyxDQUFDd0MsYUFBYSxDQUFDbEMsTUFBT04sQ0FBQUEsVUFBTyxDQUFDMkcsUUFBUSxFQUFFO1lBQ3ZFQyxVQUFVM0Y7UUFDZCxHQUFHeUY7SUFDUCxDQUFDO0lBQ0QsT0FBTyxXQUFXLEdBQUdwRyxNQUFPTixDQUFBQSxVQUFPLENBQUN3QyxhQUFhLENBQUNsQyxNQUFPTixDQUFBQSxVQUFPLENBQUN5QyxRQUFRLEVBQUUsSUFBSSxFQUFFaUU7QUFDckY7TUFSYXpEO0FBU2IsU0FBUzRELGVBQWUsS0FBYSxFQUFFO1FBQWYsaUJBQUVDOztJQUN0QixJQUFNQyxTQUFTLENBQUMsR0FBR25HLFdBQVcsRUFBRW9HLFNBQVM7SUFDeEMsSUFBRzFHLE1BQU0sRUFBRXNFLFNBQVMsQ0FBQyxXQUFJO1FBQ3RCbUMsT0FBT0UsT0FBTyxDQUFDSCxVQUFVLENBQUM7SUFDOUIsR0FBRztRQUNDQTtRQUNBQztLQUNIO0lBQ0QsT0FBTyxJQUFJO0FBQ2Y7SUFUU0Y7TUFBQUE7QUFVVCwwQ0E0Qkk7O2NBNUJFSzs4QkFBQUE7YUFBQUEsc0JBcUJVQyxLQUFLOzhCQXJCZkQ7O2tDQXNCUUM7UUFDTixNQUFLQyxLQUFLLEdBQUc7WUFDVE4sVUFBVSxJQUFJO1FBQ2xCOzs7aUJBekJGSTs7WUFZRkcsS0FBQUE7bUJBQUFBLFNBQUFBLFNBQVM7Z0JBQ0wsSUFBTVAsV0FBVyxJQUFJLENBQUNNLEtBQUssQ0FBQ04sUUFBUTtnQkFDcEMsSUFBSUEsYUFBYSxJQUFJLEVBQUU7b0JBQ25CLE9BQU8sV0FBVyxHQUFHeEcsTUFBT04sQ0FBQUEsVUFBTyxDQUFDd0MsYUFBYSxDQUFDcUUsZ0JBQWdCO3dCQUM5REMsVUFBVUE7b0JBQ2Q7Z0JBQ0osQ0FBQztnQkFDRCxPQUFPLElBQUksQ0FBQ0ssS0FBSyxDQUFDVCxRQUFRO1lBQzlCOzs7O1lBbkJPWSxLQUFBQTttQkFBUCxTQUFPQSx5QkFBeUJ0RyxLQUFLLEVBQUU7Z0JBQ25DLElBQUl5RjtnQkFDSixJQUFJLENBQUNBLE1BQU16RixNQUFNdUcsTUFBTSxLQUFLLElBQUksR0FBRyxLQUFLLElBQUlkLElBQUllLFVBQVUsQ0FBQyxnQkFBZ0IsRUFBRTtvQkFDekUsSUFBTTVGLE1BQU1aLE1BQU11RyxNQUFNLENBQUNFLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRTtvQkFDdEMsT0FBTzt3QkFDSFgsVUFBVWxGO29CQUNkO2dCQUNKLENBQUM7Z0JBQ0Qsd0NBQXdDO2dCQUN4QyxNQUFNWixNQUFNO1lBQ2hCOzs7V0FYRWtHO0VBQThCNUcsTUFBT04sQ0FBQUEsVUFBTyxDQUFDMEgsU0FBUztBQTRCNUQsU0FBU3ZFLGlCQUFpQixLQUFhLEVBQUU7UUFBZixpQkFBRXVEOztJQUN4QixJQUFNSyxTQUFTLENBQUMsR0FBR25HLFdBQVcsRUFBRW9HLFNBQVM7SUFDekMsT0FBTyxXQUFXLEdBQUcxRyxNQUFPTixDQUFBQSxVQUFPLENBQUN3QyxhQUFhLENBQUMwRSx1QkFBdUI7UUFDckVILFFBQVFBO0lBQ1osR0FBR0w7QUFDUDtJQUxTdkQ7TUFBQUE7QUFNVCwwQ0EwQkk7O2NBMUJFd0U7OEJBQUFBO2FBQUFBLHNCQW1CVVIsS0FBSzs4QkFuQmZROztrQ0FvQlFSO1FBQ04sTUFBS0MsS0FBSyxHQUFHO1lBQ1RRLG1CQUFtQixLQUFLO1FBQzVCOzs7aUJBdkJGRDs7WUFVRk4sS0FBQUE7bUJBQUFBLFNBQUFBLFNBQVM7Z0JBQ0wsSUFBSSxJQUFJLENBQUNELEtBQUssQ0FBQ1EsaUJBQWlCLEVBQUU7b0JBQzlCLE9BQU8sV0FBVyxHQUFHdEgsTUFBT04sQ0FBQUEsVUFBTyxDQUFDd0MsYUFBYSxDQUFDbEMsTUFBT04sQ0FBQUEsVUFBTyxDQUFDeUMsUUFBUSxFQUFFLElBQUksRUFBRSxXQUFXLEdBQUduQyxNQUFPTixDQUFBQSxVQUFPLENBQUN3QyxhQUFhLENBQUMsUUFBUTt3QkFDaElxRixNQUFNO3dCQUNOQyxTQUFTO29CQUNiLElBQUksSUFBSSxDQUFDWCxLQUFLLENBQUMvRixRQUFRO2dCQUMzQixDQUFDO2dCQUNELE9BQU8sSUFBSSxDQUFDK0YsS0FBSyxDQUFDVCxRQUFRO1lBQzlCOzs7O1lBakJPWSxLQUFBQTttQkFBUCxTQUFPQSx5QkFBeUJ0RyxLQUFLLEVBQUU7Z0JBQ25DLElBQUlBLE1BQU11RyxNQUFNLEtBQUssa0JBQWtCO29CQUNuQyxPQUFPO3dCQUNISyxtQkFBbUIsSUFBSTtvQkFDM0I7Z0JBQ0osQ0FBQztnQkFDRCxtQ0FBbUM7Z0JBQ25DLE1BQU01RyxNQUFNO1lBQ2hCOzs7V0FURTJHO0VBQThCckgsTUFBT04sQ0FBQUEsVUFBTyxDQUFDMEgsU0FBUztBQTBCNUQsU0FBU3hFLGlCQUFpQixLQUF3QixFQUFFO1FBQXhCOUIsV0FBRixNQUFFQSxVQUFXc0YsV0FBYixNQUFhQTtJQUNuQyxPQUFPdEYsV0FBVyxXQUFXLEdBQUdkLE1BQU9OLENBQUFBLFVBQU8sQ0FBQ3dDLGFBQWEsQ0FBQ21GLHVCQUF1QjtRQUNoRnZHLFVBQVVBO0lBQ2QsR0FBR3NGLFlBQVksV0FBVyxHQUFHcEcsTUFBT04sQ0FBQUEsVUFBTyxDQUFDd0MsYUFBYSxDQUFDbEMsTUFBT04sQ0FBQUEsVUFBTyxDQUFDeUMsUUFBUSxFQUFFLElBQUksRUFBRWlFLFNBQVM7QUFDdEc7TUFKU3hEO0FBTVQsSUFBSSxDQUFDLE9BQU9wRCxPQUFRRSxDQUFBQSxVQUFPLEtBQUssY0FBZSxPQUFPRixPQUFRRSxDQUFBQSxVQUFPLEtBQUssWUFBWUYsT0FBUUUsQ0FBQUEsVUFBTyxLQUFLLElBQUksS0FBTSxPQUFPRixPQUFRRSxDQUFBQSxVQUFPLENBQUMrSCxVQUFVLEtBQUssYUFBYTtJQUNyS25JLE9BQU9DLGNBQWMsQ0FBQ0MsT0FBUUUsQ0FBQUEsVUFBTyxFQUFFLGNBQWM7UUFBRUQsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9vSSxNQUFNLENBQUNsSSxPQUFRRSxDQUFBQSxVQUFPLEVBQUVGO0lBQy9CbUksT0FBT25JLE9BQU8sR0FBR0EsT0FBUUUsQ0FBQUEsVUFBTztBQUNsQyxDQUFDLENBRUQseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL19fdmlydHVhbF9fL25leHQtdmlydHVhbC0zOTNkOTFiYmNkLzAvY2FjaGUvbmV4dC1ucG0tMTMuMC4yLWIzOWFiZDIyZDAtZjZmZWEyZWUzNC56aXAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9sYXlvdXQtcm91dGVyLmpzP2E4NGEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IE91dGVyTGF5b3V0Um91dGVyO1xuZXhwb3J0cy5Jbm5lckxheW91dFJvdXRlciA9IElubmVyTGF5b3V0Um91dGVyO1xudmFyIF9leHRlbmRzID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2V4dGVuZHMuanNcIikuZGVmYXVsdDtcbnZhciBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZC5qc1wiKS5kZWZhdWx0O1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfYXBwUm91dGVyQ29udGV4dCA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dFwiKTtcbnZhciBfYXBwUm91dGVyID0gcmVxdWlyZShcIi4vYXBwLXJvdXRlclwiKTtcbnZhciBfaW5maW5pdGVQcm9taXNlID0gcmVxdWlyZShcIi4vaW5maW5pdGUtcHJvbWlzZVwiKTtcbnZhciBfZXJyb3JCb3VuZGFyeSA9IHJlcXVpcmUoXCIuL2Vycm9yLWJvdW5kYXJ5XCIpO1xudmFyIF9tYXRjaFNlZ21lbnRzID0gcmVxdWlyZShcIi4vbWF0Y2gtc2VnbWVudHNcIik7XG52YXIgX25hdmlnYXRpb24gPSByZXF1aXJlKFwiLi9uYXZpZ2F0aW9uXCIpO1xuZnVuY3Rpb24gT3V0ZXJMYXlvdXRSb3V0ZXIoeyBwYXJhbGxlbFJvdXRlcktleSAsIHNlZ21lbnRQYXRoICwgY2hpbGRQcm9wICwgZXJyb3IgLCBsb2FkaW5nICwgaGFzTG9hZGluZyAsIHRlbXBsYXRlICwgbm90Rm91bmQgLCByb290TGF5b3V0SW5jbHVkZWQgIH0pIHtcbiAgICBjb25zdCBjb250ZXh0ID0gKDAsIF9yZWFjdCkudXNlQ29udGV4dChfYXBwUm91dGVyQ29udGV4dC5MYXlvdXRSb3V0ZXJDb250ZXh0KTtcbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgZXhwZWN0ZWQgbGF5b3V0IHJvdXRlciB0byBiZSBtb3VudGVkJyk7XG4gICAgfVxuICAgIGNvbnN0IHsgY2hpbGROb2RlcyAsIHRyZWUgLCB1cmwgIH0gPSBjb250ZXh0O1xuICAgIC8vIEdldCB0aGUgY3VycmVudCBwYXJhbGxlbFJvdXRlciBjYWNoZSBub2RlXG4gICAgbGV0IGNoaWxkTm9kZXNGb3JQYXJhbGxlbFJvdXRlciA9IGNoaWxkTm9kZXMuZ2V0KHBhcmFsbGVsUm91dGVyS2V5KTtcbiAgICAvLyBJZiB0aGUgcGFyYWxsZWwgcm91dGVyIGNhY2hlIG5vZGUgZG9lcyBub3QgZXhpc3QgeWV0LCBjcmVhdGUgaXQuXG4gICAgLy8gVGhpcyB3cml0ZXMgdG8gdGhlIGNhY2hlIHdoZW4gdGhlcmUgaXMgbm8gaXRlbSBpbiB0aGUgY2FjaGUgeWV0LiBJdCBuZXZlciAqb3ZlcndyaXRlcyogZXhpc3RpbmcgY2FjaGUgaXRlbXMgd2hpY2ggaXMgd2h5IGl0J3Mgc2FmZSBpbiBjb25jdXJyZW50IG1vZGUuXG4gICAgaWYgKCFjaGlsZE5vZGVzRm9yUGFyYWxsZWxSb3V0ZXIpIHtcbiAgICAgICAgY2hpbGROb2Rlcy5zZXQocGFyYWxsZWxSb3V0ZXJLZXksIG5ldyBNYXAoKSk7XG4gICAgICAgIGNoaWxkTm9kZXNGb3JQYXJhbGxlbFJvdXRlciA9IGNoaWxkTm9kZXMuZ2V0KHBhcmFsbGVsUm91dGVyS2V5KTtcbiAgICB9XG4gICAgLy8gR2V0IHRoZSBhY3RpdmUgc2VnbWVudCBpbiB0aGUgdHJlZVxuICAgIC8vIFRoZSByZWFzb24gYXJyYXlzIGFyZSB1c2VkIGluIHRoZSBkYXRhIGZvcm1hdCBpcyB0aGF0IHRoZXNlIGFyZSB0cmFuc2ZlcnJlZCBmcm9tIHRoZSBzZXJ2ZXIgdG8gdGhlIGJyb3dzZXIgc28gaXQncyBvcHRpbWl6ZWQgdG8gc2F2ZSBieXRlcy5cbiAgICBjb25zdCB0cmVlU2VnbWVudCA9IHRyZWVbMV1bcGFyYWxsZWxSb3V0ZXJLZXldWzBdO1xuICAgIGNvbnN0IGNoaWxkUHJvcFNlZ21lbnQgPSBBcnJheS5pc0FycmF5KGNoaWxkUHJvcC5zZWdtZW50KSA/IGNoaWxkUHJvcC5zZWdtZW50WzFdIDogY2hpbGRQcm9wLnNlZ21lbnQ7XG4gICAgLy8gSWYgc2VnbWVudCBpcyBhbiBhcnJheSBpdCdzIGEgZHluYW1pYyByb3V0ZSBhbmQgd2Ugd2FudCB0byByZWFkIHRoZSBkeW5hbWljIHJvdXRlIHZhbHVlIGFzIHRoZSBzZWdtZW50IHRvIGdldCBmcm9tIHRoZSBjYWNoZS5cbiAgICBjb25zdCBjdXJyZW50Q2hpbGRTZWdtZW50ID0gQXJyYXkuaXNBcnJheSh0cmVlU2VnbWVudCkgPyB0cmVlU2VnbWVudFsxXSA6IHRyZWVTZWdtZW50O1xuICAgIC8qKlxuICAgKiBEZWNpZGVzIHdoaWNoIHNlZ21lbnRzIHRvIGtlZXAgcmVuZGVyaW5nLCBhbGwgc2VnbWVudHMgdGhhdCBhcmUgbm90IGFjdGl2ZSB3aWxsIGJlIHdyYXBwZWQgaW4gYDxPZmZzY3JlZW4+YC5cbiAgICovIC8vIFRPRE8tQVBQOiBBZGQgaGFuZGxpbmcgb2YgYDxPZmZzY3JlZW4+YCB3aGVuIGl0J3MgYXZhaWxhYmxlLlxuICAgIGNvbnN0IHByZXNlcnZlZFNlZ21lbnRzID0gW1xuICAgICAgICBjdXJyZW50Q2hpbGRTZWdtZW50XG4gICAgXTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdC5kZWZhdWx0LkZyYWdtZW50LCBudWxsLCBwcmVzZXJ2ZWRTZWdtZW50cy5tYXAoKHByZXNlcnZlZFNlZ21lbnQpPT57XG4gICAgICAgIHJldHVybigvKlxuICAgICAgICAgICAgLSBFcnJvciBib3VuZGFyeVxuICAgICAgICAgICAgICAtIE9ubHkgcmVuZGVycyBlcnJvciBib3VuZGFyeSBpZiBlcnJvciBjb21wb25lbnQgaXMgcHJvdmlkZWQuXG4gICAgICAgICAgICAgIC0gUmVuZGVyZWQgZm9yIGVhY2ggc2VnbWVudCB0byBlbnN1cmUgdGhleSBoYXZlIHRoZWlyIG93biBlcnJvciBzdGF0ZS5cbiAgICAgICAgICAgIC0gTG9hZGluZyBib3VuZGFyeVxuICAgICAgICAgICAgICAtIE9ubHkgcmVuZGVycyBzdXNwZW5zZSBib3VuZGFyeSBpZiBsb2FkaW5nIGNvbXBvbmVudHMgaXMgcHJvdmlkZWQuXG4gICAgICAgICAgICAgIC0gUmVuZGVyZWQgZm9yIGVhY2ggc2VnbWVudCB0byBlbnN1cmUgdGhleSBoYXZlIHRoZWlyIG93biBsb2FkaW5nIHN0YXRlLlxuICAgICAgICAgICAgICAtIFBhc3NlZCB0byB0aGUgcm91dGVyIGR1cmluZyByZW5kZXJpbmcgdG8gZW5zdXJlIGl0IGNhbiBiZSBpbW1lZGlhdGVseSByZW5kZXJlZCB3aGVuIHN1c3BlbmRpbmcgb24gYSBGbGlnaHQgZmV0Y2guXG4gICAgICAgICAgKi8gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9hcHBSb3V0ZXJDb250ZXh0LlRlbXBsYXRlQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICAgICAga2V5OiBwcmVzZXJ2ZWRTZWdtZW50LFxuICAgICAgICAgICAgdmFsdWU6IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfZXJyb3JCb3VuZGFyeS5FcnJvckJvdW5kYXJ5LCB7XG4gICAgICAgICAgICAgICAgZXJyb3JDb21wb25lbnQ6IGVycm9yXG4gICAgICAgICAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoTG9hZGluZ0JvdW5kYXJ5LCB7XG4gICAgICAgICAgICAgICAgaGFzTG9hZGluZzogaGFzTG9hZGluZyxcbiAgICAgICAgICAgICAgICBsb2FkaW5nOiBsb2FkaW5nXG4gICAgICAgICAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoTm90Rm91bmRCb3VuZGFyeSwge1xuICAgICAgICAgICAgICAgIG5vdEZvdW5kOiBub3RGb3VuZFxuICAgICAgICAgICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFJlZGlyZWN0Qm91bmRhcnksIG51bGwsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChJbm5lckxheW91dFJvdXRlciwge1xuICAgICAgICAgICAgICAgIHBhcmFsbGVsUm91dGVyS2V5OiBwYXJhbGxlbFJvdXRlcktleSxcbiAgICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICB0cmVlOiB0cmVlLFxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZXM6IGNoaWxkTm9kZXNGb3JQYXJhbGxlbFJvdXRlcixcbiAgICAgICAgICAgICAgICBjaGlsZFByb3A6IGNoaWxkUHJvcFNlZ21lbnQgPT09IHByZXNlcnZlZFNlZ21lbnQgPyBjaGlsZFByb3AgOiBudWxsLFxuICAgICAgICAgICAgICAgIHNlZ21lbnRQYXRoOiBzZWdtZW50UGF0aCxcbiAgICAgICAgICAgICAgICBwYXRoOiBwcmVzZXJ2ZWRTZWdtZW50LFxuICAgICAgICAgICAgICAgIGlzQWN0aXZlOiBjdXJyZW50Q2hpbGRTZWdtZW50ID09PSBwcmVzZXJ2ZWRTZWdtZW50LFxuICAgICAgICAgICAgICAgIHJvb3RMYXlvdXRJbmNsdWRlZDogcm9vdExheW91dEluY2x1ZGVkXG4gICAgICAgICAgICB9KSkpKSlcbiAgICAgICAgfSwgdGVtcGxhdGUpKTtcbiAgICB9KSk7XG59XG4ndXNlIGNsaWVudCc7XG4vKipcbiAqIEFkZCByZWZldGNoIG1hcmtlciB0byByb3V0ZXIgc3RhdGUgYXQgdGhlIHBvaW50IG9mIHRoZSBjdXJyZW50IGxheW91dCBzZWdtZW50LlxuICogVGhpcyBlbnN1cmVzIHRoZSByZXNwb25zZSByZXR1cm5lZCBpcyBub3QgZnVydGhlciBkb3duIHRoYW4gdGhlIGN1cnJlbnQgbGF5b3V0IHNlZ21lbnQuXG4gKi8gZnVuY3Rpb24gd2Fsa0FkZFJlZmV0Y2goc2VnbWVudFBhdGhUb1dhbGssIHRyZWVUb1JlY3JlYXRlKSB7XG4gICAgaWYgKHNlZ21lbnRQYXRoVG9XYWxrKSB7XG4gICAgICAgIGNvbnN0IFtzZWdtZW50LCBwYXJhbGxlbFJvdXRlS2V5XSA9IHNlZ21lbnRQYXRoVG9XYWxrO1xuICAgICAgICBjb25zdCBpc0xhc3QgPSBzZWdtZW50UGF0aFRvV2Fsay5sZW5ndGggPT09IDI7XG4gICAgICAgIGlmICgoMCwgX21hdGNoU2VnbWVudHMpLm1hdGNoU2VnbWVudCh0cmVlVG9SZWNyZWF0ZVswXSwgc2VnbWVudCkpIHtcbiAgICAgICAgICAgIGlmICh0cmVlVG9SZWNyZWF0ZVsxXS5oYXNPd25Qcm9wZXJ0eShwYXJhbGxlbFJvdXRlS2V5KSkge1xuICAgICAgICAgICAgICAgIGlmIChpc0xhc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3ViVHJlZSA9IHdhbGtBZGRSZWZldGNoKHVuZGVmaW5lZCwgdHJlZVRvUmVjcmVhdGVbMV1bcGFyYWxsZWxSb3V0ZUtleV0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJlZVRvUmVjcmVhdGVbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBfZXh0ZW5kcyh7fSwgdHJlZVRvUmVjcmVhdGVbMV0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbcGFyYWxsZWxSb3V0ZUtleV06IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViVHJlZVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViVHJlZVsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViVHJlZVsyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JlZmV0Y2gnLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwgXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHRyZWVUb1JlY3JlYXRlWzBdLFxuICAgICAgICAgICAgICAgICAgICBfZXh0ZW5kcyh7fSwgdHJlZVRvUmVjcmVhdGVbMV0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFtwYXJhbGxlbFJvdXRlS2V5XTogd2Fsa0FkZFJlZmV0Y2goc2VnbWVudFBhdGhUb1dhbGsuc2xpY2UoMiksIHRyZWVUb1JlY3JlYXRlWzFdW3BhcmFsbGVsUm91dGVLZXldKVxuICAgICAgICAgICAgICAgICAgICB9KSwgXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJlZVRvUmVjcmVhdGU7XG59XG4vKipcbiAqIENoZWNrIGlmIHRoZSB0b3Agb2YgdGhlIEhUTUxFbGVtZW50IGlzIGluIHRoZSB2aWV3cG9ydC5cbiAqLyBmdW5jdGlvbiB0b3BPZkVsZW1lbnRJblZpZXdwb3J0KGVsZW1lbnQpIHtcbiAgICBjb25zdCByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4gcmVjdC50b3AgPj0gMDtcbn1cbmZ1bmN0aW9uIElubmVyTGF5b3V0Um91dGVyKHsgcGFyYWxsZWxSb3V0ZXJLZXkgLCB1cmwgLCBjaGlsZE5vZGVzICwgY2hpbGRQcm9wICwgc2VnbWVudFBhdGggLCB0cmVlICwgLy8gVE9ETy1BUFA6IGltcGxlbWVudCBgPE9mZnNjcmVlbj5gIHdoZW4gYXZhaWxhYmxlLlxuLy8gaXNBY3RpdmUsXG5wYXRoICwgcm9vdExheW91dEluY2x1ZGVkICB9KSB7XG4gICAgY29uc3QgY29udGV4dCA9ICgwLCBfcmVhY3QpLnVzZUNvbnRleHQoX2FwcFJvdXRlckNvbnRleHQuR2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dCk7XG4gICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IGdsb2JhbCBsYXlvdXQgcm91dGVyIG5vdCBtb3VudGVkJyk7XG4gICAgfVxuICAgIGNvbnN0IHsgY2hhbmdlQnlTZXJ2ZXJSZXNwb25zZSAsIHRyZWU6IGZ1bGxUcmVlICwgZm9jdXNBbmRTY3JvbGxSZWYgIH0gPSBjb250ZXh0O1xuICAgIGNvbnN0IGZvY3VzQW5kU2Nyb2xsRWxlbWVudFJlZiA9ICgwLCBfcmVhY3QpLnVzZVJlZihudWxsKTtcbiAgICAoMCwgX3JlYWN0KS51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgLy8gSGFuZGxlIHNjcm9sbCBhbmQgZm9jdXMsIGl0J3Mgb25seSBhcHBsaWVkIG9uY2UgaW4gdGhlIGZpcnN0IHVzZUVmZmVjdCB0aGF0IHRyaWdnZXJzIHRoYXQgY2hhbmdlZC5cbiAgICAgICAgaWYgKGZvY3VzQW5kU2Nyb2xsUmVmLmFwcGx5ICYmIGZvY3VzQW5kU2Nyb2xsRWxlbWVudFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAvLyBTdGF0ZSBpcyBtdXRhdGVkIHRvIGVuc3VyZSB0aGF0IHRoZSBmb2N1cyBhbmQgc2Nyb2xsIGlzIGFwcGxpZWQgb25seSBvbmNlLlxuICAgICAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWYuYXBwbHkgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIFNldCBmb2N1cyBvbiB0aGUgZWxlbWVudFxuICAgICAgICAgICAgZm9jdXNBbmRTY3JvbGxFbGVtZW50UmVmLmN1cnJlbnQuZm9jdXMoKTtcbiAgICAgICAgICAgIC8vIE9ubHkgc2Nyb2xsIGludG8gdmlld3BvcnQgd2hlbiB0aGUgbGF5b3V0IGlzIG5vdCB2aXNpYmxlIGN1cnJlbnRseS5cbiAgICAgICAgICAgIGlmICghdG9wT2ZFbGVtZW50SW5WaWV3cG9ydChmb2N1c0FuZFNjcm9sbEVsZW1lbnRSZWYuY3VycmVudCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBodG1sRWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZyA9IGh0bWxFbGVtZW50LnN0eWxlLnNjcm9sbEJlaGF2aW9yO1xuICAgICAgICAgICAgICAgIGh0bWxFbGVtZW50LnN0eWxlLnNjcm9sbEJlaGF2aW9yID0gJ2F1dG8nO1xuICAgICAgICAgICAgICAgIGZvY3VzQW5kU2Nyb2xsRWxlbWVudFJlZi5jdXJyZW50LnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgICAgICAgICAgaHRtbEVsZW1lbnQuc3R5bGUuc2Nyb2xsQmVoYXZpb3IgPSBleGlzdGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWZcbiAgICBdKTtcbiAgICAvLyBSZWFkIHNlZ21lbnQgcGF0aCBmcm9tIHRoZSBwYXJhbGxlbCByb3V0ZXIgY2FjaGUgbm9kZS5cbiAgICBsZXQgY2hpbGROb2RlID0gY2hpbGROb2Rlcy5nZXQocGF0aCk7XG4gICAgLy8gSWYgY2hpbGRQcm9wIGlzIGF2YWlsYWJsZSB0aGlzIG1lYW5zIGl0J3MgdGhlIEZsaWdodCAvIFNTUiBjYXNlLlxuICAgIGlmIChjaGlsZFByb3AgJiYgLy8gVE9ETy1BUFA6IHZlcmlmeSBpZiB0aGlzIGNhbiBiZSBudWxsIGJhc2VkIG9uIHVzZXIgY29kZVxuICAgIGNoaWxkUHJvcC5jdXJyZW50ICE9PSBudWxsICYmICFjaGlsZE5vZGUgLyomJlxuICAgICFjaGlsZFByb3AucGFydGlhbCovICkge1xuICAgICAgICAvLyBBZGQgdGhlIHNlZ21lbnQncyBzdWJUcmVlRGF0YSB0byB0aGUgY2FjaGUuXG4gICAgICAgIC8vIFRoaXMgd3JpdGVzIHRvIHRoZSBjYWNoZSB3aGVuIHRoZXJlIGlzIG5vIGl0ZW0gaW4gdGhlIGNhY2hlIHlldC4gSXQgbmV2ZXIgKm92ZXJ3cml0ZXMqIGV4aXN0aW5nIGNhY2hlIGl0ZW1zIHdoaWNoIGlzIHdoeSBpdCdzIHNhZmUgaW4gY29uY3VycmVudCBtb2RlLlxuICAgICAgICBjaGlsZE5vZGVzLnNldChwYXRoLCB7XG4gICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgc3ViVHJlZURhdGE6IGNoaWxkUHJvcC5jdXJyZW50LFxuICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoKVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gTXV0YXRlcyB0aGUgcHJvcCBpbiBvcmRlciB0byBjbGVhbiB1cCB0aGUgbWVtb3J5IGFzc29jaWF0ZWQgd2l0aCB0aGUgc3ViVHJlZURhdGEgYXMgaXQgaXMgbm93IHBhcnQgb2YgdGhlIGNhY2hlLlxuICAgICAgICBjaGlsZFByb3AuY3VycmVudCA9IG51bGw7XG4gICAgICAgIC8vIEluIHRoZSBhYm92ZSBjYXNlIGNoaWxkTm9kZSB3YXMgc2V0IG9uIGNoaWxkTm9kZXMsIHNvIHdlIGhhdmUgdG8gZ2V0IGl0IGZyb20gdGhlIGNhY2hlTm9kZXMgYWdhaW4uXG4gICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZXMuZ2V0KHBhdGgpO1xuICAgIH1cbiAgICAvLyBXaGVuIGNoaWxkTm9kZSBpcyBub3QgYXZhaWxhYmxlIGR1cmluZyByZW5kZXJpbmcgY2xpZW50LXNpZGUgd2UgbmVlZCB0byBmZXRjaCBpdCBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgaWYgKCFjaGlsZE5vZGUpIHtcbiAgICAgICAgLyoqXG4gICAgICogUm91dGVyIHN0YXRlIHdpdGggcmVmZXRjaCBtYXJrZXIgYWRkZWRcbiAgICAgKi8gLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgICAgICBjb25zdCByZWZldGNoVHJlZSA9IHdhbGtBZGRSZWZldGNoKFtcbiAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgLi4uc2VnbWVudFBhdGhcbiAgICAgICAgXSwgZnVsbFRyZWUpO1xuICAgICAgICAvKipcbiAgICAgKiBGbGlnaHQgZGF0YSBmZXRjaCBraWNrZWQgb2ZmIGR1cmluZyByZW5kZXIgYW5kIHB1dCBpbnRvIHRoZSBjYWNoZS5cbiAgICAgKi8gY2hpbGROb2Rlcy5zZXQocGF0aCwge1xuICAgICAgICAgICAgZGF0YTogKDAsIF9hcHBSb3V0ZXIpLmZldGNoU2VydmVyUmVzcG9uc2UobmV3IFVSTCh1cmwsIGxvY2F0aW9uLm9yaWdpbiksIHJlZmV0Y2hUcmVlKSxcbiAgICAgICAgICAgIHN1YlRyZWVEYXRhOiBudWxsLFxuICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoKVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gSW4gdGhlIGFib3ZlIGNhc2UgY2hpbGROb2RlIHdhcyBzZXQgb24gY2hpbGROb2Rlcywgc28gd2UgaGF2ZSB0byBnZXQgaXQgZnJvbSB0aGUgY2FjaGVOb2RlcyBhZ2Fpbi5cbiAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2Rlcy5nZXQocGF0aCk7XG4gICAgfVxuICAgIC8vIFRoaXMgY2FzZSBzaG91bGQgbmV2ZXIgaGFwcGVuIHNvIGl0IHRocm93cyBhbiBlcnJvci4gSXQgaW5kaWNhdGVzIHRoZXJlJ3MgYSBidWcgaW4gdGhlIE5leHQuanMuXG4gICAgaWYgKCFjaGlsZE5vZGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaGlsZCBub2RlIHNob3VsZCBhbHdheXMgZXhpc3QnKTtcbiAgICB9XG4gICAgLy8gVGhpcyBjYXNlIHNob3VsZCBuZXZlciBoYXBwZW4gc28gaXQgdGhyb3dzIGFuIGVycm9yLiBJdCBpbmRpY2F0ZXMgdGhlcmUncyBhIGJ1ZyBpbiB0aGUgTmV4dC5qcy5cbiAgICBpZiAoY2hpbGROb2RlLnN1YlRyZWVEYXRhICYmIGNoaWxkTm9kZS5kYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2hpbGQgbm9kZSBzaG91bGQgbm90IGhhdmUgYm90aCBzdWJUcmVlRGF0YSBhbmQgZGF0YScpO1xuICAgIH1cbiAgICAvLyBJZiBjYWNoZSBub2RlIGhhcyBhIGRhdGEgcmVxdWVzdCB3ZSBoYXZlIHRvIHVud3JhcCByZXNwb25zZSBieSBgdXNlYCBhbmQgdXBkYXRlIHRoZSBjYWNoZS5cbiAgICBpZiAoY2hpbGROb2RlLmRhdGEpIHtcbiAgICAgICAgLy8gVE9ETy1BUFA6IGVycm9yIGNhc2VcbiAgICAgICAgLyoqXG4gICAgICogRmxpZ2h0IHJlc3BvbnNlIGRhdGFcbiAgICAgKi8gLy8gV2hlbiB0aGUgZGF0YSBoYXMgbm90IHJlc29sdmVkIHlldCBgdXNlYCB3aWxsIHN1c3BlbmQgaGVyZS5cbiAgICAgICAgY29uc3QgW2ZsaWdodERhdGEsIG92ZXJyaWRlQ2Fub25pY2FsVXJsXSA9ICgwLCBfcmVhY3QpLnVzZShjaGlsZE5vZGUuZGF0YSk7XG4gICAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gbmF2aWdhdGluZyB0byBwYWdlIGluIGBwYWdlc2AgZnJvbSBgYXBwYFxuICAgICAgICBpZiAodHlwZW9mIGZsaWdodERhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybDtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNlZ21lbnRQYXRoIGZyb20gdGhlIHNlcnZlciBkb2VzIG5vdCBtYXRjaCB0aGUgbGF5b3V0J3Mgc2VnbWVudFBhdGhcbiAgICAgICAgY2hpbGROb2RlLmRhdGEgPSBudWxsO1xuICAgICAgICAvLyBzZXRUaW1lb3V0IGlzIHVzZWQgdG8gc3RhcnQgYSBuZXcgdHJhbnNpdGlvbiBkdXJpbmcgcmVuZGVyLCB0aGlzIGlzIGFuIGludGVudGlvbmFsIGhhY2sgYXJvdW5kIFJlYWN0LlxuICAgICAgICBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIHN0YXJ0VHJhbnNpdGlvbiBleGlzdHNcbiAgICAgICAgICAgIF9yZWFjdC5kZWZhdWx0LnN0YXJ0VHJhbnNpdGlvbigoKT0+e1xuICAgICAgICAgICAgICAgIC8vIFRPRE8tQVBQOiBoYW5kbGUgcmVkaXJlY3RcbiAgICAgICAgICAgICAgICBjaGFuZ2VCeVNlcnZlclJlc3BvbnNlKGZ1bGxUcmVlLCBmbGlnaHREYXRhLCBvdmVycmlkZUNhbm9uaWNhbFVybCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFN1c3BlbmQgaW5maW5pdGVseSBhcyBgY2hhbmdlQnlTZXJ2ZXJSZXNwb25zZWAgd2lsbCBjYXVzZSBhIGRpZmZlcmVudCBwYXJ0IG9mIHRoZSB0cmVlIHRvIGJlIHJlbmRlcmVkLlxuICAgICAgICAoMCwgX3JlYWN0KS51c2UoKDAsIF9pbmZpbml0ZVByb21pc2UpLmNyZWF0ZUluZmluaXRlUHJvbWlzZSgpKTtcbiAgICB9XG4gICAgLy8gSWYgY2FjaGUgbm9kZSBoYXMgbm8gc3ViVHJlZURhdGEgYW5kIG5vIGRhdGEgcmVxdWVzdCB3ZSBoYXZlIHRvIGluZmluaXRlbHkgc3VzcGVuZCBhcyB0aGUgZGF0YSB3aWxsIGxpa2VseSBmbG93IGluIGZyb20gYW5vdGhlciBwbGFjZS5cbiAgICAvLyBUT0RPLUFQUDogZG91YmxlIGNoZWNrIHVzZXJzIGNhbid0IHJldHVybiBudWxsIGluIGEgY29tcG9uZW50IHRoYXQgd2lsbCBraWNrIGluIGhlcmUuXG4gICAgaWYgKCFjaGlsZE5vZGUuc3ViVHJlZURhdGEpIHtcbiAgICAgICAgKDAsIF9yZWFjdCkudXNlKCgwLCBfaW5maW5pdGVQcm9taXNlKS5jcmVhdGVJbmZpbml0ZVByb21pc2UoKSk7XG4gICAgfVxuICAgIGNvbnN0IHN1YnRyZWUgPSAvLyBUaGUgbGF5b3V0IHJvdXRlciBjb250ZXh0IG5hcnJvd3MgZG93biB0cmVlIGFuZCBjaGlsZE5vZGVzIGF0IGVhY2ggbGV2ZWwuXG4gICAgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9hcHBSb3V0ZXJDb250ZXh0LkxheW91dFJvdXRlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHRyZWU6IHRyZWVbMV1bcGFyYWxsZWxSb3V0ZXJLZXldLFxuICAgICAgICAgICAgY2hpbGROb2RlczogY2hpbGROb2RlLnBhcmFsbGVsUm91dGVzLFxuICAgICAgICAgICAgLy8gVE9ETy1BUFA6IG92ZXJyaWRpbmcgb2YgdXJsIGZvciBwYXJhbGxlbCByb3V0ZXNcbiAgICAgICAgICAgIHVybDogdXJsXG4gICAgICAgIH1cbiAgICB9LCBjaGlsZE5vZGUuc3ViVHJlZURhdGEpO1xuICAgIC8vIEVuc3VyZSByb290IGxheW91dCBpcyBub3Qgd3JhcHBlZCBpbiBhIGRpdiBhcyB0aGUgcm9vdCBsYXlvdXQgcmVuZGVycyBgPGh0bWw+YFxuICAgIHJldHVybiByb290TGF5b3V0SW5jbHVkZWQgPyAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICByZWY6IGZvY3VzQW5kU2Nyb2xsRWxlbWVudFJlZixcbiAgICAgICAgXCJkYXRhLW5leHRqcy1zY3JvbGwtZm9jdXMtYm91bmRhcnlcIjogJydcbiAgICB9LCBzdWJ0cmVlKSA6IHN1YnRyZWU7XG59XG4vKipcbiAqIFJlbmRlcnMgc3VzcGVuc2UgYm91bmRhcnkgd2l0aCB0aGUgcHJvdmlkZWQgXCJsb2FkaW5nXCIgcHJvcGVydHkgYXMgdGhlIGZhbGxiYWNrLlxuICogSWYgbm8gbG9hZGluZyBwcm9wZXJ0eSBpcyBwcm92aWRlZCBpdCByZW5kZXJzIHRoZSBjaGlsZHJlbiB3aXRob3V0IGEgc3VzcGVuc2UgYm91bmRhcnkuXG4gKi8gZnVuY3Rpb24gTG9hZGluZ0JvdW5kYXJ5KHsgY2hpbGRyZW4gLCBsb2FkaW5nICwgaGFzTG9hZGluZyAgfSkge1xuICAgIGlmIChoYXNMb2FkaW5nKSB7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETy1BUFA6IFJlYWN0LlN1c3BlbnNlIGZhbGxiYWNrIHR5cGUgaXMgd3JvbmdcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcmVhY3QuZGVmYXVsdC5TdXNwZW5zZSwge1xuICAgICAgICAgICAgZmFsbGJhY2s6IGxvYWRpbmdcbiAgICAgICAgfSwgY2hpbGRyZW4pO1xuICAgIH1cbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdC5kZWZhdWx0LkZyYWdtZW50LCBudWxsLCBjaGlsZHJlbik7XG59XG5mdW5jdGlvbiBIYW5kbGVSZWRpcmVjdCh7IHJlZGlyZWN0ICB9KSB7XG4gICAgY29uc3Qgcm91dGVyID0gKDAsIF9uYXZpZ2F0aW9uKS51c2VSb3V0ZXIoKTtcbiAgICAoMCwgX3JlYWN0KS51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgcm91dGVyLnJlcGxhY2UocmVkaXJlY3QsIHt9KTtcbiAgICB9LCBbXG4gICAgICAgIHJlZGlyZWN0LFxuICAgICAgICByb3V0ZXJcbiAgICBdKTtcbiAgICByZXR1cm4gbnVsbDtcbn1cbmNsYXNzIFJlZGlyZWN0RXJyb3JCb3VuZGFyeSBleHRlbmRzIF9yZWFjdC5kZWZhdWx0LkNvbXBvbmVudCB7XG4gICAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvcikge1xuICAgICAgICB2YXIgcmVmO1xuICAgICAgICBpZiAoKHJlZiA9IGVycm9yLmRpZ2VzdCkgPT0gbnVsbCA/IHZvaWQgMCA6IHJlZi5zdGFydHNXaXRoKCdORVhUX1JFRElSRUNUJykpIHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IGVycm9yLmRpZ2VzdC5zcGxpdCgnOycpWzFdO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByZWRpcmVjdDogdXJsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlLXRocm93IGlmIGVycm9yIGlzIG5vdCBmb3IgcmVkaXJlY3RcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgcmVkaXJlY3QgPSB0aGlzLnN0YXRlLnJlZGlyZWN0O1xuICAgICAgICBpZiAocmVkaXJlY3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoSGFuZGxlUmVkaXJlY3QsIHtcbiAgICAgICAgICAgICAgICByZWRpcmVjdDogcmVkaXJlY3RcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcyl7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHJlZGlyZWN0OiBudWxsXG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gUmVkaXJlY3RCb3VuZGFyeSh7IGNoaWxkcmVuICB9KSB7XG4gICAgY29uc3Qgcm91dGVyID0gKDAsIF9uYXZpZ2F0aW9uKS51c2VSb3V0ZXIoKTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFJlZGlyZWN0RXJyb3JCb3VuZGFyeSwge1xuICAgICAgICByb3V0ZXI6IHJvdXRlclxuICAgIH0sIGNoaWxkcmVuKTtcbn1cbmNsYXNzIE5vdEZvdW5kRXJyb3JCb3VuZGFyeSBleHRlbmRzIF9yZWFjdC5kZWZhdWx0LkNvbXBvbmVudCB7XG4gICAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IuZGlnZXN0ID09PSAnTkVYVF9OT1RfRk9VTkQnKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5vdEZvdW5kVHJpZ2dlcmVkOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlLXRocm93IGlmIGVycm9yIGlzIG5vdCBmb3IgNDA0XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLm5vdEZvdW5kVHJpZ2dlcmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdC5kZWZhdWx0LkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIsIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcInJvYm90c1wiLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwibm9pbmRleFwiXG4gICAgICAgICAgICB9KSwgdGhpcy5wcm9wcy5ub3RGb3VuZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW47XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHByb3BzKXtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgbm90Rm91bmRUcmlnZ2VyZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gTm90Rm91bmRCb3VuZGFyeSh7IG5vdEZvdW5kICwgY2hpbGRyZW4gIH0pIHtcbiAgICByZXR1cm4gbm90Rm91bmQgPyAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoTm90Rm91bmRFcnJvckJvdW5kYXJ5LCB7XG4gICAgICAgIG5vdEZvdW5kOiBub3RGb3VuZFxuICAgIH0sIGNoaWxkcmVuKSA6IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcmVhY3QuZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4pO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYXlvdXQtcm91dGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImRlZmF1bHQiLCJPdXRlckxheW91dFJvdXRlciIsIklubmVyTGF5b3V0Um91dGVyIiwiX2V4dGVuZHMiLCJyZXF1aXJlIiwiX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCIsIl9yZWFjdCIsIl9hcHBSb3V0ZXJDb250ZXh0IiwiX2FwcFJvdXRlciIsIl9pbmZpbml0ZVByb21pc2UiLCJfZXJyb3JCb3VuZGFyeSIsIl9tYXRjaFNlZ21lbnRzIiwiX25hdmlnYXRpb24iLCJwYXJhbGxlbFJvdXRlcktleSIsInNlZ21lbnRQYXRoIiwiY2hpbGRQcm9wIiwiZXJyb3IiLCJsb2FkaW5nIiwiaGFzTG9hZGluZyIsInRlbXBsYXRlIiwibm90Rm91bmQiLCJyb290TGF5b3V0SW5jbHVkZWQiLCJjb250ZXh0IiwidXNlQ29udGV4dCIsIkxheW91dFJvdXRlckNvbnRleHQiLCJFcnJvciIsImNoaWxkTm9kZXMiLCJ0cmVlIiwidXJsIiwiY2hpbGROb2Rlc0ZvclBhcmFsbGVsUm91dGVyIiwiZ2V0Iiwic2V0IiwiTWFwIiwidHJlZVNlZ21lbnQiLCJjaGlsZFByb3BTZWdtZW50IiwiQXJyYXkiLCJpc0FycmF5Iiwic2VnbWVudCIsImN1cnJlbnRDaGlsZFNlZ21lbnQiLCJwcmVzZXJ2ZWRTZWdtZW50cyIsImNyZWF0ZUVsZW1lbnQiLCJGcmFnbWVudCIsIm1hcCIsInByZXNlcnZlZFNlZ21lbnQiLCJUZW1wbGF0ZUNvbnRleHQiLCJQcm92aWRlciIsImtleSIsIkVycm9yQm91bmRhcnkiLCJlcnJvckNvbXBvbmVudCIsIkxvYWRpbmdCb3VuZGFyeSIsIk5vdEZvdW5kQm91bmRhcnkiLCJSZWRpcmVjdEJvdW5kYXJ5IiwicGF0aCIsImlzQWN0aXZlIiwid2Fsa0FkZFJlZmV0Y2giLCJzZWdtZW50UGF0aFRvV2FsayIsInRyZWVUb1JlY3JlYXRlIiwicGFyYWxsZWxSb3V0ZUtleSIsImlzTGFzdCIsImxlbmd0aCIsIm1hdGNoU2VnbWVudCIsImhhc093blByb3BlcnR5Iiwic3ViVHJlZSIsInVuZGVmaW5lZCIsInNsaWNlIiwidG9wT2ZFbGVtZW50SW5WaWV3cG9ydCIsImVsZW1lbnQiLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwidG9wIiwiR2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dCIsImNoYW5nZUJ5U2VydmVyUmVzcG9uc2UiLCJmdWxsVHJlZSIsImZvY3VzQW5kU2Nyb2xsUmVmIiwiZm9jdXNBbmRTY3JvbGxFbGVtZW50UmVmIiwidXNlUmVmIiwidXNlRWZmZWN0IiwiYXBwbHkiLCJjdXJyZW50IiwiZm9jdXMiLCJodG1sRWxlbWVudCIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiZXhpc3RpbmciLCJzdHlsZSIsInNjcm9sbEJlaGF2aW9yIiwic2Nyb2xsSW50b1ZpZXciLCJjaGlsZE5vZGUiLCJkYXRhIiwic3ViVHJlZURhdGEiLCJwYXJhbGxlbFJvdXRlcyIsInJlZmV0Y2hUcmVlIiwiZmV0Y2hTZXJ2ZXJSZXNwb25zZSIsIlVSTCIsImxvY2F0aW9uIiwib3JpZ2luIiwidXNlIiwiZmxpZ2h0RGF0YSIsIm92ZXJyaWRlQ2Fub25pY2FsVXJsIiwid2luZG93IiwiaHJlZiIsInNldFRpbWVvdXQiLCJzdGFydFRyYW5zaXRpb24iLCJjcmVhdGVJbmZpbml0ZVByb21pc2UiLCJzdWJ0cmVlIiwicmVmIiwiY2hpbGRyZW4iLCJTdXNwZW5zZSIsImZhbGxiYWNrIiwiSGFuZGxlUmVkaXJlY3QiLCJyZWRpcmVjdCIsInJvdXRlciIsInVzZVJvdXRlciIsInJlcGxhY2UiLCJSZWRpcmVjdEVycm9yQm91bmRhcnkiLCJwcm9wcyIsInN0YXRlIiwicmVuZGVyIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIiwiZGlnZXN0Iiwic3RhcnRzV2l0aCIsInNwbGl0IiwiQ29tcG9uZW50IiwiTm90Rm91bmRFcnJvckJvdW5kYXJ5Iiwibm90Rm91bmRUcmlnZ2VyZWQiLCJuYW1lIiwiY29udGVudCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./.yarn/__virtual__/next-virtual-393d91bbcd/0/cache/next-npm-13.0.2-b39abd22d0-f6fea2ee34.zip/node_modules/next/dist/client/components/layout-router.js\n"));

/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-393d91bbcd/0/cache/next-npm-13.0.2-b39abd22d0-f6fea2ee34.zip/node_modules/next/dist/client/components/match-segments.js":
/*!****************************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-393d91bbcd/0/cache/next-npm-13.0.2-b39abd22d0-f6fea2ee34.zip/node_modules/next/dist/client/components/match-segments.js ***!
  \****************************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.matchSegment = void 0;\nvar matchSegment = function(existingSegment, segment) {\n    // Common case: segment is just a string\n    if (typeof existingSegment === \"string\" && typeof segment === \"string\") {\n        return existingSegment === segment;\n    }\n    // Dynamic parameter case: segment is an array with param/value. Both param and value are compared.\n    if (Array.isArray(existingSegment) && Array.isArray(segment)) {\n        return existingSegment[0] === segment[0] && existingSegment[1] === segment[1];\n    }\n    return false;\n};\nexports.matchSegment = matchSegment;\nif ((typeof exports[\"default\"] === \"function\" || typeof exports[\"default\"] === \"object\" && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === \"undefined\") {\n    Object.defineProperty(exports[\"default\"], \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports[\"default\"], exports);\n    module.exports = exports[\"default\"];\n} //# sourceMappingURL=match-segments.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi8ueWFybi9fX3ZpcnR1YWxfXy9uZXh0LXZpcnR1YWwtMzkzZDkxYmJjZC8wL2NhY2hlL25leHQtbnBtLTEzLjAuMi1iMzlhYmQyMmQwLWY2ZmVhMmVlMzQuemlwL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvbWF0Y2gtc2VnbWVudHMuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsb0JBQW9CLEdBQUcsS0FBSztBQUM1QixJQUFNRSxlQUFlLFNBQUNDLGlCQUFpQkMsU0FBVTtJQUM3Qyx3Q0FBd0M7SUFDeEMsSUFBSSxPQUFPRCxvQkFBb0IsWUFBWSxPQUFPQyxZQUFZLFVBQVU7UUFDcEUsT0FBT0Qsb0JBQW9CQztJQUMvQixDQUFDO0lBQ0QsbUdBQW1HO0lBQ25HLElBQUlDLE1BQU1DLE9BQU8sQ0FBQ0gsb0JBQW9CRSxNQUFNQyxPQUFPLENBQUNGLFVBQVU7UUFDMUQsT0FBT0QsZUFBZSxDQUFDLEVBQUUsS0FBS0MsT0FBTyxDQUFDLEVBQUUsSUFBSUQsZUFBZSxDQUFDLEVBQUUsS0FBS0MsT0FBTyxDQUFDLEVBQUU7SUFDakYsQ0FBQztJQUNELE9BQU8sS0FBSztBQUNoQjtBQUNBSixvQkFBb0IsR0FBR0U7QUFFdkIsSUFBSSxDQUFDLE9BQU9GLE9BQVFPLENBQUFBLFVBQU8sS0FBSyxjQUFlLE9BQU9QLE9BQVFPLENBQUFBLFVBQU8sS0FBSyxZQUFZUCxPQUFRTyxDQUFBQSxVQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9QLE9BQVFPLENBQUFBLFVBQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktWLE9BQU9DLGNBQWMsQ0FBQ0MsT0FBUU8sQ0FBQUEsVUFBTyxFQUFFLGNBQWM7UUFBRU4sT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9XLE1BQU0sQ0FBQ1QsT0FBUU8sQ0FBQUEsVUFBTyxFQUFFUDtJQUMvQlUsT0FBT1YsT0FBTyxHQUFHQSxPQUFRTyxDQUFBQSxVQUFPO0FBQ2xDLENBQUMsQ0FFRCwwQ0FBMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vX192aXJ0dWFsX18vbmV4dC12aXJ0dWFsLTM5M2Q5MWJiY2QvMC9jYWNoZS9uZXh0LW5wbS0xMy4wLjItYjM5YWJkMjJkMC1mNmZlYTJlZTM0LnppcC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL21hdGNoLXNlZ21lbnRzLmpzP2FlYTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLm1hdGNoU2VnbWVudCA9IHZvaWQgMDtcbmNvbnN0IG1hdGNoU2VnbWVudCA9IChleGlzdGluZ1NlZ21lbnQsIHNlZ21lbnQpPT57XG4gICAgLy8gQ29tbW9uIGNhc2U6IHNlZ21lbnQgaXMganVzdCBhIHN0cmluZ1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmdTZWdtZW50ID09PSAnc3RyaW5nJyAmJiB0eXBlb2Ygc2VnbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nU2VnbWVudCA9PT0gc2VnbWVudDtcbiAgICB9XG4gICAgLy8gRHluYW1pYyBwYXJhbWV0ZXIgY2FzZTogc2VnbWVudCBpcyBhbiBhcnJheSB3aXRoIHBhcmFtL3ZhbHVlLiBCb3RoIHBhcmFtIGFuZCB2YWx1ZSBhcmUgY29tcGFyZWQuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXhpc3RpbmdTZWdtZW50KSAmJiBBcnJheS5pc0FycmF5KHNlZ21lbnQpKSB7XG4gICAgICAgIHJldHVybiBleGlzdGluZ1NlZ21lbnRbMF0gPT09IHNlZ21lbnRbMF0gJiYgZXhpc3RpbmdTZWdtZW50WzFdID09PSBzZWdtZW50WzFdO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuZXhwb3J0cy5tYXRjaFNlZ21lbnQgPSBtYXRjaFNlZ21lbnQ7XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdGNoLXNlZ21lbnRzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1hdGNoU2VnbWVudCIsImV4aXN0aW5nU2VnbWVudCIsInNlZ21lbnQiLCJBcnJheSIsImlzQXJyYXkiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./.yarn/__virtual__/next-virtual-393d91bbcd/0/cache/next-npm-13.0.2-b39abd22d0-f6fea2ee34.zip/node_modules/next/dist/client/components/match-segments.js\n"));

/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-393d91bbcd/0/cache/next-npm-13.0.2-b39abd22d0-f6fea2ee34.zip/node_modules/next/dist/client/components/reducer.js":
/*!*********************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-393d91bbcd/0/cache/next-npm-13.0.2-b39abd22d0-f6fea2ee34.zip/node_modules/next/dist/client/components/reducer.js ***!
  \*********************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _iterableToArrayLimit(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.reducer = exports.ACTION_PREFETCH = exports.ACTION_SERVER_PATCH = exports.ACTION_RESTORE = exports.ACTION_NAVIGATE = exports.ACTION_REFRESH = void 0;\nvar _extends = (__webpack_require__(/*! @swc/helpers/lib/_extends.js */ \"./.yarn/cache/@swc-helpers-npm-0.4.11-d20747f9c8-736857d524.zip/node_modules/@swc/helpers/lib/_extends.js\")[\"default\"]);\nvar _matchSegments = __webpack_require__(/*! ./match-segments */ \"./.yarn/__virtual__/next-virtual-393d91bbcd/0/cache/next-npm-13.0.2-b39abd22d0-f6fea2ee34.zip/node_modules/next/dist/client/components/match-segments.js\");\nvar _appRouter = __webpack_require__(/*! ./app-router */ \"./.yarn/__virtual__/next-virtual-393d91bbcd/0/cache/next-npm-13.0.2-b39abd22d0-f6fea2ee34.zip/node_modules/next/dist/client/components/app-router.js\");\n/**\n * Create data fetching record for Promise.\n */ // TODO-APP: change `any` to type inference.\nfunction createRecordFromThenable(thenable) {\n    thenable.status = \"pending\";\n    thenable.then(function(value) {\n        if (thenable.status === \"pending\") {\n            thenable.status = \"fulfilled\";\n            thenable.value = value;\n        }\n    }, function(err) {\n        if (thenable.status === \"pending\") {\n            thenable.status = \"rejected\";\n            thenable.value = err;\n        }\n    });\n    return thenable;\n}\n/**\n * Read record value or throw Promise if it's not resolved yet.\n */ function readRecordValue(thenable) {\n    if (thenable.status === \"fulfilled\") {\n        return thenable.value;\n    } else {\n        throw thenable;\n    }\n}\nfunction createHrefFromUrl(url) {\n    return url.pathname + url.search + url.hash;\n}\n/**\n * Invalidate cache one level down from the router state.\n */ // TODO-APP: Verify if this needs to be recursive.\nfunction invalidateCacheByRouterState(newCache, existingCache, routerState) {\n    // Remove segment that we got data for so that it is filled in during rendering of subTreeData.\n    for(var key in routerState[1]){\n        var segmentForParallelRoute = routerState[1][key][0];\n        var cacheKey = Array.isArray(segmentForParallelRoute) ? segmentForParallelRoute[1] : segmentForParallelRoute;\n        var existingParallelRoutesCacheNode = existingCache.parallelRoutes.get(key);\n        if (existingParallelRoutesCacheNode) {\n            var parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode);\n            parallelRouteCacheNode[\"delete\"](cacheKey);\n            newCache.parallelRoutes.set(key, parallelRouteCacheNode);\n        }\n    }\n}\n/**\n * Fill cache with subTreeData based on flightDataPath\n */ function fillCacheWithNewSubTreeData(newCache, existingCache, flightDataPath) {\n    var isLastEntry = flightDataPath.length <= 4;\n    var _flightDataPath = _slicedToArray(flightDataPath, 2), parallelRouteKey = _flightDataPath[0], segment = _flightDataPath[1];\n    var segmentForCache = Array.isArray(segment) ? segment[1] : segment;\n    var existingChildSegmentMap = existingCache.parallelRoutes.get(parallelRouteKey);\n    if (!existingChildSegmentMap) {\n        // Bailout because the existing cache does not have the path to the leaf node\n        // Will trigger lazy fetch in layout-router because of missing segment\n        return;\n    }\n    var childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey);\n    if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n        childSegmentMap = new Map(existingChildSegmentMap);\n        newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap);\n    }\n    var existingChildCacheNode = existingChildSegmentMap.get(segmentForCache);\n    var childCacheNode = childSegmentMap.get(segmentForCache);\n    // In case of last segment start the fetch at this level and don't copy further down.\n    if (isLastEntry) {\n        if (!childCacheNode || !childCacheNode.data || childCacheNode === existingChildCacheNode) {\n            childCacheNode = {\n                data: null,\n                subTreeData: flightDataPath[3],\n                // Ensure segments other than the one we got data for are preserved.\n                parallelRoutes: existingChildCacheNode ? new Map(existingChildCacheNode.parallelRoutes) : new Map()\n            };\n            if (existingChildCacheNode) {\n                invalidateCacheByRouterState(childCacheNode, existingChildCacheNode, flightDataPath[2]);\n            }\n            childSegmentMap.set(segmentForCache, childCacheNode);\n        }\n        return;\n    }\n    if (!childCacheNode || !existingChildCacheNode) {\n        // Bailout because the existing cache does not have the path to the leaf node\n        // Will trigger lazy fetch in layout-router because of missing segment\n        return;\n    }\n    if (childCacheNode === existingChildCacheNode) {\n        childCacheNode = {\n            data: childCacheNode.data,\n            subTreeData: childCacheNode.subTreeData,\n            parallelRoutes: new Map(childCacheNode.parallelRoutes)\n        };\n        childSegmentMap.set(segmentForCache, childCacheNode);\n    }\n    fillCacheWithNewSubTreeData(childCacheNode, existingChildCacheNode, flightDataPath.slice(2));\n}\n/**\n * Fill cache up to the end of the flightSegmentPath, invalidating anything below it.\n */ function invalidateCacheBelowFlightSegmentPath(newCache, existingCache, flightSegmentPath) {\n    var isLastEntry = flightSegmentPath.length <= 2;\n    var _flightSegmentPath = _slicedToArray(flightSegmentPath, 2), parallelRouteKey = _flightSegmentPath[0], segment = _flightSegmentPath[1];\n    var segmentForCache = Array.isArray(segment) ? segment[1] : segment;\n    var existingChildSegmentMap = existingCache.parallelRoutes.get(parallelRouteKey);\n    if (!existingChildSegmentMap) {\n        // Bailout because the existing cache does not have the path to the leaf node\n        // Will trigger lazy fetch in layout-router because of missing segment\n        return;\n    }\n    var childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey);\n    if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n        childSegmentMap = new Map(existingChildSegmentMap);\n        newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap);\n    }\n    // In case of last entry don't copy further down.\n    if (isLastEntry) {\n        childSegmentMap[\"delete\"](segmentForCache);\n        return;\n    }\n    var existingChildCacheNode = existingChildSegmentMap.get(segmentForCache);\n    var childCacheNode = childSegmentMap.get(segmentForCache);\n    if (!childCacheNode || !existingChildCacheNode) {\n        // Bailout because the existing cache does not have the path to the leaf node\n        // Will trigger lazy fetch in layout-router because of missing segment\n        return;\n    }\n    if (childCacheNode === existingChildCacheNode) {\n        childCacheNode = {\n            data: childCacheNode.data,\n            subTreeData: childCacheNode.subTreeData,\n            parallelRoutes: new Map(childCacheNode.parallelRoutes)\n        };\n        childSegmentMap.set(segmentForCache, childCacheNode);\n    }\n    invalidateCacheBelowFlightSegmentPath(childCacheNode, existingChildCacheNode, flightSegmentPath.slice(2));\n}\n/**\n * Fill cache with subTreeData based on flightDataPath that was prefetched\n * This operation is append-only to the existing cache.\n */ function fillCacheWithPrefetchedSubTreeData(existingCache, flightDataPath) {\n    var isLastEntry = flightDataPath.length <= 4;\n    var _flightDataPath = _slicedToArray(flightDataPath, 2), parallelRouteKey = _flightDataPath[0], segment = _flightDataPath[1];\n    var segmentForCache = Array.isArray(segment) ? segment[1] : segment;\n    var existingChildSegmentMap = existingCache.parallelRoutes.get(parallelRouteKey);\n    if (!existingChildSegmentMap) {\n        // Bailout because the existing cache does not have the path to the leaf node\n        return;\n    }\n    var existingChildCacheNode = existingChildSegmentMap.get(segmentForCache);\n    if (isLastEntry) {\n        if (!existingChildCacheNode) {\n            existingChildSegmentMap.set(segmentForCache, {\n                data: null,\n                subTreeData: flightDataPath[3],\n                parallelRoutes: new Map()\n            });\n        }\n        return;\n    }\n    if (!existingChildCacheNode) {\n        // Bailout because the existing cache does not have the path to the leaf node\n        return;\n    }\n    fillCacheWithPrefetchedSubTreeData(existingChildCacheNode, flightDataPath.slice(2));\n}\n/**\n * Kick off fetch based on the common layout between two routes. Fill cache with data property holding the in-progress fetch.\n */ function fillCacheWithDataProperty(newCache, existingCache, segments, fetchResponse) {\n    var isLastEntry = segments.length === 1;\n    var parallelRouteKey = \"children\";\n    var _segments = _slicedToArray(segments, 1), segment = _segments[0];\n    var existingChildSegmentMap = existingCache.parallelRoutes.get(parallelRouteKey);\n    if (!existingChildSegmentMap) {\n        // Bailout because the existing cache does not have the path to the leaf node\n        // Will trigger lazy fetch in layout-router because of missing segment\n        return {\n            bailOptimistic: true\n        };\n    }\n    var childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey);\n    if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n        childSegmentMap = new Map(existingChildSegmentMap);\n        newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap);\n    }\n    var existingChildCacheNode = existingChildSegmentMap.get(segment);\n    var childCacheNode = childSegmentMap.get(segment);\n    // In case of last segment start off the fetch at this level and don't copy further down.\n    if (isLastEntry) {\n        if (!childCacheNode || !childCacheNode.data || childCacheNode === existingChildCacheNode) {\n            childSegmentMap.set(segment, {\n                data: fetchResponse(),\n                subTreeData: null,\n                parallelRoutes: new Map()\n            });\n        }\n        return;\n    }\n    if (!childCacheNode || !existingChildCacheNode) {\n        // Start fetch in the place where the existing cache doesn't have the data yet.\n        if (!childCacheNode) {\n            childSegmentMap.set(segment, {\n                data: fetchResponse(),\n                subTreeData: null,\n                parallelRoutes: new Map()\n            });\n        }\n        return;\n    }\n    if (childCacheNode === existingChildCacheNode) {\n        childCacheNode = {\n            data: childCacheNode.data,\n            subTreeData: childCacheNode.subTreeData,\n            parallelRoutes: new Map(childCacheNode.parallelRoutes)\n        };\n        childSegmentMap.set(segment, childCacheNode);\n    }\n    return fillCacheWithDataProperty(childCacheNode, existingChildCacheNode, segments.slice(1), fetchResponse);\n}\n/**\n * Create optimistic version of router state based on the existing router state and segments.\n * This is used to allow rendering layout-routers up till the point where data is missing.\n */ function createOptimisticTree(segments, flightRouterState, _isFirstSegment, parentRefetch, _href) {\n    var ref = _slicedToArray(flightRouterState || [\n        null,\n        {}\n    ], 2), existingSegment = ref[0], existingParallelRoutes = ref[1];\n    var segment = segments[0];\n    var isLastSegment = segments.length === 1;\n    var segmentMatches = existingSegment !== null && (0, _matchSegments).matchSegment(existingSegment, segment);\n    var shouldRefetchThisLevel = !flightRouterState || !segmentMatches;\n    var parallelRoutes = {};\n    if (existingSegment !== null && segmentMatches) {\n        parallelRoutes = existingParallelRoutes;\n    }\n    var childTree;\n    if (!isLastSegment) {\n        var childItem = createOptimisticTree(segments.slice(1), parallelRoutes ? parallelRoutes.children : null, false, parentRefetch || shouldRefetchThisLevel);\n        childTree = childItem;\n    }\n    var result = [\n        segment,\n        _extends({}, parallelRoutes, childTree ? {\n            children: childTree\n        } : {})\n    ];\n    if (!parentRefetch && shouldRefetchThisLevel) {\n        result[3] = \"refetch\";\n    }\n    // TODO-APP: Revisit\n    // Add url into the tree\n    // if (isFirstSegment) {\n    //   result[2] = href\n    // }\n    return result;\n}\n/**\n * Apply the router state from the Flight response. Creates a new router state tree.\n */ function applyRouterStatePatchToTree(flightSegmentPath, flightRouterState, treePatch) {\n    var _flightRouterState = _slicedToArray(flightRouterState, 5), segment = _flightRouterState[0], parallelRoutes = _flightRouterState[1], isRootLayout = _flightRouterState[4];\n    // Root refresh\n    if (flightSegmentPath.length === 1) {\n        var tree = _toConsumableArray(treePatch);\n        // TODO-APP: revisit\n        // if (url) {\n        //   tree[2] = url\n        // }\n        return tree;\n    }\n    var _flightSegmentPath = _slicedToArray(flightSegmentPath, 2), currentSegment = _flightSegmentPath[0], parallelRouteKey = _flightSegmentPath[1];\n    // Tree path returned from the server should always match up with the current tree in the browser\n    if (!(0, _matchSegments).matchSegment(currentSegment, segment)) {\n        return null;\n    }\n    var lastSegment = flightSegmentPath.length === 2;\n    var parallelRoutePatch;\n    if (lastSegment) {\n        parallelRoutePatch = treePatch;\n    } else {\n        parallelRoutePatch = applyRouterStatePatchToTree(flightSegmentPath.slice(2), parallelRoutes[parallelRouteKey], treePatch);\n        if (parallelRoutePatch === null) {\n            return null;\n        }\n    }\n    var tree1 = [\n        flightSegmentPath[0],\n        _extends({}, parallelRoutes, _defineProperty({}, parallelRouteKey, parallelRoutePatch))\n    ];\n    // Current segment is the root layout\n    if (isRootLayout) {\n        tree1[4] = true;\n    }\n    // TODO-APP: Revisit\n    // if (url) {\n    //   tree[2] = url\n    // }\n    return tree1;\n}\nfunction shouldHardNavigate(flightSegmentPath, flightRouterState, treePatch) {\n    var _flightRouterState = _slicedToArray(flightRouterState, 2), segment = _flightRouterState[0], parallelRoutes = _flightRouterState[1];\n    // TODO-APP: Check if `as` can be replaced.\n    var _flightSegmentPath = _slicedToArray(flightSegmentPath, 2), currentSegment = _flightSegmentPath[0], parallelRouteKey = _flightSegmentPath[1];\n    // Check if current segment matches the existing segment.\n    if (!(0, _matchSegments).matchSegment(currentSegment, segment)) {\n        // If dynamic parameter in tree doesn't match up with segment path a hard navigation is triggered.\n        if (Array.isArray(currentSegment)) {\n            return true;\n        }\n        // If the existing segment did not match soft navigation is triggered.\n        return false;\n    }\n    var lastSegment = flightSegmentPath.length <= 2;\n    if (lastSegment) {\n        return false;\n    }\n    return shouldHardNavigate(flightSegmentPath.slice(2), parallelRoutes[parallelRouteKey], treePatch);\n}\nfunction isNavigatingToNewRootLayout(currentTree, nextTree) {\n    // Compare segments\n    var currentTreeSegment = currentTree[0];\n    var nextTreeSegment = nextTree[0];\n    // If any segment is different before we find the root layout, the root layout has changed.\n    // E.g. /same/(group1)/layout.js -> /same/(group2)/layout.js\n    // First segment is 'same' for both, keep looking. (group1) changed to (group2) before the root layout was found, it must have changed.\n    if (Array.isArray(currentTreeSegment) && Array.isArray(nextTreeSegment)) {\n        // Compare dynamic param name and type but ignore the value, different values would not affect the current root layout\n        // /[name] - /slug1 and /slug2, both values (slug1 & slug2) still has the same layout /[name]/layout.js\n        if (currentTreeSegment[0] !== nextTreeSegment[0] || currentTreeSegment[2] !== nextTreeSegment[2]) {\n            return true;\n        }\n    } else if (currentTreeSegment !== nextTreeSegment) {\n        return true;\n    }\n    // Current tree root layout found\n    if (currentTree[4]) {\n        // If the next tree doesn't have the root layout flag, it must have changed.\n        return !nextTree[4];\n    }\n    // Current tree  didn't have its root layout here, must have changed.\n    if (nextTree[4]) {\n        return true;\n    }\n    // We can't assume it's `parallelRoutes.children` here in case the root layout is `app/@something/layout.js`\n    // But it's not possible to be more than one parallelRoutes before the root layout is found\n    // TODO-APP: change to traverse all parallel routes\n    var currentTreeChild = Object.values(currentTree[1])[0];\n    var nextTreeChild = Object.values(nextTree[1])[0];\n    if (!currentTreeChild || !nextTreeChild) return true;\n    return isNavigatingToNewRootLayout(currentTreeChild, nextTreeChild);\n}\nvar ACTION_REFRESH = \"refresh\";\nexports.ACTION_REFRESH = ACTION_REFRESH;\nvar ACTION_NAVIGATE = \"navigate\";\nexports.ACTION_NAVIGATE = ACTION_NAVIGATE;\nvar ACTION_RESTORE = \"restore\";\nexports.ACTION_RESTORE = ACTION_RESTORE;\nvar ACTION_SERVER_PATCH = \"server-patch\";\nexports.ACTION_SERVER_PATCH = ACTION_SERVER_PATCH;\nvar ACTION_PREFETCH = \"prefetch\";\nexports.ACTION_PREFETCH = ACTION_PREFETCH;\n/**\n * Reducer that handles the app-router state updates.\n */ function clientReducer(state, action) {\n    switch(action.type){\n        case ACTION_NAVIGATE:\n            {\n                var url = action.url, navigateType = action.navigateType, cache = action.cache, mutable = action.mutable, forceOptimisticNavigation = action.forceOptimisticNavigation;\n                var pathname = url.pathname, search = url.search;\n                var href = createHrefFromUrl(url);\n                var pendingPush = navigateType === \"push\";\n                var isForCurrentTree = JSON.stringify(mutable.previousTree) === JSON.stringify(state.tree);\n                if (mutable.mpaNavigation && isForCurrentTree) {\n                    return {\n                        // Set href.\n                        canonicalUrl: mutable.canonicalUrlOverride ? mutable.canonicalUrlOverride : href,\n                        // TODO-APP: verify mpaNavigation not being set is correct here.\n                        pushRef: {\n                            pendingPush: pendingPush,\n                            mpaNavigation: mutable.mpaNavigation\n                        },\n                        // All navigation requires scroll and focus management to trigger.\n                        focusAndScrollRef: {\n                            apply: false\n                        },\n                        // Apply cache.\n                        cache: state.cache,\n                        prefetchCache: state.prefetchCache,\n                        // Apply patched router state.\n                        tree: state.tree\n                    };\n                }\n                // Handle concurrent rendering / strict mode case where the cache and tree were already populated.\n                if (mutable.patchedTree && isForCurrentTree) {\n                    return {\n                        // Set href.\n                        canonicalUrl: mutable.canonicalUrlOverride ? mutable.canonicalUrlOverride : href,\n                        // TODO-APP: verify mpaNavigation not being set is correct here.\n                        pushRef: {\n                            pendingPush: pendingPush,\n                            mpaNavigation: false\n                        },\n                        // All navigation requires scroll and focus management to trigger.\n                        focusAndScrollRef: {\n                            apply: true\n                        },\n                        // Apply cache.\n                        cache: mutable.useExistingCache ? state.cache : cache,\n                        prefetchCache: state.prefetchCache,\n                        // Apply patched router state.\n                        tree: mutable.patchedTree\n                    };\n                }\n                var prefetchValues = state.prefetchCache.get(href);\n                if (prefetchValues) {\n                    // The one before last item is the router state tree patch\n                    var flightSegmentPath = prefetchValues.flightSegmentPath, newTree = prefetchValues.tree, canonicalUrlOverride = prefetchValues.canonicalUrlOverride;\n                    if (newTree !== null) {\n                        mutable.previousTree = state.tree;\n                        mutable.patchedTree = newTree;\n                        mutable.mpaNavigation = isNavigatingToNewRootLayout(state.tree, newTree);\n                        var hardNavigate = search !== location.search || shouldHardNavigate([\n                            \"\"\n                        ].concat(_toConsumableArray(flightSegmentPath)), state.tree, newTree);\n                        if (hardNavigate) {\n                            // TODO-APP: segments.slice(1) strips '', we can get rid of '' altogether.\n                            // Copy subTreeData for the root node of the cache.\n                            cache.subTreeData = state.cache.subTreeData;\n                            invalidateCacheBelowFlightSegmentPath(cache, state.cache, flightSegmentPath);\n                        } else {\n                            mutable.useExistingCache = true;\n                        }\n                        var canonicalUrlOverrideHref = canonicalUrlOverride ? createHrefFromUrl(canonicalUrlOverride) : undefined;\n                        if (canonicalUrlOverrideHref) {\n                            mutable.canonicalUrlOverride = canonicalUrlOverrideHref;\n                        }\n                        return {\n                            // Set href.\n                            canonicalUrl: canonicalUrlOverrideHref ? canonicalUrlOverrideHref : href,\n                            // Set pendingPush.\n                            pushRef: {\n                                pendingPush: pendingPush,\n                                mpaNavigation: false\n                            },\n                            // All navigation requires scroll and focus management to trigger.\n                            focusAndScrollRef: {\n                                apply: true\n                            },\n                            // Apply patched cache.\n                            cache: mutable.useExistingCache ? state.cache : cache,\n                            prefetchCache: state.prefetchCache,\n                            // Apply patched tree.\n                            tree: newTree\n                        };\n                    }\n                }\n                // When doing a hard push there can be two cases: with optimistic tree and without\n                // The with optimistic tree case only happens when the layouts have a loading state (loading.js)\n                // The without optimistic tree case happens when there is no loading state, in that case we suspend in this reducer\n                // forceOptimisticNavigation is used for links that have `prefetch={false}`.\n                if (forceOptimisticNavigation) {\n                    var segments = pathname.split(\"/\");\n                    // TODO-APP: figure out something better for index pages\n                    segments.push(\"\");\n                    // Optimistic tree case.\n                    // If the optimistic tree is deeper than the current state leave that deeper part out of the fetch\n                    var optimisticTree = createOptimisticTree(segments, state.tree, true, false, href);\n                    // Copy subTreeData for the root node of the cache.\n                    cache.subTreeData = state.cache.subTreeData;\n                    // Copy existing cache nodes as far as possible and fill in `data` property with the started data fetch.\n                    // The `data` property is used to suspend in layout-router during render if it hasn't resolved yet by the time it renders.\n                    var res = fillCacheWithDataProperty(cache, state.cache, segments.slice(1), function() {\n                        return (0, _appRouter).fetchServerResponse(url, optimisticTree);\n                    });\n                    // If optimistic fetch couldn't happen it falls back to the non-optimistic case.\n                    if (!(res == null ? void 0 : res.bailOptimistic)) {\n                        mutable.previousTree = state.tree;\n                        mutable.patchedTree = optimisticTree;\n                        mutable.mpaNavigation = isNavigatingToNewRootLayout(state.tree, optimisticTree);\n                        return {\n                            // Set href.\n                            canonicalUrl: href,\n                            // Set pendingPush.\n                            pushRef: {\n                                pendingPush: pendingPush,\n                                mpaNavigation: false\n                            },\n                            // All navigation requires scroll and focus management to trigger.\n                            focusAndScrollRef: {\n                                apply: true\n                            },\n                            // Apply patched cache.\n                            cache: cache,\n                            prefetchCache: state.prefetchCache,\n                            // Apply optimistic tree.\n                            tree: optimisticTree\n                        };\n                    }\n                }\n                // Below is the not-optimistic case. Data is fetched at the root and suspended there without a suspense boundary.\n                // If no in-flight fetch at the top, start it.\n                if (!cache.data) {\n                    cache.data = createRecordFromThenable((0, _appRouter).fetchServerResponse(url, state.tree));\n                }\n                // Unwrap cache data with `use` to suspend here (in the reducer) until the fetch resolves.\n                var ref = _slicedToArray(readRecordValue(cache.data), 2), flightData = ref[0], canonicalUrlOverride1 = ref[1];\n                // Handle case when navigating to page in `pages` from `app`\n                if (typeof flightData === \"string\") {\n                    return {\n                        canonicalUrl: flightData,\n                        // Enable mpaNavigation\n                        pushRef: {\n                            pendingPush: true,\n                            mpaNavigation: true\n                        },\n                        // Don't apply scroll and focus management.\n                        focusAndScrollRef: {\n                            apply: false\n                        },\n                        cache: state.cache,\n                        prefetchCache: state.prefetchCache,\n                        tree: state.tree\n                    };\n                }\n                // Remove cache.data as it has been resolved at this point.\n                cache.data = null;\n                // TODO-APP: Currently the Flight data can only have one item but in the future it can have multiple paths.\n                var flightDataPath = flightData[0];\n                // The one before last item is the router state tree patch\n                var ref1 = _slicedToArray(flightDataPath.slice(-2), 2), treePatch = ref1[0], subTreeData = ref1[1];\n                // Path without the last segment, router state, and the subTreeData\n                var flightSegmentPath1 = flightDataPath.slice(0, -3);\n                // Create new tree based on the flightSegmentPath and router state patch\n                var newTree1 = applyRouterStatePatchToTree([\n                    \"\"\n                ].concat(_toConsumableArray(flightSegmentPath1)), state.tree, treePatch);\n                if (newTree1 === null) {\n                    throw new Error(\"SEGMENT MISMATCH\");\n                }\n                var canonicalUrlOverrideHref1 = canonicalUrlOverride1 ? createHrefFromUrl(canonicalUrlOverride1) : undefined;\n                if (canonicalUrlOverrideHref1) {\n                    mutable.canonicalUrlOverride = canonicalUrlOverrideHref1;\n                }\n                mutable.previousTree = state.tree;\n                mutable.patchedTree = newTree1;\n                mutable.mpaNavigation = isNavigatingToNewRootLayout(state.tree, newTree1);\n                if (flightDataPath.length === 2) {\n                    cache.subTreeData = subTreeData;\n                } else {\n                    // Copy subTreeData for the root node of the cache.\n                    cache.subTreeData = state.cache.subTreeData;\n                    // Create a copy of the existing cache with the subTreeData applied.\n                    fillCacheWithNewSubTreeData(cache, state.cache, flightDataPath);\n                }\n                return {\n                    // Set href.\n                    canonicalUrl: canonicalUrlOverrideHref1 ? canonicalUrlOverrideHref1 : href,\n                    // Set pendingPush.\n                    pushRef: {\n                        pendingPush: pendingPush,\n                        mpaNavigation: false\n                    },\n                    // All navigation requires scroll and focus management to trigger.\n                    focusAndScrollRef: {\n                        apply: true\n                    },\n                    // Apply patched cache.\n                    cache: cache,\n                    prefetchCache: state.prefetchCache,\n                    // Apply patched tree.\n                    tree: newTree1\n                };\n            }\n        case ACTION_SERVER_PATCH:\n            {\n                var flightData1 = action.flightData, previousTree = action.previousTree, overrideCanonicalUrl = action.overrideCanonicalUrl, cache1 = action.cache, mutable1 = action.mutable;\n                // When a fetch is slow to resolve it could be that you navigated away while the request was happening or before the reducer runs.\n                // In that case opt-out of applying the patch given that the data could be stale.\n                if (JSON.stringify(previousTree) !== JSON.stringify(state.tree)) {\n                    // TODO-APP: Handle tree mismatch\n                    console.log(\"TREE MISMATCH\");\n                    // Keep everything as-is.\n                    return state;\n                }\n                if (mutable1.mpaNavigation) {\n                    return {\n                        // Set href.\n                        canonicalUrl: mutable1.canonicalUrlOverride ? mutable1.canonicalUrlOverride : state.canonicalUrl,\n                        // TODO-APP: verify mpaNavigation not being set is correct here.\n                        pushRef: {\n                            pendingPush: true,\n                            mpaNavigation: mutable1.mpaNavigation\n                        },\n                        // All navigation requires scroll and focus management to trigger.\n                        focusAndScrollRef: {\n                            apply: false\n                        },\n                        // Apply cache.\n                        cache: state.cache,\n                        prefetchCache: state.prefetchCache,\n                        // Apply patched router state.\n                        tree: state.tree\n                    };\n                }\n                // Handle concurrent rendering / strict mode case where the cache and tree were already populated.\n                if (mutable1.patchedTree) {\n                    return {\n                        // Keep href as it was set during navigate / restore\n                        canonicalUrl: mutable1.canonicalUrlOverride ? mutable1.canonicalUrlOverride : state.canonicalUrl,\n                        // Keep pushRef as server-patch only causes cache/tree update.\n                        pushRef: state.pushRef,\n                        // Keep focusAndScrollRef as server-patch only causes cache/tree update.\n                        focusAndScrollRef: state.focusAndScrollRef,\n                        // Apply patched router state\n                        tree: mutable1.patchedTree,\n                        prefetchCache: state.prefetchCache,\n                        // Apply patched cache\n                        cache: cache1\n                    };\n                }\n                // Handle case when navigating to page in `pages` from `app`\n                if (typeof flightData1 === \"string\") {\n                    return {\n                        // Set href.\n                        canonicalUrl: flightData1,\n                        // Enable mpaNavigation as this is a navigation that the app-router shouldn't handle.\n                        pushRef: {\n                            pendingPush: true,\n                            mpaNavigation: true\n                        },\n                        // Don't apply scroll and focus management.\n                        focusAndScrollRef: {\n                            apply: false\n                        },\n                        // Other state is kept as-is.\n                        cache: state.cache,\n                        prefetchCache: state.prefetchCache,\n                        tree: state.tree\n                    };\n                }\n                // TODO-APP: Currently the Flight data can only have one item but in the future it can have multiple paths.\n                var flightDataPath1 = flightData1[0];\n                // Slices off the last segment (which is at -3) as it doesn't exist in the tree yet\n                var treePath = flightDataPath1.slice(0, -3);\n                var ref2 = _slicedToArray(flightDataPath1.slice(-2), 2), treePatch1 = ref2[0], subTreeData1 = ref2[1];\n                var newTree2 = applyRouterStatePatchToTree([\n                    \"\"\n                ].concat(_toConsumableArray(treePath)), state.tree, treePatch1);\n                if (newTree2 === null) {\n                    throw new Error(\"SEGMENT MISMATCH\");\n                }\n                var canonicalUrlOverrideHref2 = overrideCanonicalUrl ? createHrefFromUrl(overrideCanonicalUrl) : undefined;\n                if (canonicalUrlOverrideHref2) {\n                    mutable1.canonicalUrlOverride = canonicalUrlOverrideHref2;\n                }\n                mutable1.patchedTree = newTree2;\n                mutable1.mpaNavigation = isNavigatingToNewRootLayout(state.tree, newTree2);\n                // Root refresh\n                if (flightDataPath1.length === 2) {\n                    cache1.subTreeData = subTreeData1;\n                } else {\n                    // Copy subTreeData for the root node of the cache.\n                    cache1.subTreeData = state.cache.subTreeData;\n                    fillCacheWithNewSubTreeData(cache1, state.cache, flightDataPath1);\n                }\n                return {\n                    // Keep href as it was set during navigate / restore\n                    canonicalUrl: canonicalUrlOverrideHref2 ? canonicalUrlOverrideHref2 : state.canonicalUrl,\n                    // Keep pushRef as server-patch only causes cache/tree update.\n                    pushRef: state.pushRef,\n                    // Keep focusAndScrollRef as server-patch only causes cache/tree update.\n                    focusAndScrollRef: state.focusAndScrollRef,\n                    // Apply patched router state\n                    tree: newTree2,\n                    prefetchCache: state.prefetchCache,\n                    // Apply patched cache\n                    cache: cache1\n                };\n            }\n        case ACTION_RESTORE:\n            {\n                var url1 = action.url, tree = action.tree;\n                var href1 = createHrefFromUrl(url1);\n                return {\n                    // Set canonical url\n                    canonicalUrl: href1,\n                    pushRef: state.pushRef,\n                    focusAndScrollRef: state.focusAndScrollRef,\n                    cache: state.cache,\n                    prefetchCache: state.prefetchCache,\n                    // Restore provided tree\n                    tree: tree\n                };\n            }\n        case ACTION_REFRESH:\n            {\n                var cache2 = action.cache, mutable2 = action.mutable;\n                var href2 = state.canonicalUrl;\n                var isForCurrentTree1 = JSON.stringify(mutable2.previousTree) === JSON.stringify(state.tree);\n                if (mutable2.mpaNavigation && isForCurrentTree1) {\n                    return {\n                        // Set href.\n                        canonicalUrl: mutable2.canonicalUrlOverride ? mutable2.canonicalUrlOverride : state.canonicalUrl,\n                        // TODO-APP: verify mpaNavigation not being set is correct here.\n                        pushRef: {\n                            pendingPush: true,\n                            mpaNavigation: mutable2.mpaNavigation\n                        },\n                        // All navigation requires scroll and focus management to trigger.\n                        focusAndScrollRef: {\n                            apply: false\n                        },\n                        // Apply cache.\n                        cache: state.cache,\n                        prefetchCache: state.prefetchCache,\n                        // Apply patched router state.\n                        tree: state.tree\n                    };\n                }\n                // Handle concurrent rendering / strict mode case where the cache and tree were already populated.\n                if (mutable2.patchedTree && isForCurrentTree1) {\n                    return {\n                        // Set href.\n                        canonicalUrl: mutable2.canonicalUrlOverride ? mutable2.canonicalUrlOverride : href2,\n                        // set pendingPush (always false in this case).\n                        pushRef: state.pushRef,\n                        // Apply focus and scroll.\n                        // TODO-APP: might need to disable this for Fast Refresh.\n                        focusAndScrollRef: {\n                            apply: true\n                        },\n                        cache: cache2,\n                        prefetchCache: state.prefetchCache,\n                        tree: mutable2.patchedTree\n                    };\n                }\n                if (!cache2.data) {\n                    // Fetch data from the root of the tree.\n                    cache2.data = createRecordFromThenable((0, _appRouter).fetchServerResponse(new URL(href2, location.origin), [\n                        state.tree[0],\n                        state.tree[1],\n                        state.tree[2],\n                        \"refetch\"\n                    ]));\n                }\n                var ref3 = _slicedToArray(readRecordValue(cache2.data), 2), flightData2 = ref3[0], canonicalUrlOverride2 = ref3[1];\n                // Handle case when navigating to page in `pages` from `app`\n                if (typeof flightData2 === \"string\") {\n                    return {\n                        canonicalUrl: flightData2,\n                        pushRef: {\n                            pendingPush: true,\n                            mpaNavigation: true\n                        },\n                        focusAndScrollRef: {\n                            apply: false\n                        },\n                        cache: state.cache,\n                        prefetchCache: state.prefetchCache,\n                        tree: state.tree\n                    };\n                }\n                // Remove cache.data as it has been resolved at this point.\n                cache2.data = null;\n                // TODO-APP: Currently the Flight data can only have one item but in the future it can have multiple paths.\n                var flightDataPath2 = flightData2[0];\n                // FlightDataPath with more than two items means unexpected Flight data was returned\n                if (flightDataPath2.length !== 2) {\n                    // TODO-APP: handle this case better\n                    console.log(\"REFRESH FAILED\");\n                    return state;\n                }\n                // Given the path can only have two items the items are only the router state and subTreeData for the root.\n                var _flightDataPath = _slicedToArray(flightDataPath2, 2), treePatch2 = _flightDataPath[0], subTreeData2 = _flightDataPath[1];\n                var newTree3 = applyRouterStatePatchToTree([\n                    \"\"\n                ], state.tree, treePatch2);\n                if (newTree3 === null) {\n                    throw new Error(\"SEGMENT MISMATCH\");\n                }\n                var canonicalUrlOverrideHref3 = canonicalUrlOverride2 ? createHrefFromUrl(canonicalUrlOverride2) : undefined;\n                if (canonicalUrlOverride2) {\n                    mutable2.canonicalUrlOverride = canonicalUrlOverrideHref3;\n                }\n                mutable2.previousTree = state.tree;\n                mutable2.patchedTree = newTree3;\n                mutable2.mpaNavigation = isNavigatingToNewRootLayout(state.tree, newTree3);\n                // Set subTreeData for the root node of the cache.\n                cache2.subTreeData = subTreeData2;\n                return {\n                    // Set href, this doesn't reuse the state.canonicalUrl as because of concurrent rendering the href might change between dispatching and applying.\n                    canonicalUrl: canonicalUrlOverrideHref3 ? canonicalUrlOverrideHref3 : href2,\n                    // set pendingPush (always false in this case).\n                    pushRef: state.pushRef,\n                    // TODO-APP: might need to disable this for Fast Refresh.\n                    focusAndScrollRef: {\n                        apply: false\n                    },\n                    // Apply patched cache.\n                    cache: cache2,\n                    prefetchCache: state.prefetchCache,\n                    // Apply patched router state.\n                    tree: newTree3\n                };\n            }\n        case ACTION_PREFETCH:\n            {\n                var url2 = action.url, serverResponse = action.serverResponse;\n                var _serverResponse = _slicedToArray(serverResponse, 2), flightData3 = _serverResponse[0], canonicalUrlOverride3 = _serverResponse[1];\n                // TODO-APP: Implement prefetch for hard navigation\n                if (typeof flightData3 === \"string\") {\n                    return state;\n                }\n                var href3 = createHrefFromUrl(url2);\n                // TODO-APP: Currently the Flight data can only have one item but in the future it can have multiple paths.\n                var flightDataPath3 = flightData3[0];\n                // The one before last item is the router state tree patch\n                var ref4 = _slicedToArray(flightDataPath3.slice(-2), 2), treePatch3 = ref4[0], subTreeData3 = ref4[1];\n                // TODO-APP: Verify if `null` can't be returned from user code.\n                // If subTreeData is null the prefetch did not provide a component tree.\n                if (subTreeData3 !== null) {\n                    fillCacheWithPrefetchedSubTreeData(state.cache, flightDataPath3);\n                }\n                var flightSegmentPath2 = flightDataPath3.slice(0, -2);\n                var newTree4 = applyRouterStatePatchToTree([\n                    \"\"\n                ].concat(_toConsumableArray(flightSegmentPath2)), state.tree, treePatch3);\n                // Patch did not apply correctly\n                if (newTree4 === null) {\n                    return state;\n                }\n                // Create new tree based on the flightSegmentPath and router state patch\n                state.prefetchCache.set(href3, {\n                    // Path without the last segment, router state, and the subTreeData\n                    flightSegmentPath: flightSegmentPath2,\n                    // Create new tree based on the flightSegmentPath and router state patch\n                    tree: newTree4,\n                    canonicalUrlOverride: canonicalUrlOverride3\n                });\n                return state;\n            }\n        // This case should never be hit as dispatch is strongly typed.\n        default:\n            throw new Error(\"Unknown action\");\n    }\n}\nfunction serverReducer(state, _action) {\n    return state;\n}\nvar reducer =  false ? 0 : clientReducer;\nexports.reducer = reducer;\nif ((typeof exports[\"default\"] === \"function\" || typeof exports[\"default\"] === \"object\" && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === \"undefined\") {\n    Object.defineProperty(exports[\"default\"], \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports[\"default\"], exports);\n    module.exports = exports[\"default\"];\n} //# sourceMappingURL=reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi8ueWFybi9fX3ZpcnR1YWxfXy9uZXh0LXZpcnR1YWwtMzkzZDkxYmJjZC8wL2NhY2hlL25leHQtbnBtLTEzLjAuMi1iMzlhYmQyMmQwLWY2ZmVhMmVlMzQuemlwL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVkdWNlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELGVBQWUsR0FBR0EsdUJBQXVCLEdBQUdBLDJCQUEyQixHQUFHQSxzQkFBc0IsR0FBR0EsdUJBQXVCLEdBQUdBLHNCQUFzQixHQUFHLEtBQUs7QUFDM0osSUFBSVEsV0FBV0MsaUxBQStDO0FBQzlELElBQUlFLGlCQUFpQkYsbUJBQU9BLENBQUMsa0xBQWtCO0FBQy9DLElBQUlHLGFBQWFILG1CQUFPQSxDQUFDLDBLQUFjO0FBQ3ZDOztDQUVDLEdBQUcsNENBQTRDO0FBQ2hELFNBQVNJLHlCQUF5QkMsUUFBUSxFQUFFO0lBQ3hDQSxTQUFTQyxNQUFNLEdBQUc7SUFDbEJELFNBQVNFLElBQUksQ0FBQyxTQUFDZixPQUFRO1FBQ25CLElBQUlhLFNBQVNDLE1BQU0sS0FBSyxXQUFXO1lBQy9CRCxTQUFTQyxNQUFNLEdBQUc7WUFDbEJELFNBQVNiLEtBQUssR0FBR0E7UUFDckIsQ0FBQztJQUNMLEdBQUcsU0FBQ2dCLEtBQU07UUFDTixJQUFJSCxTQUFTQyxNQUFNLEtBQUssV0FBVztZQUMvQkQsU0FBU0MsTUFBTSxHQUFHO1lBQ2xCRCxTQUFTYixLQUFLLEdBQUdnQjtRQUNyQixDQUFDO0lBQ0w7SUFDQSxPQUFPSDtBQUNYO0FBQ0E7O0NBRUMsR0FBRyxTQUFTSSxnQkFBZ0JKLFFBQVEsRUFBRTtJQUNuQyxJQUFJQSxTQUFTQyxNQUFNLEtBQUssYUFBYTtR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QUNuRUgsT0FBTzRJLE1BQU0sQ0FBQzFJLE9BQVFVLENBQUFBLFVBQU8sRUFBRVY7SUFDL0IySSxPQUFPM0ksT0FBTyxHQUFHQSxPQUFRVSxDQUFBQSxVQUFPO0FBQ2xDLENBQUMsQ0FFRCxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vX192aXJ0dWFsX18vbmV4dC12aXJ0dWFsLTM5M2Q5MWJiY2QvMC9jYWNoZS9uZXh0LW5wbS0xMy4wLjItYjM5YWJkMjJkMC1mNmZlYTJlZTM0LnppcC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlZHVjZXIuanM/ODdkNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucmVkdWNlciA9IGV4cG9ydHMuQUNUSU9OX1BSRUZFVENIID0gZXhwb3J0cy5BQ1RJT05fU0VSVkVSX1BBVENIID0gZXhwb3J0cy5BQ1RJT05fUkVTVE9SRSA9IGV4cG9ydHMuQUNUSU9OX05BVklHQVRFID0gZXhwb3J0cy5BQ1RJT05fUkVGUkVTSCA9IHZvaWQgMDtcbnZhciBfZXh0ZW5kcyA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19leHRlbmRzLmpzXCIpLmRlZmF1bHQ7XG52YXIgX21hdGNoU2VnbWVudHMgPSByZXF1aXJlKFwiLi9tYXRjaC1zZWdtZW50c1wiKTtcbnZhciBfYXBwUm91dGVyID0gcmVxdWlyZShcIi4vYXBwLXJvdXRlclwiKTtcbi8qKlxuICogQ3JlYXRlIGRhdGEgZmV0Y2hpbmcgcmVjb3JkIGZvciBQcm9taXNlLlxuICovIC8vIFRPRE8tQVBQOiBjaGFuZ2UgYGFueWAgdG8gdHlwZSBpbmZlcmVuY2UuXG5mdW5jdGlvbiBjcmVhdGVSZWNvcmRGcm9tVGhlbmFibGUodGhlbmFibGUpIHtcbiAgICB0aGVuYWJsZS5zdGF0dXMgPSAncGVuZGluZyc7XG4gICAgdGhlbmFibGUudGhlbigodmFsdWUpPT57XG4gICAgICAgIGlmICh0aGVuYWJsZS5zdGF0dXMgPT09ICdwZW5kaW5nJykge1xuICAgICAgICAgICAgdGhlbmFibGUuc3RhdHVzID0gJ2Z1bGZpbGxlZCc7XG4gICAgICAgICAgICB0aGVuYWJsZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSwgKGVycik9PntcbiAgICAgICAgaWYgKHRoZW5hYmxlLnN0YXR1cyA9PT0gJ3BlbmRpbmcnKSB7XG4gICAgICAgICAgICB0aGVuYWJsZS5zdGF0dXMgPSAncmVqZWN0ZWQnO1xuICAgICAgICAgICAgdGhlbmFibGUudmFsdWUgPSBlcnI7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGhlbmFibGU7XG59XG4vKipcbiAqIFJlYWQgcmVjb3JkIHZhbHVlIG9yIHRocm93IFByb21pc2UgaWYgaXQncyBub3QgcmVzb2x2ZWQgeWV0LlxuICovIGZ1bmN0aW9uIHJlYWRSZWNvcmRWYWx1ZSh0aGVuYWJsZSkge1xuICAgIGlmICh0aGVuYWJsZS5zdGF0dXMgPT09ICdmdWxmaWxsZWQnKSB7XG4gICAgICAgIHJldHVybiB0aGVuYWJsZS52YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyB0aGVuYWJsZTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVIcmVmRnJvbVVybCh1cmwpIHtcbiAgICByZXR1cm4gdXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaCArIHVybC5oYXNoO1xufVxuLyoqXG4gKiBJbnZhbGlkYXRlIGNhY2hlIG9uZSBsZXZlbCBkb3duIGZyb20gdGhlIHJvdXRlciBzdGF0ZS5cbiAqLyAvLyBUT0RPLUFQUDogVmVyaWZ5IGlmIHRoaXMgbmVlZHMgdG8gYmUgcmVjdXJzaXZlLlxuZnVuY3Rpb24gaW52YWxpZGF0ZUNhY2hlQnlSb3V0ZXJTdGF0ZShuZXdDYWNoZSwgZXhpc3RpbmdDYWNoZSwgcm91dGVyU3RhdGUpIHtcbiAgICAvLyBSZW1vdmUgc2VnbWVudCB0aGF0IHdlIGdvdCBkYXRhIGZvciBzbyB0aGF0IGl0IGlzIGZpbGxlZCBpbiBkdXJpbmcgcmVuZGVyaW5nIG9mIHN1YlRyZWVEYXRhLlxuICAgIGZvcihjb25zdCBrZXkgaW4gcm91dGVyU3RhdGVbMV0pe1xuICAgICAgICBjb25zdCBzZWdtZW50Rm9yUGFyYWxsZWxSb3V0ZSA9IHJvdXRlclN0YXRlWzFdW2tleV1bMF07XG4gICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gQXJyYXkuaXNBcnJheShzZWdtZW50Rm9yUGFyYWxsZWxSb3V0ZSkgPyBzZWdtZW50Rm9yUGFyYWxsZWxSb3V0ZVsxXSA6IHNlZ21lbnRGb3JQYXJhbGxlbFJvdXRlO1xuICAgICAgICBjb25zdCBleGlzdGluZ1BhcmFsbGVsUm91dGVzQ2FjaGVOb2RlID0gZXhpc3RpbmdDYWNoZS5wYXJhbGxlbFJvdXRlcy5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGV4aXN0aW5nUGFyYWxsZWxSb3V0ZXNDYWNoZU5vZGUpIHtcbiAgICAgICAgICAgIGxldCBwYXJhbGxlbFJvdXRlQ2FjaGVOb2RlID0gbmV3IE1hcChleGlzdGluZ1BhcmFsbGVsUm91dGVzQ2FjaGVOb2RlKTtcbiAgICAgICAgICAgIHBhcmFsbGVsUm91dGVDYWNoZU5vZGUuZGVsZXRlKGNhY2hlS2V5KTtcbiAgICAgICAgICAgIG5ld0NhY2hlLnBhcmFsbGVsUm91dGVzLnNldChrZXksIHBhcmFsbGVsUm91dGVDYWNoZU5vZGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBGaWxsIGNhY2hlIHdpdGggc3ViVHJlZURhdGEgYmFzZWQgb24gZmxpZ2h0RGF0YVBhdGhcbiAqLyBmdW5jdGlvbiBmaWxsQ2FjaGVXaXRoTmV3U3ViVHJlZURhdGEobmV3Q2FjaGUsIGV4aXN0aW5nQ2FjaGUsIGZsaWdodERhdGFQYXRoKSB7XG4gICAgY29uc3QgaXNMYXN0RW50cnkgPSBmbGlnaHREYXRhUGF0aC5sZW5ndGggPD0gNDtcbiAgICBjb25zdCBbcGFyYWxsZWxSb3V0ZUtleSwgc2VnbWVudF0gPSBmbGlnaHREYXRhUGF0aDtcbiAgICBjb25zdCBzZWdtZW50Rm9yQ2FjaGUgPSBBcnJheS5pc0FycmF5KHNlZ21lbnQpID8gc2VnbWVudFsxXSA6IHNlZ21lbnQ7XG4gICAgY29uc3QgZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXAgPSBleGlzdGluZ0NhY2hlLnBhcmFsbGVsUm91dGVzLmdldChwYXJhbGxlbFJvdXRlS2V5KTtcbiAgICBpZiAoIWV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwKSB7XG4gICAgICAgIC8vIEJhaWxvdXQgYmVjYXVzZSB0aGUgZXhpc3RpbmcgY2FjaGUgZG9lcyBub3QgaGF2ZSB0aGUgcGF0aCB0byB0aGUgbGVhZiBub2RlXG4gICAgICAgIC8vIFdpbGwgdHJpZ2dlciBsYXp5IGZldGNoIGluIGxheW91dC1yb3V0ZXIgYmVjYXVzZSBvZiBtaXNzaW5nIHNlZ21lbnRcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgY2hpbGRTZWdtZW50TWFwID0gbmV3Q2FjaGUucGFyYWxsZWxSb3V0ZXMuZ2V0KHBhcmFsbGVsUm91dGVLZXkpO1xuICAgIGlmICghY2hpbGRTZWdtZW50TWFwIHx8IGNoaWxkU2VnbWVudE1hcCA9PT0gZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXApIHtcbiAgICAgICAgY2hpbGRTZWdtZW50TWFwID0gbmV3IE1hcChleGlzdGluZ0NoaWxkU2VnbWVudE1hcCk7XG4gICAgICAgIG5ld0NhY2hlLnBhcmFsbGVsUm91dGVzLnNldChwYXJhbGxlbFJvdXRlS2V5LCBjaGlsZFNlZ21lbnRNYXApO1xuICAgIH1cbiAgICBjb25zdCBleGlzdGluZ0NoaWxkQ2FjaGVOb2RlID0gZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXAuZ2V0KHNlZ21lbnRGb3JDYWNoZSk7XG4gICAgbGV0IGNoaWxkQ2FjaGVOb2RlID0gY2hpbGRTZWdtZW50TWFwLmdldChzZWdtZW50Rm9yQ2FjaGUpO1xuICAgIC8vIEluIGNhc2Ugb2YgbGFzdCBzZWdtZW50IHN0YXJ0IHRoZSBmZXRjaCBhdCB0aGlzIGxldmVsIGFuZCBkb24ndCBjb3B5IGZ1cnRoZXIgZG93bi5cbiAgICBpZiAoaXNMYXN0RW50cnkpIHtcbiAgICAgICAgaWYgKCFjaGlsZENhY2hlTm9kZSB8fCAhY2hpbGRDYWNoZU5vZGUuZGF0YSB8fCBjaGlsZENhY2hlTm9kZSA9PT0gZXhpc3RpbmdDaGlsZENhY2hlTm9kZSkge1xuICAgICAgICAgICAgY2hpbGRDYWNoZU5vZGUgPSB7XG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBzdWJUcmVlRGF0YTogZmxpZ2h0RGF0YVBhdGhbM10sXG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIHNlZ21lbnRzIG90aGVyIHRoYW4gdGhlIG9uZSB3ZSBnb3QgZGF0YSBmb3IgYXJlIHByZXNlcnZlZC5cbiAgICAgICAgICAgICAgICBwYXJhbGxlbFJvdXRlczogZXhpc3RpbmdDaGlsZENhY2hlTm9kZSA/IG5ldyBNYXAoZXhpc3RpbmdDaGlsZENhY2hlTm9kZS5wYXJhbGxlbFJvdXRlcykgOiBuZXcgTWFwKClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdDaGlsZENhY2hlTm9kZSkge1xuICAgICAgICAgICAgICAgIGludmFsaWRhdGVDYWNoZUJ5Um91dGVyU3RhdGUoY2hpbGRDYWNoZU5vZGUsIGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUsIGZsaWdodERhdGFQYXRoWzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkU2VnbWVudE1hcC5zZXQoc2VnbWVudEZvckNhY2hlLCBjaGlsZENhY2hlTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWNoaWxkQ2FjaGVOb2RlIHx8ICFleGlzdGluZ0NoaWxkQ2FjaGVOb2RlKSB7XG4gICAgICAgIC8vIEJhaWxvdXQgYmVjYXVzZSB0aGUgZXhpc3RpbmcgY2FjaGUgZG9lcyBub3QgaGF2ZSB0aGUgcGF0aCB0byB0aGUgbGVhZiBub2RlXG4gICAgICAgIC8vIFdpbGwgdHJpZ2dlciBsYXp5IGZldGNoIGluIGxheW91dC1yb3V0ZXIgYmVjYXVzZSBvZiBtaXNzaW5nIHNlZ21lbnRcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY2hpbGRDYWNoZU5vZGUgPT09IGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUpIHtcbiAgICAgICAgY2hpbGRDYWNoZU5vZGUgPSB7XG4gICAgICAgICAgICBkYXRhOiBjaGlsZENhY2hlTm9kZS5kYXRhLFxuICAgICAgICAgICAgc3ViVHJlZURhdGE6IGNoaWxkQ2FjaGVOb2RlLnN1YlRyZWVEYXRhLFxuICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoY2hpbGRDYWNoZU5vZGUucGFyYWxsZWxSb3V0ZXMpXG4gICAgICAgIH07XG4gICAgICAgIGNoaWxkU2VnbWVudE1hcC5zZXQoc2VnbWVudEZvckNhY2hlLCBjaGlsZENhY2hlTm9kZSk7XG4gICAgfVxuICAgIGZpbGxDYWNoZVdpdGhOZXdTdWJUcmVlRGF0YShjaGlsZENhY2hlTm9kZSwgZXhpc3RpbmdDaGlsZENhY2hlTm9kZSwgZmxpZ2h0RGF0YVBhdGguc2xpY2UoMikpO1xufVxuLyoqXG4gKiBGaWxsIGNhY2hlIHVwIHRvIHRoZSBlbmQgb2YgdGhlIGZsaWdodFNlZ21lbnRQYXRoLCBpbnZhbGlkYXRpbmcgYW55dGhpbmcgYmVsb3cgaXQuXG4gKi8gZnVuY3Rpb24gaW52YWxpZGF0ZUNhY2hlQmVsb3dGbGlnaHRTZWdtZW50UGF0aChuZXdDYWNoZSwgZXhpc3RpbmdDYWNoZSwgZmxpZ2h0U2VnbWVudFBhdGgpIHtcbiAgICBjb25zdCBpc0xhc3RFbnRyeSA9IGZsaWdodFNlZ21lbnRQYXRoLmxlbmd0aCA8PSAyO1xuICAgIGNvbnN0IFtwYXJhbGxlbFJvdXRlS2V5LCBzZWdtZW50XSA9IGZsaWdodFNlZ21lbnRQYXRoO1xuICAgIGNvbnN0IHNlZ21lbnRGb3JDYWNoZSA9IEFycmF5LmlzQXJyYXkoc2VnbWVudCkgPyBzZWdtZW50WzFdIDogc2VnbWVudDtcbiAgICBjb25zdCBleGlzdGluZ0NoaWxkU2VnbWVudE1hcCA9IGV4aXN0aW5nQ2FjaGUucGFyYWxsZWxSb3V0ZXMuZ2V0KHBhcmFsbGVsUm91dGVLZXkpO1xuICAgIGlmICghZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXApIHtcbiAgICAgICAgLy8gQmFpbG91dCBiZWNhdXNlIHRoZSBleGlzdGluZyBjYWNoZSBkb2VzIG5vdCBoYXZlIHRoZSBwYXRoIHRvIHRoZSBsZWFmIG5vZGVcbiAgICAgICAgLy8gV2lsbCB0cmlnZ2VyIGxhenkgZmV0Y2ggaW4gbGF5b3V0LXJvdXRlciBiZWNhdXNlIG9mIG1pc3Npbmcgc2VnbWVudFxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBjaGlsZFNlZ21lbnRNYXAgPSBuZXdDYWNoZS5wYXJhbGxlbFJvdXRlcy5nZXQocGFyYWxsZWxSb3V0ZUtleSk7XG4gICAgaWYgKCFjaGlsZFNlZ21lbnRNYXAgfHwgY2hpbGRTZWdtZW50TWFwID09PSBleGlzdGluZ0NoaWxkU2VnbWVudE1hcCkge1xuICAgICAgICBjaGlsZFNlZ21lbnRNYXAgPSBuZXcgTWFwKGV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwKTtcbiAgICAgICAgbmV3Q2FjaGUucGFyYWxsZWxSb3V0ZXMuc2V0KHBhcmFsbGVsUm91dGVLZXksIGNoaWxkU2VnbWVudE1hcCk7XG4gICAgfVxuICAgIC8vIEluIGNhc2Ugb2YgbGFzdCBlbnRyeSBkb24ndCBjb3B5IGZ1cnRoZXIgZG93bi5cbiAgICBpZiAoaXNMYXN0RW50cnkpIHtcbiAgICAgICAgY2hpbGRTZWdtZW50TWFwLmRlbGV0ZShzZWdtZW50Rm9yQ2FjaGUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUgPSBleGlzdGluZ0NoaWxkU2VnbWVudE1hcC5nZXQoc2VnbWVudEZvckNhY2hlKTtcbiAgICBsZXQgY2hpbGRDYWNoZU5vZGUgPSBjaGlsZFNlZ21lbnRNYXAuZ2V0KHNlZ21lbnRGb3JDYWNoZSk7XG4gICAgaWYgKCFjaGlsZENhY2hlTm9kZSB8fCAhZXhpc3RpbmdDaGlsZENhY2hlTm9kZSkge1xuICAgICAgICAvLyBCYWlsb3V0IGJlY2F1c2UgdGhlIGV4aXN0aW5nIGNhY2hlIGRvZXMgbm90IGhhdmUgdGhlIHBhdGggdG8gdGhlIGxlYWYgbm9kZVxuICAgICAgICAvLyBXaWxsIHRyaWdnZXIgbGF6eSBmZXRjaCBpbiBsYXlvdXQtcm91dGVyIGJlY2F1c2Ugb2YgbWlzc2luZyBzZWdtZW50XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNoaWxkQ2FjaGVOb2RlID09PSBleGlzdGluZ0NoaWxkQ2FjaGVOb2RlKSB7XG4gICAgICAgIGNoaWxkQ2FjaGVOb2RlID0ge1xuICAgICAgICAgICAgZGF0YTogY2hpbGRDYWNoZU5vZGUuZGF0YSxcbiAgICAgICAgICAgIHN1YlRyZWVEYXRhOiBjaGlsZENhY2hlTm9kZS5zdWJUcmVlRGF0YSxcbiAgICAgICAgICAgIHBhcmFsbGVsUm91dGVzOiBuZXcgTWFwKGNoaWxkQ2FjaGVOb2RlLnBhcmFsbGVsUm91dGVzKVxuICAgICAgICB9O1xuICAgICAgICBjaGlsZFNlZ21lbnRNYXAuc2V0KHNlZ21lbnRGb3JDYWNoZSwgY2hpbGRDYWNoZU5vZGUpO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlQ2FjaGVCZWxvd0ZsaWdodFNlZ21lbnRQYXRoKGNoaWxkQ2FjaGVOb2RlLCBleGlzdGluZ0NoaWxkQ2FjaGVOb2RlLCBmbGlnaHRTZWdtZW50UGF0aC5zbGljZSgyKSk7XG59XG4vKipcbiAqIEZpbGwgY2FjaGUgd2l0aCBzdWJUcmVlRGF0YSBiYXNlZCBvbiBmbGlnaHREYXRhUGF0aCB0aGF0IHdhcyBwcmVmZXRjaGVkXG4gKiBUaGlzIG9wZXJhdGlvbiBpcyBhcHBlbmQtb25seSB0byB0aGUgZXhpc3RpbmcgY2FjaGUuXG4gKi8gZnVuY3Rpb24gZmlsbENhY2hlV2l0aFByZWZldGNoZWRTdWJUcmVlRGF0YShleGlzdGluZ0NhY2hlLCBmbGlnaHREYXRhUGF0aCkge1xuICAgIGNvbnN0IGlzTGFzdEVudHJ5ID0gZmxpZ2h0RGF0YVBhdGgubGVuZ3RoIDw9IDQ7XG4gICAgY29uc3QgW3BhcmFsbGVsUm91dGVLZXksIHNlZ21lbnRdID0gZmxpZ2h0RGF0YVBhdGg7XG4gICAgY29uc3Qgc2VnbWVudEZvckNhY2hlID0gQXJyYXkuaXNBcnJheShzZWdtZW50KSA/IHNlZ21lbnRbMV0gOiBzZWdtZW50O1xuICAgIGNvbnN0IGV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwID0gZXhpc3RpbmdDYWNoZS5wYXJhbGxlbFJvdXRlcy5nZXQocGFyYWxsZWxSb3V0ZUtleSk7XG4gICAgaWYgKCFleGlzdGluZ0NoaWxkU2VnbWVudE1hcCkge1xuICAgICAgICAvLyBCYWlsb3V0IGJlY2F1c2UgdGhlIGV4aXN0aW5nIGNhY2hlIGRvZXMgbm90IGhhdmUgdGhlIHBhdGggdG8gdGhlIGxlYWYgbm9kZVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUgPSBleGlzdGluZ0NoaWxkU2VnbWVudE1hcC5nZXQoc2VnbWVudEZvckNhY2hlKTtcbiAgICBpZiAoaXNMYXN0RW50cnkpIHtcbiAgICAgICAgaWYgKCFleGlzdGluZ0NoaWxkQ2FjaGVOb2RlKSB7XG4gICAgICAgICAgICBleGlzdGluZ0NoaWxkU2VnbWVudE1hcC5zZXQoc2VnbWVudEZvckNhY2hlLCB7XG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBzdWJUcmVlRGF0YTogZmxpZ2h0RGF0YVBhdGhbM10sXG4gICAgICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUpIHtcbiAgICAgICAgLy8gQmFpbG91dCBiZWNhdXNlIHRoZSBleGlzdGluZyBjYWNoZSBkb2VzIG5vdCBoYXZlIHRoZSBwYXRoIHRvIHRoZSBsZWFmIG5vZGVcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmaWxsQ2FjaGVXaXRoUHJlZmV0Y2hlZFN1YlRyZWVEYXRhKGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUsIGZsaWdodERhdGFQYXRoLnNsaWNlKDIpKTtcbn1cbi8qKlxuICogS2ljayBvZmYgZmV0Y2ggYmFzZWQgb24gdGhlIGNvbW1vbiBsYXlvdXQgYmV0d2VlbiB0d28gcm91dGVzLiBGaWxsIGNhY2hlIHdpdGggZGF0YSBwcm9wZXJ0eSBob2xkaW5nIHRoZSBpbi1wcm9ncmVzcyBmZXRjaC5cbiAqLyBmdW5jdGlvbiBmaWxsQ2FjaGVXaXRoRGF0YVByb3BlcnR5KG5ld0NhY2hlLCBleGlzdGluZ0NhY2hlLCBzZWdtZW50cywgZmV0Y2hSZXNwb25zZSkge1xuICAgIGNvbnN0IGlzTGFzdEVudHJ5ID0gc2VnbWVudHMubGVuZ3RoID09PSAxO1xuICAgIGNvbnN0IHBhcmFsbGVsUm91dGVLZXkgPSAnY2hpbGRyZW4nO1xuICAgIGNvbnN0IFtzZWdtZW50XSA9IHNlZ21lbnRzO1xuICAgIGNvbnN0IGV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwID0gZXhpc3RpbmdDYWNoZS5wYXJhbGxlbFJvdXRlcy5nZXQocGFyYWxsZWxSb3V0ZUtleSk7XG4gICAgaWYgKCFleGlzdGluZ0NoaWxkU2VnbWVudE1hcCkge1xuICAgICAgICAvLyBCYWlsb3V0IGJlY2F1c2UgdGhlIGV4aXN0aW5nIGNhY2hlIGRvZXMgbm90IGhhdmUgdGhlIHBhdGggdG8gdGhlIGxlYWYgbm9kZVxuICAgICAgICAvLyBXaWxsIHRyaWdnZXIgbGF6eSBmZXRjaCBpbiBsYXlvdXQtcm91dGVyIGJlY2F1c2Ugb2YgbWlzc2luZyBzZWdtZW50XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBiYWlsT3B0aW1pc3RpYzogdHJ1ZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBsZXQgY2hpbGRTZWdtZW50TWFwID0gbmV3Q2FjaGUucGFyYWxsZWxSb3V0ZXMuZ2V0KHBhcmFsbGVsUm91dGVLZXkpO1xuICAgIGlmICghY2hpbGRTZWdtZW50TWFwIHx8IGNoaWxkU2VnbWVudE1hcCA9PT0gZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXApIHtcbiAgICAgICAgY2hpbGRTZWdtZW50TWFwID0gbmV3IE1hcChleGlzdGluZ0NoaWxkU2VnbWVudE1hcCk7XG4gICAgICAgIG5ld0NhY2hlLnBhcmFsbGVsUm91dGVzLnNldChwYXJhbGxlbFJvdXRlS2V5LCBjaGlsZFNlZ21lbnRNYXApO1xuICAgIH1cbiAgICBjb25zdCBleGlzdGluZ0NoaWxkQ2FjaGVOb2RlID0gZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXAuZ2V0KHNlZ21lbnQpO1xuICAgIGxldCBjaGlsZENhY2hlTm9kZSA9IGNoaWxkU2VnbWVudE1hcC5nZXQoc2VnbWVudCk7XG4gICAgLy8gSW4gY2FzZSBvZiBsYXN0IHNlZ21lbnQgc3RhcnQgb2ZmIHRoZSBmZXRjaCBhdCB0aGlzIGxldmVsIGFuZCBkb24ndCBjb3B5IGZ1cnRoZXIgZG93bi5cbiAgICBpZiAoaXNMYXN0RW50cnkpIHtcbiAgICAgICAgaWYgKCFjaGlsZENhY2hlTm9kZSB8fCAhY2hpbGRDYWNoZU5vZGUuZGF0YSB8fCBjaGlsZENhY2hlTm9kZSA9PT0gZXhpc3RpbmdDaGlsZENhY2hlTm9kZSkge1xuICAgICAgICAgICAgY2hpbGRTZWdtZW50TWFwLnNldChzZWdtZW50LCB7XG4gICAgICAgICAgICAgICAgZGF0YTogZmV0Y2hSZXNwb25zZSgpLFxuICAgICAgICAgICAgICAgIHN1YlRyZWVEYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIHBhcmFsbGVsUm91dGVzOiBuZXcgTWFwKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFjaGlsZENhY2hlTm9kZSB8fCAhZXhpc3RpbmdDaGlsZENhY2hlTm9kZSkge1xuICAgICAgICAvLyBTdGFydCBmZXRjaCBpbiB0aGUgcGxhY2Ugd2hlcmUgdGhlIGV4aXN0aW5nIGNhY2hlIGRvZXNuJ3QgaGF2ZSB0aGUgZGF0YSB5ZXQuXG4gICAgICAgIGlmICghY2hpbGRDYWNoZU5vZGUpIHtcbiAgICAgICAgICAgIGNoaWxkU2VnbWVudE1hcC5zZXQoc2VnbWVudCwge1xuICAgICAgICAgICAgICAgIGRhdGE6IGZldGNoUmVzcG9uc2UoKSxcbiAgICAgICAgICAgICAgICBzdWJUcmVlRGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBwYXJhbGxlbFJvdXRlczogbmV3IE1hcCgpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjaGlsZENhY2hlTm9kZSA9PT0gZXhpc3RpbmdDaGlsZENhY2hlTm9kZSkge1xuICAgICAgICBjaGlsZENhY2hlTm9kZSA9IHtcbiAgICAgICAgICAgIGRhdGE6IGNoaWxkQ2FjaGVOb2RlLmRhdGEsXG4gICAgICAgICAgICBzdWJUcmVlRGF0YTogY2hpbGRDYWNoZU5vZGUuc3ViVHJlZURhdGEsXG4gICAgICAgICAgICBwYXJhbGxlbFJvdXRlczogbmV3IE1hcChjaGlsZENhY2hlTm9kZS5wYXJhbGxlbFJvdXRlcylcbiAgICAgICAgfTtcbiAgICAgICAgY2hpbGRTZWdtZW50TWFwLnNldChzZWdtZW50LCBjaGlsZENhY2hlTm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBmaWxsQ2FjaGVXaXRoRGF0YVByb3BlcnR5KGNoaWxkQ2FjaGVOb2RlLCBleGlzdGluZ0NoaWxkQ2FjaGVOb2RlLCBzZWdtZW50cy5zbGljZSgxKSwgZmV0Y2hSZXNwb25zZSk7XG59XG4vKipcbiAqIENyZWF0ZSBvcHRpbWlzdGljIHZlcnNpb24gb2Ygcm91dGVyIHN0YXRlIGJhc2VkIG9uIHRoZSBleGlzdGluZyByb3V0ZXIgc3RhdGUgYW5kIHNlZ21lbnRzLlxuICogVGhpcyBpcyB1c2VkIHRvIGFsbG93IHJlbmRlcmluZyBsYXlvdXQtcm91dGVycyB1cCB0aWxsIHRoZSBwb2ludCB3aGVyZSBkYXRhIGlzIG1pc3NpbmcuXG4gKi8gZnVuY3Rpb24gY3JlYXRlT3B0aW1pc3RpY1RyZWUoc2VnbWVudHMsIGZsaWdodFJvdXRlclN0YXRlLCBfaXNGaXJzdFNlZ21lbnQsIHBhcmVudFJlZmV0Y2gsIF9ocmVmKSB7XG4gICAgY29uc3QgW2V4aXN0aW5nU2VnbWVudCwgZXhpc3RpbmdQYXJhbGxlbFJvdXRlc10gPSBmbGlnaHRSb3V0ZXJTdGF0ZSB8fCBbXG4gICAgICAgIG51bGwsXG4gICAgICAgIHt9LCBcbiAgICBdO1xuICAgIGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50c1swXTtcbiAgICBjb25zdCBpc0xhc3RTZWdtZW50ID0gc2VnbWVudHMubGVuZ3RoID09PSAxO1xuICAgIGNvbnN0IHNlZ21lbnRNYXRjaGVzID0gZXhpc3RpbmdTZWdtZW50ICE9PSBudWxsICYmICgwLCBfbWF0Y2hTZWdtZW50cykubWF0Y2hTZWdtZW50KGV4aXN0aW5nU2VnbWVudCwgc2VnbWVudCk7XG4gICAgY29uc3Qgc2hvdWxkUmVmZXRjaFRoaXNMZXZlbCA9ICFmbGlnaHRSb3V0ZXJTdGF0ZSB8fCAhc2VnbWVudE1hdGNoZXM7XG4gICAgbGV0IHBhcmFsbGVsUm91dGVzID0ge307XG4gICAgaWYgKGV4aXN0aW5nU2VnbWVudCAhPT0gbnVsbCAmJiBzZWdtZW50TWF0Y2hlcykge1xuICAgICAgICBwYXJhbGxlbFJvdXRlcyA9IGV4aXN0aW5nUGFyYWxsZWxSb3V0ZXM7XG4gICAgfVxuICAgIGxldCBjaGlsZFRyZWU7XG4gICAgaWYgKCFpc0xhc3RTZWdtZW50KSB7XG4gICAgICAgIGNvbnN0IGNoaWxkSXRlbSA9IGNyZWF0ZU9wdGltaXN0aWNUcmVlKHNlZ21lbnRzLnNsaWNlKDEpLCBwYXJhbGxlbFJvdXRlcyA/IHBhcmFsbGVsUm91dGVzLmNoaWxkcmVuIDogbnVsbCwgZmFsc2UsIHBhcmVudFJlZmV0Y2ggfHwgc2hvdWxkUmVmZXRjaFRoaXNMZXZlbCk7XG4gICAgICAgIGNoaWxkVHJlZSA9IGNoaWxkSXRlbTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gW1xuICAgICAgICBzZWdtZW50LFxuICAgICAgICBfZXh0ZW5kcyh7fSwgcGFyYWxsZWxSb3V0ZXMsIGNoaWxkVHJlZSA/IHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBjaGlsZFRyZWVcbiAgICAgICAgfSA6IHt9KSwgXG4gICAgXTtcbiAgICBpZiAoIXBhcmVudFJlZmV0Y2ggJiYgc2hvdWxkUmVmZXRjaFRoaXNMZXZlbCkge1xuICAgICAgICByZXN1bHRbM10gPSAncmVmZXRjaCc7XG4gICAgfVxuICAgIC8vIFRPRE8tQVBQOiBSZXZpc2l0XG4gICAgLy8gQWRkIHVybCBpbnRvIHRoZSB0cmVlXG4gICAgLy8gaWYgKGlzRmlyc3RTZWdtZW50KSB7XG4gICAgLy8gICByZXN1bHRbMl0gPSBocmVmXG4gICAgLy8gfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEFwcGx5IHRoZSByb3V0ZXIgc3RhdGUgZnJvbSB0aGUgRmxpZ2h0IHJlc3BvbnNlLiBDcmVhdGVzIGEgbmV3IHJvdXRlciBzdGF0ZSB0cmVlLlxuICovIGZ1bmN0aW9uIGFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZShmbGlnaHRTZWdtZW50UGF0aCwgZmxpZ2h0Um91dGVyU3RhdGUsIHRyZWVQYXRjaCkge1xuICAgIGNvbnN0IFtzZWdtZW50LCBwYXJhbGxlbFJvdXRlcywgLCAsIGlzUm9vdExheW91dF0gPSBmbGlnaHRSb3V0ZXJTdGF0ZTtcbiAgICAvLyBSb290IHJlZnJlc2hcbiAgICBpZiAoZmxpZ2h0U2VnbWVudFBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNvbnN0IHRyZWUgPSBbXG4gICAgICAgICAgICAuLi50cmVlUGF0Y2hcbiAgICAgICAgXTtcbiAgICAgICAgLy8gVE9ETy1BUFA6IHJldmlzaXRcbiAgICAgICAgLy8gaWYgKHVybCkge1xuICAgICAgICAvLyAgIHRyZWVbMl0gPSB1cmxcbiAgICAgICAgLy8gfVxuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICB9XG4gICAgY29uc3QgW2N1cnJlbnRTZWdtZW50LCBwYXJhbGxlbFJvdXRlS2V5XSA9IGZsaWdodFNlZ21lbnRQYXRoO1xuICAgIC8vIFRyZWUgcGF0aCByZXR1cm5lZCBmcm9tIHRoZSBzZXJ2ZXIgc2hvdWxkIGFsd2F5cyBtYXRjaCB1cCB3aXRoIHRoZSBjdXJyZW50IHRyZWUgaW4gdGhlIGJyb3dzZXJcbiAgICBpZiAoISgwLCBfbWF0Y2hTZWdtZW50cykubWF0Y2hTZWdtZW50KGN1cnJlbnRTZWdtZW50LCBzZWdtZW50KSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgbGFzdFNlZ21lbnQgPSBmbGlnaHRTZWdtZW50UGF0aC5sZW5ndGggPT09IDI7XG4gICAgbGV0IHBhcmFsbGVsUm91dGVQYXRjaDtcbiAgICBpZiAobGFzdFNlZ21lbnQpIHtcbiAgICAgICAgcGFyYWxsZWxSb3V0ZVBhdGNoID0gdHJlZVBhdGNoO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmFsbGVsUm91dGVQYXRjaCA9IGFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZShmbGlnaHRTZWdtZW50UGF0aC5zbGljZSgyKSwgcGFyYWxsZWxSb3V0ZXNbcGFyYWxsZWxSb3V0ZUtleV0sIHRyZWVQYXRjaCk7XG4gICAgICAgIGlmIChwYXJhbGxlbFJvdXRlUGF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRyZWUgPSBbXG4gICAgICAgIGZsaWdodFNlZ21lbnRQYXRoWzBdLFxuICAgICAgICBfZXh0ZW5kcyh7fSwgcGFyYWxsZWxSb3V0ZXMsIHtcbiAgICAgICAgICAgIFtwYXJhbGxlbFJvdXRlS2V5XTogcGFyYWxsZWxSb3V0ZVBhdGNoXG4gICAgICAgIH0pLCBcbiAgICBdO1xuICAgIC8vIEN1cnJlbnQgc2VnbWVudCBpcyB0aGUgcm9vdCBsYXlvdXRcbiAgICBpZiAoaXNSb290TGF5b3V0KSB7XG4gICAgICAgIHRyZWVbNF0gPSB0cnVlO1xuICAgIH1cbiAgICAvLyBUT0RPLUFQUDogUmV2aXNpdFxuICAgIC8vIGlmICh1cmwpIHtcbiAgICAvLyAgIHRyZWVbMl0gPSB1cmxcbiAgICAvLyB9XG4gICAgcmV0dXJuIHRyZWU7XG59XG5mdW5jdGlvbiBzaG91bGRIYXJkTmF2aWdhdGUoZmxpZ2h0U2VnbWVudFBhdGgsIGZsaWdodFJvdXRlclN0YXRlLCB0cmVlUGF0Y2gpIHtcbiAgICBjb25zdCBbc2VnbWVudCwgcGFyYWxsZWxSb3V0ZXNdID0gZmxpZ2h0Um91dGVyU3RhdGU7XG4gICAgLy8gVE9ETy1BUFA6IENoZWNrIGlmIGBhc2AgY2FuIGJlIHJlcGxhY2VkLlxuICAgIGNvbnN0IFtjdXJyZW50U2VnbWVudCwgcGFyYWxsZWxSb3V0ZUtleV0gPSBmbGlnaHRTZWdtZW50UGF0aDtcbiAgICAvLyBDaGVjayBpZiBjdXJyZW50IHNlZ21lbnQgbWF0Y2hlcyB0aGUgZXhpc3Rpbmcgc2VnbWVudC5cbiAgICBpZiAoISgwLCBfbWF0Y2hTZWdtZW50cykubWF0Y2hTZWdtZW50KGN1cnJlbnRTZWdtZW50LCBzZWdtZW50KSkge1xuICAgICAgICAvLyBJZiBkeW5hbWljIHBhcmFtZXRlciBpbiB0cmVlIGRvZXNuJ3QgbWF0Y2ggdXAgd2l0aCBzZWdtZW50IHBhdGggYSBoYXJkIG5hdmlnYXRpb24gaXMgdHJpZ2dlcmVkLlxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50U2VnbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBleGlzdGluZyBzZWdtZW50IGRpZCBub3QgbWF0Y2ggc29mdCBuYXZpZ2F0aW9uIGlzIHRyaWdnZXJlZC5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBsYXN0U2VnbWVudCA9IGZsaWdodFNlZ21lbnRQYXRoLmxlbmd0aCA8PSAyO1xuICAgIGlmIChsYXN0U2VnbWVudCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBzaG91bGRIYXJkTmF2aWdhdGUoZmxpZ2h0U2VnbWVudFBhdGguc2xpY2UoMiksIHBhcmFsbGVsUm91dGVzW3BhcmFsbGVsUm91dGVLZXldLCB0cmVlUGF0Y2gpO1xufVxuZnVuY3Rpb24gaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0KGN1cnJlbnRUcmVlLCBuZXh0VHJlZSkge1xuICAgIC8vIENvbXBhcmUgc2VnbWVudHNcbiAgICBjb25zdCBjdXJyZW50VHJlZVNlZ21lbnQgPSBjdXJyZW50VHJlZVswXTtcbiAgICBjb25zdCBuZXh0VHJlZVNlZ21lbnQgPSBuZXh0VHJlZVswXTtcbiAgICAvLyBJZiBhbnkgc2VnbWVudCBpcyBkaWZmZXJlbnQgYmVmb3JlIHdlIGZpbmQgdGhlIHJvb3QgbGF5b3V0LCB0aGUgcm9vdCBsYXlvdXQgaGFzIGNoYW5nZWQuXG4gICAgLy8gRS5nLiAvc2FtZS8oZ3JvdXAxKS9sYXlvdXQuanMgLT4gL3NhbWUvKGdyb3VwMikvbGF5b3V0LmpzXG4gICAgLy8gRmlyc3Qgc2VnbWVudCBpcyAnc2FtZScgZm9yIGJvdGgsIGtlZXAgbG9va2luZy4gKGdyb3VwMSkgY2hhbmdlZCB0byAoZ3JvdXAyKSBiZWZvcmUgdGhlIHJvb3QgbGF5b3V0IHdhcyBmb3VuZCwgaXQgbXVzdCBoYXZlIGNoYW5nZWQuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudFRyZWVTZWdtZW50KSAmJiBBcnJheS5pc0FycmF5KG5leHRUcmVlU2VnbWVudCkpIHtcbiAgICAgICAgLy8gQ29tcGFyZSBkeW5hbWljIHBhcmFtIG5hbWUgYW5kIHR5cGUgYnV0IGlnbm9yZSB0aGUgdmFsdWUsIGRpZmZlcmVudCB2YWx1ZXMgd291bGQgbm90IGFmZmVjdCB0aGUgY3VycmVudCByb290IGxheW91dFxuICAgICAgICAvLyAvW25hbWVdIC0gL3NsdWcxIGFuZCAvc2x1ZzIsIGJvdGggdmFsdWVzIChzbHVnMSAmIHNsdWcyKSBzdGlsbCBoYXMgdGhlIHNhbWUgbGF5b3V0IC9bbmFtZV0vbGF5b3V0LmpzXG4gICAgICAgIGlmIChjdXJyZW50VHJlZVNlZ21lbnRbMF0gIT09IG5leHRUcmVlU2VnbWVudFswXSB8fCBjdXJyZW50VHJlZVNlZ21lbnRbMl0gIT09IG5leHRUcmVlU2VnbWVudFsyXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRUcmVlU2VnbWVudCAhPT0gbmV4dFRyZWVTZWdtZW50KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBDdXJyZW50IHRyZWUgcm9vdCBsYXlvdXQgZm91bmRcbiAgICBpZiAoY3VycmVudFRyZWVbNF0pIHtcbiAgICAgICAgLy8gSWYgdGhlIG5leHQgdHJlZSBkb2Vzbid0IGhhdmUgdGhlIHJvb3QgbGF5b3V0IGZsYWcsIGl0IG11c3QgaGF2ZSBjaGFuZ2VkLlxuICAgICAgICByZXR1cm4gIW5leHRUcmVlWzRdO1xuICAgIH1cbiAgICAvLyBDdXJyZW50IHRyZWUgIGRpZG4ndCBoYXZlIGl0cyByb290IGxheW91dCBoZXJlLCBtdXN0IGhhdmUgY2hhbmdlZC5cbiAgICBpZiAobmV4dFRyZWVbNF0pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIFdlIGNhbid0IGFzc3VtZSBpdCdzIGBwYXJhbGxlbFJvdXRlcy5jaGlsZHJlbmAgaGVyZSBpbiBjYXNlIHRoZSByb290IGxheW91dCBpcyBgYXBwL0Bzb21ldGhpbmcvbGF5b3V0LmpzYFxuICAgIC8vIEJ1dCBpdCdzIG5vdCBwb3NzaWJsZSB0byBiZSBtb3JlIHRoYW4gb25lIHBhcmFsbGVsUm91dGVzIGJlZm9yZSB0aGUgcm9vdCBsYXlvdXQgaXMgZm91bmRcbiAgICAvLyBUT0RPLUFQUDogY2hhbmdlIHRvIHRyYXZlcnNlIGFsbCBwYXJhbGxlbCByb3V0ZXNcbiAgICBjb25zdCBjdXJyZW50VHJlZUNoaWxkID0gT2JqZWN0LnZhbHVlcyhjdXJyZW50VHJlZVsxXSlbMF07XG4gICAgY29uc3QgbmV4dFRyZWVDaGlsZCA9IE9iamVjdC52YWx1ZXMobmV4dFRyZWVbMV0pWzBdO1xuICAgIGlmICghY3VycmVudFRyZWVDaGlsZCB8fCAhbmV4dFRyZWVDaGlsZCkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dChjdXJyZW50VHJlZUNoaWxkLCBuZXh0VHJlZUNoaWxkKTtcbn1cbmNvbnN0IEFDVElPTl9SRUZSRVNIID0gJ3JlZnJlc2gnO1xuZXhwb3J0cy5BQ1RJT05fUkVGUkVTSCA9IEFDVElPTl9SRUZSRVNIO1xuY29uc3QgQUNUSU9OX05BVklHQVRFID0gJ25hdmlnYXRlJztcbmV4cG9ydHMuQUNUSU9OX05BVklHQVRFID0gQUNUSU9OX05BVklHQVRFO1xuY29uc3QgQUNUSU9OX1JFU1RPUkUgPSAncmVzdG9yZSc7XG5leHBvcnRzLkFDVElPTl9SRVNUT1JFID0gQUNUSU9OX1JFU1RPUkU7XG5jb25zdCBBQ1RJT05fU0VSVkVSX1BBVENIID0gJ3NlcnZlci1wYXRjaCc7XG5leHBvcnRzLkFDVElPTl9TRVJWRVJfUEFUQ0ggPSBBQ1RJT05fU0VSVkVSX1BBVENIO1xuY29uc3QgQUNUSU9OX1BSRUZFVENIID0gJ3ByZWZldGNoJztcbmV4cG9ydHMuQUNUSU9OX1BSRUZFVENIID0gQUNUSU9OX1BSRUZFVENIO1xuLyoqXG4gKiBSZWR1Y2VyIHRoYXQgaGFuZGxlcyB0aGUgYXBwLXJvdXRlciBzdGF0ZSB1cGRhdGVzLlxuICovIGZ1bmN0aW9uIGNsaWVudFJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICAgIHN3aXRjaChhY3Rpb24udHlwZSl7XG4gICAgICAgIGNhc2UgQUNUSU9OX05BVklHQVRFOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdXJsICwgbmF2aWdhdGVUeXBlICwgY2FjaGUgLCBtdXRhYmxlICwgZm9yY2VPcHRpbWlzdGljTmF2aWdhdGlvbiAgfSA9IGFjdGlvbjtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHBhdGhuYW1lICwgc2VhcmNoICB9ID0gdXJsO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhyZWYgPSBjcmVhdGVIcmVmRnJvbVVybCh1cmwpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBlbmRpbmdQdXNoID0gbmF2aWdhdGVUeXBlID09PSAncHVzaCc7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNGb3JDdXJyZW50VHJlZSA9IEpTT04uc3RyaW5naWZ5KG11dGFibGUucHJldmlvdXNUcmVlKSA9PT0gSlNPTi5zdHJpbmdpZnkoc3RhdGUudHJlZSk7XG4gICAgICAgICAgICAgICAgaWYgKG11dGFibGUubXBhTmF2aWdhdGlvbiAmJiBpc0ZvckN1cnJlbnRUcmVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgaHJlZi5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbm9uaWNhbFVybDogbXV0YWJsZS5jYW5vbmljYWxVcmxPdmVycmlkZSA/IG11dGFibGUuY2Fub25pY2FsVXJsT3ZlcnJpZGUgOiBocmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETy1BUFA6IHZlcmlmeSBtcGFOYXZpZ2F0aW9uIG5vdCBiZWluZyBzZXQgaXMgY29ycmVjdCBoZXJlLlxuICAgICAgICAgICAgICAgICAgICAgICAgcHVzaFJlZjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdQdXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1wYU5hdmlnYXRpb246IG11dGFibGUubXBhTmF2aWdhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbCBuYXZpZ2F0aW9uIHJlcXVpcmVzIHNjcm9sbCBhbmQgZm9jdXMgbWFuYWdlbWVudCB0byB0cmlnZ2VyLlxuICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWY6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBseTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBjYWNoZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlOiBzdGF0ZS5jYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZldGNoQ2FjaGU6IHN0YXRlLnByZWZldGNoQ2FjaGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBwYXRjaGVkIHJvdXRlciBzdGF0ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyZWU6IHN0YXRlLnRyZWVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIGNvbmN1cnJlbnQgcmVuZGVyaW5nIC8gc3RyaWN0IG1vZGUgY2FzZSB3aGVyZSB0aGUgY2FjaGUgYW5kIHRyZWUgd2VyZSBhbHJlYWR5IHBvcHVsYXRlZC5cbiAgICAgICAgICAgICAgICBpZiAobXV0YWJsZS5wYXRjaGVkVHJlZSAmJiBpc0ZvckN1cnJlbnRUcmVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgaHJlZi5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbm9uaWNhbFVybDogbXV0YWJsZS5jYW5vbmljYWxVcmxPdmVycmlkZSA/IG11dGFibGUuY2Fub25pY2FsVXJsT3ZlcnJpZGUgOiBocmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETy1BUFA6IHZlcmlmeSBtcGFOYXZpZ2F0aW9uIG5vdCBiZWluZyBzZXQgaXMgY29ycmVjdCBoZXJlLlxuICAgICAgICAgICAgICAgICAgICAgICAgcHVzaFJlZjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdQdXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1wYU5hdmlnYXRpb246IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsIG5hdmlnYXRpb24gcmVxdWlyZXMgc2Nyb2xsIGFuZCBmb2N1cyBtYW5hZ2VtZW50IHRvIHRyaWdnZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb2N1c0FuZFNjcm9sbFJlZjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGx5OiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgY2FjaGUuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZTogbXV0YWJsZS51c2VFeGlzdGluZ0NhY2hlID8gc3RhdGUuY2FjaGUgOiBjYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZldGNoQ2FjaGU6IHN0YXRlLnByZWZldGNoQ2FjaGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBwYXRjaGVkIHJvdXRlciBzdGF0ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyZWU6IG11dGFibGUucGF0Y2hlZFRyZWVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcHJlZmV0Y2hWYWx1ZXMgPSBzdGF0ZS5wcmVmZXRjaENhY2hlLmdldChocmVmKTtcbiAgICAgICAgICAgICAgICBpZiAocHJlZmV0Y2hWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG9uZSBiZWZvcmUgbGFzdCBpdGVtIGlzIHRoZSByb3V0ZXIgc3RhdGUgdHJlZSBwYXRjaFxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGZsaWdodFNlZ21lbnRQYXRoICwgdHJlZTogbmV3VHJlZSAsIGNhbm9uaWNhbFVybE92ZXJyaWRlICwgIH0gPSBwcmVmZXRjaFZhbHVlcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1RyZWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGFibGUucHJldmlvdXNUcmVlID0gc3RhdGUudHJlZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGFibGUucGF0Y2hlZFRyZWUgPSBuZXdUcmVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YWJsZS5tcGFOYXZpZ2F0aW9uID0gaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0KHN0YXRlLnRyZWUsIG5ld1RyZWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFyZE5hdmlnYXRlID0gLy8gVE9ETy1BUFA6IFJldmlzaXQgaWYgdGhpcyBpcyBjb3JyZWN0LlxuICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoICE9PSBsb2NhdGlvbi5zZWFyY2ggfHwgc2hvdWxkSGFyZE5hdmlnYXRlKC8vIFRPRE8tQVBQOiByZW1vdmUgJydcbiAgICAgICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5mbGlnaHRTZWdtZW50UGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgXSwgc3RhdGUudHJlZSwgbmV3VHJlZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFyZE5hdmlnYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETy1BUFA6IHNlZ21lbnRzLnNsaWNlKDEpIHN0cmlwcyAnJywgd2UgY2FuIGdldCByaWQgb2YgJycgYWx0b2dldGhlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3B5IHN1YlRyZWVEYXRhIGZvciB0aGUgcm9vdCBub2RlIG9mIHRoZSBjYWNoZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5zdWJUcmVlRGF0YSA9IHN0YXRlLmNhY2hlLnN1YlRyZWVEYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludmFsaWRhdGVDYWNoZUJlbG93RmxpZ2h0U2VnbWVudFBhdGgoY2FjaGUsIHN0YXRlLmNhY2hlLCBmbGlnaHRTZWdtZW50UGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dGFibGUudXNlRXhpc3RpbmdDYWNoZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYgPSBjYW5vbmljYWxVcmxPdmVycmlkZSA/IGNyZWF0ZUhyZWZGcm9tVXJsKGNhbm9uaWNhbFVybE92ZXJyaWRlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhYmxlLmNhbm9uaWNhbFVybE92ZXJyaWRlID0gY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgaHJlZi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5vbmljYWxVcmw6IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiA/IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiA6IGhyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHBlbmRpbmdQdXNoLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hSZWY6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1B1c2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1wYU5hdmlnYXRpb246IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGwgbmF2aWdhdGlvbiByZXF1aXJlcyBzY3JvbGwgYW5kIGZvY3VzIG1hbmFnZW1lbnQgdG8gdHJpZ2dlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb2N1c0FuZFNjcm9sbFJlZjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBseTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgcGF0Y2hlZCBjYWNoZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZTogbXV0YWJsZS51c2VFeGlzdGluZ0NhY2hlID8gc3RhdGUuY2FjaGUgOiBjYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVmZXRjaENhY2hlOiBzdGF0ZS5wcmVmZXRjaENhY2hlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IHBhdGNoZWQgdHJlZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmVlOiBuZXdUcmVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFdoZW4gZG9pbmcgYSBoYXJkIHB1c2ggdGhlcmUgY2FuIGJlIHR3byBjYXNlczogd2l0aCBvcHRpbWlzdGljIHRyZWUgYW5kIHdpdGhvdXRcbiAgICAgICAgICAgICAgICAvLyBUaGUgd2l0aCBvcHRpbWlzdGljIHRyZWUgY2FzZSBvbmx5IGhhcHBlbnMgd2hlbiB0aGUgbGF5b3V0cyBoYXZlIGEgbG9hZGluZyBzdGF0ZSAobG9hZGluZy5qcylcbiAgICAgICAgICAgICAgICAvLyBUaGUgd2l0aG91dCBvcHRpbWlzdGljIHRyZWUgY2FzZSBoYXBwZW5zIHdoZW4gdGhlcmUgaXMgbm8gbG9hZGluZyBzdGF0ZSwgaW4gdGhhdCBjYXNlIHdlIHN1c3BlbmQgaW4gdGhpcyByZWR1Y2VyXG4gICAgICAgICAgICAgICAgLy8gZm9yY2VPcHRpbWlzdGljTmF2aWdhdGlvbiBpcyB1c2VkIGZvciBsaW5rcyB0aGF0IGhhdmUgYHByZWZldGNoPXtmYWxzZX1gLlxuICAgICAgICAgICAgICAgIGlmIChmb3JjZU9wdGltaXN0aWNOYXZpZ2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlZ21lbnRzID0gcGF0aG5hbWUuc3BsaXQoJy8nKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETy1BUFA6IGZpZ3VyZSBvdXQgc29tZXRoaW5nIGJldHRlciBmb3IgaW5kZXggcGFnZXNcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudHMucHVzaCgnJyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9wdGltaXN0aWMgdHJlZSBjYXNlLlxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgb3B0aW1pc3RpYyB0cmVlIGlzIGRlZXBlciB0aGFuIHRoZSBjdXJyZW50IHN0YXRlIGxlYXZlIHRoYXQgZGVlcGVyIHBhcnQgb3V0IG9mIHRoZSBmZXRjaFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcHRpbWlzdGljVHJlZSA9IGNyZWF0ZU9wdGltaXN0aWNUcmVlKHNlZ21lbnRzLCBzdGF0ZS50cmVlLCB0cnVlLCBmYWxzZSwgaHJlZik7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvcHkgc3ViVHJlZURhdGEgZm9yIHRoZSByb290IG5vZGUgb2YgdGhlIGNhY2hlLlxuICAgICAgICAgICAgICAgICAgICBjYWNoZS5zdWJUcmVlRGF0YSA9IHN0YXRlLmNhY2hlLnN1YlRyZWVEYXRhO1xuICAgICAgICAgICAgICAgICAgICAvLyBDb3B5IGV4aXN0aW5nIGNhY2hlIG5vZGVzIGFzIGZhciBhcyBwb3NzaWJsZSBhbmQgZmlsbCBpbiBgZGF0YWAgcHJvcGVydHkgd2l0aCB0aGUgc3RhcnRlZCBkYXRhIGZldGNoLlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgYGRhdGFgIHByb3BlcnR5IGlzIHVzZWQgdG8gc3VzcGVuZCBpbiBsYXlvdXQtcm91dGVyIGR1cmluZyByZW5kZXIgaWYgaXQgaGFzbid0IHJlc29sdmVkIHlldCBieSB0aGUgdGltZSBpdCByZW5kZXJzLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBmaWxsQ2FjaGVXaXRoRGF0YVByb3BlcnR5KGNhY2hlLCBzdGF0ZS5jYWNoZSwgLy8gVE9ETy1BUFA6IHNlZ21lbnRzLnNsaWNlKDEpIHN0cmlwcyAnJywgd2UgY2FuIGdldCByaWQgb2YgJycgYWx0b2dldGhlci5cbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudHMuc2xpY2UoMSksICgpPT4oMCwgX2FwcFJvdXRlcikuZmV0Y2hTZXJ2ZXJSZXNwb25zZSh1cmwsIG9wdGltaXN0aWNUcmVlKSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIG9wdGltaXN0aWMgZmV0Y2ggY291bGRuJ3QgaGFwcGVuIGl0IGZhbGxzIGJhY2sgdG8gdGhlIG5vbi1vcHRpbWlzdGljIGNhc2UuXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHJlcyA9PSBudWxsID8gdm9pZCAwIDogcmVzLmJhaWxPcHRpbWlzdGljKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YWJsZS5wcmV2aW91c1RyZWUgPSBzdGF0ZS50cmVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YWJsZS5wYXRjaGVkVHJlZSA9IG9wdGltaXN0aWNUcmVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YWJsZS5tcGFOYXZpZ2F0aW9uID0gaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0KHN0YXRlLnRyZWUsIG9wdGltaXN0aWNUcmVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGhyZWYuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2Fub25pY2FsVXJsOiBocmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldCBwZW5kaW5nUHVzaC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXNoUmVmOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdQdXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtcGFOYXZpZ2F0aW9uOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsIG5hdmlnYXRpb24gcmVxdWlyZXMgc2Nyb2xsIGFuZCBmb2N1cyBtYW5hZ2VtZW50IHRvIHRyaWdnZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWY6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHk6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IHBhdGNoZWQgY2FjaGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGU6IGNhY2hlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWZldGNoQ2FjaGU6IHN0YXRlLnByZWZldGNoQ2FjaGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgb3B0aW1pc3RpYyB0cmVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyZWU6IG9wdGltaXN0aWNUcmVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEJlbG93IGlzIHRoZSBub3Qtb3B0aW1pc3RpYyBjYXNlLiBEYXRhIGlzIGZldGNoZWQgYXQgdGhlIHJvb3QgYW5kIHN1c3BlbmRlZCB0aGVyZSB3aXRob3V0IGEgc3VzcGVuc2UgYm91bmRhcnkuXG4gICAgICAgICAgICAgICAgLy8gSWYgbm8gaW4tZmxpZ2h0IGZldGNoIGF0IHRoZSB0b3AsIHN0YXJ0IGl0LlxuICAgICAgICAgICAgICAgIGlmICghY2FjaGUuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZS5kYXRhID0gY3JlYXRlUmVjb3JkRnJvbVRoZW5hYmxlKCgwLCBfYXBwUm91dGVyKS5mZXRjaFNlcnZlclJlc3BvbnNlKHVybCwgc3RhdGUudHJlZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVbndyYXAgY2FjaGUgZGF0YSB3aXRoIGB1c2VgIHRvIHN1c3BlbmQgaGVyZSAoaW4gdGhlIHJlZHVjZXIpIHVudGlsIHRoZSBmZXRjaCByZXNvbHZlcy5cbiAgICAgICAgICAgICAgICBjb25zdCBbZmxpZ2h0RGF0YSwgY2Fub25pY2FsVXJsT3ZlcnJpZGVdID0gcmVhZFJlY29yZFZhbHVlKGNhY2hlLmRhdGEpO1xuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gbmF2aWdhdGluZyB0byBwYWdlIGluIGBwYWdlc2AgZnJvbSBgYXBwYFxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZmxpZ2h0RGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbm9uaWNhbFVybDogZmxpZ2h0RGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuYWJsZSBtcGFOYXZpZ2F0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoUmVmOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1B1c2g6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXBhTmF2aWdhdGlvbjogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGFwcGx5IHNjcm9sbCBhbmQgZm9jdXMgbWFuYWdlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHk6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGU6IHN0YXRlLmNhY2hlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmV0Y2hDYWNoZTogc3RhdGUucHJlZmV0Y2hDYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyZWU6IHN0YXRlLnRyZWVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGNhY2hlLmRhdGEgYXMgaXQgaGFzIGJlZW4gcmVzb2x2ZWQgYXQgdGhpcyBwb2ludC5cbiAgICAgICAgICAgICAgICBjYWNoZS5kYXRhID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvLyBUT0RPLUFQUDogQ3VycmVudGx5IHRoZSBGbGlnaHQgZGF0YSBjYW4gb25seSBoYXZlIG9uZSBpdGVtIGJ1dCBpbiB0aGUgZnV0dXJlIGl0IGNhbiBoYXZlIG11bHRpcGxlIHBhdGhzLlxuICAgICAgICAgICAgICAgIGNvbnN0IGZsaWdodERhdGFQYXRoID0gZmxpZ2h0RGF0YVswXTtcbiAgICAgICAgICAgICAgICAvLyBUaGUgb25lIGJlZm9yZSBsYXN0IGl0ZW0gaXMgdGhlIHJvdXRlciBzdGF0ZSB0cmVlIHBhdGNoXG4gICAgICAgICAgICAgICAgY29uc3QgW3RyZWVQYXRjaCwgc3ViVHJlZURhdGFdID0gZmxpZ2h0RGF0YVBhdGguc2xpY2UoLTIpO1xuICAgICAgICAgICAgICAgIC8vIFBhdGggd2l0aG91dCB0aGUgbGFzdCBzZWdtZW50LCByb3V0ZXIgc3RhdGUsIGFuZCB0aGUgc3ViVHJlZURhdGFcbiAgICAgICAgICAgICAgICBjb25zdCBmbGlnaHRTZWdtZW50UGF0aCA9IGZsaWdodERhdGFQYXRoLnNsaWNlKDAsIC0zKTtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgbmV3IHRyZWUgYmFzZWQgb24gdGhlIGZsaWdodFNlZ21lbnRQYXRoIGFuZCByb3V0ZXIgc3RhdGUgcGF0Y2hcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdUcmVlID0gYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlKC8vIFRPRE8tQVBQOiByZW1vdmUgJydcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgICAgICAgICAuLi5mbGlnaHRTZWdtZW50UGF0aFxuICAgICAgICAgICAgICAgIF0sIHN0YXRlLnRyZWUsIHRyZWVQYXRjaCk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1RyZWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTRUdNRU5UIE1JU01BVENIJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiA9IGNhbm9uaWNhbFVybE92ZXJyaWRlID8gY3JlYXRlSHJlZkZyb21VcmwoY2Fub25pY2FsVXJsT3ZlcnJpZGUpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmIChjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgbXV0YWJsZS5jYW5vbmljYWxVcmxPdmVycmlkZSA9IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbXV0YWJsZS5wcmV2aW91c1RyZWUgPSBzdGF0ZS50cmVlO1xuICAgICAgICAgICAgICAgIG11dGFibGUucGF0Y2hlZFRyZWUgPSBuZXdUcmVlO1xuICAgICAgICAgICAgICAgIG11dGFibGUubXBhTmF2aWdhdGlvbiA9IGlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dChzdGF0ZS50cmVlLCBuZXdUcmVlKTtcbiAgICAgICAgICAgICAgICBpZiAoZmxpZ2h0RGF0YVBhdGgubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlLnN1YlRyZWVEYXRhID0gc3ViVHJlZURhdGE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29weSBzdWJUcmVlRGF0YSBmb3IgdGhlIHJvb3Qgbm9kZSBvZiB0aGUgY2FjaGUuXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlLnN1YlRyZWVEYXRhID0gc3RhdGUuY2FjaGUuc3ViVHJlZURhdGE7XG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIGNvcHkgb2YgdGhlIGV4aXN0aW5nIGNhY2hlIHdpdGggdGhlIHN1YlRyZWVEYXRhIGFwcGxpZWQuXG4gICAgICAgICAgICAgICAgICAgIGZpbGxDYWNoZVdpdGhOZXdTdWJUcmVlRGF0YShjYWNoZSwgc3RhdGUuY2FjaGUsIGZsaWdodERhdGFQYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGhyZWYuXG4gICAgICAgICAgICAgICAgICAgIGNhbm9uaWNhbFVybDogY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmID8gY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmIDogaHJlZixcbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHBlbmRpbmdQdXNoLlxuICAgICAgICAgICAgICAgICAgICBwdXNoUmVmOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nUHVzaCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1wYU5hdmlnYXRpb246IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIC8vIEFsbCBuYXZpZ2F0aW9uIHJlcXVpcmVzIHNjcm9sbCBhbmQgZm9jdXMgbWFuYWdlbWVudCB0byB0cmlnZ2VyLlxuICAgICAgICAgICAgICAgICAgICBmb2N1c0FuZFNjcm9sbFJlZjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHk6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgcGF0Y2hlZCBjYWNoZS5cbiAgICAgICAgICAgICAgICAgICAgY2FjaGU6IGNhY2hlLFxuICAgICAgICAgICAgICAgICAgICBwcmVmZXRjaENhY2hlOiBzdGF0ZS5wcmVmZXRjaENhY2hlLFxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBwYXRjaGVkIHRyZWUuXG4gICAgICAgICAgICAgICAgICAgIHRyZWU6IG5ld1RyZWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIEFDVElPTl9TRVJWRVJfUEFUQ0g6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBmbGlnaHREYXRhICwgcHJldmlvdXNUcmVlICwgb3ZlcnJpZGVDYW5vbmljYWxVcmwgLCBjYWNoZSAsIG11dGFibGUgIH0gPSBhY3Rpb247XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBhIGZldGNoIGlzIHNsb3cgdG8gcmVzb2x2ZSBpdCBjb3VsZCBiZSB0aGF0IHlvdSBuYXZpZ2F0ZWQgYXdheSB3aGlsZSB0aGUgcmVxdWVzdCB3YXMgaGFwcGVuaW5nIG9yIGJlZm9yZSB0aGUgcmVkdWNlciBydW5zLlxuICAgICAgICAgICAgICAgIC8vIEluIHRoYXQgY2FzZSBvcHQtb3V0IG9mIGFwcGx5aW5nIHRoZSBwYXRjaCBnaXZlbiB0aGF0IHRoZSBkYXRhIGNvdWxkIGJlIHN0YWxlLlxuICAgICAgICAgICAgICAgIGlmIChKU09OLnN0cmluZ2lmeShwcmV2aW91c1RyZWUpICE9PSBKU09OLnN0cmluZ2lmeShzdGF0ZS50cmVlKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPLUFQUDogSGFuZGxlIHRyZWUgbWlzbWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1RSRUUgTUlTTUFUQ0gnKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gS2VlcCBldmVyeXRoaW5nIGFzLWlzLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtdXRhYmxlLm1wYU5hdmlnYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldCBocmVmLlxuICAgICAgICAgICAgICAgICAgICAgICAgY2Fub25pY2FsVXJsOiBtdXRhYmxlLmNhbm9uaWNhbFVybE92ZXJyaWRlID8gbXV0YWJsZS5jYW5vbmljYWxVcmxPdmVycmlkZSA6IHN0YXRlLmNhbm9uaWNhbFVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8tQVBQOiB2ZXJpZnkgbXBhTmF2aWdhdGlvbiBub3QgYmVpbmcgc2V0IGlzIGNvcnJlY3QgaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hSZWY6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nUHVzaDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtcGFOYXZpZ2F0aW9uOiBtdXRhYmxlLm1wYU5hdmlnYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGwgbmF2aWdhdGlvbiByZXF1aXJlcyBzY3JvbGwgYW5kIGZvY3VzIG1hbmFnZW1lbnQgdG8gdHJpZ2dlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHk6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgY2FjaGUuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZTogc3RhdGUuY2FjaGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmZXRjaENhY2hlOiBzdGF0ZS5wcmVmZXRjaENhY2hlLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgcGF0Y2hlZCByb3V0ZXIgc3RhdGUuXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmVlOiBzdGF0ZS50cmVlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBjb25jdXJyZW50IHJlbmRlcmluZyAvIHN0cmljdCBtb2RlIGNhc2Ugd2hlcmUgdGhlIGNhY2hlIGFuZCB0cmVlIHdlcmUgYWxyZWFkeSBwb3B1bGF0ZWQuXG4gICAgICAgICAgICAgICAgaWYgKG11dGFibGUucGF0Y2hlZFRyZWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEtlZXAgaHJlZiBhcyBpdCB3YXMgc2V0IGR1cmluZyBuYXZpZ2F0ZSAvIHJlc3RvcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbm9uaWNhbFVybDogbXV0YWJsZS5jYW5vbmljYWxVcmxPdmVycmlkZSA/IG11dGFibGUuY2Fub25pY2FsVXJsT3ZlcnJpZGUgOiBzdGF0ZS5jYW5vbmljYWxVcmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBLZWVwIHB1c2hSZWYgYXMgc2VydmVyLXBhdGNoIG9ubHkgY2F1c2VzIGNhY2hlL3RyZWUgdXBkYXRlLlxuICAgICAgICAgICAgICAgICAgICAgICAgcHVzaFJlZjogc3RhdGUucHVzaFJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEtlZXAgZm9jdXNBbmRTY3JvbGxSZWYgYXMgc2VydmVyLXBhdGNoIG9ubHkgY2F1c2VzIGNhY2hlL3RyZWUgdXBkYXRlLlxuICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWY6IHN0YXRlLmZvY3VzQW5kU2Nyb2xsUmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgcGF0Y2hlZCByb3V0ZXIgc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyZWU6IG11dGFibGUucGF0Y2hlZFRyZWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmZXRjaENhY2hlOiBzdGF0ZS5wcmVmZXRjaENhY2hlLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgcGF0Y2hlZCBjYWNoZVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGU6IGNhY2hlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gbmF2aWdhdGluZyB0byBwYWdlIGluIGBwYWdlc2AgZnJvbSBgYXBwYFxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZmxpZ2h0RGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldCBocmVmLlxuICAgICAgICAgICAgICAgICAgICAgICAgY2Fub25pY2FsVXJsOiBmbGlnaHREYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5hYmxlIG1wYU5hdmlnYXRpb24gYXMgdGhpcyBpcyBhIG5hdmlnYXRpb24gdGhhdCB0aGUgYXBwLXJvdXRlciBzaG91bGRuJ3QgaGFuZGxlLlxuICAgICAgICAgICAgICAgICAgICAgICAgcHVzaFJlZjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdQdXNoOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1wYU5hdmlnYXRpb246IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBhcHBseSBzY3JvbGwgYW5kIGZvY3VzIG1hbmFnZW1lbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb2N1c0FuZFNjcm9sbFJlZjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGx5OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyIHN0YXRlIGlzIGtlcHQgYXMtaXMuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZTogc3RhdGUuY2FjaGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmZXRjaENhY2hlOiBzdGF0ZS5wcmVmZXRjaENhY2hlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJlZTogc3RhdGUudHJlZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUT0RPLUFQUDogQ3VycmVudGx5IHRoZSBGbGlnaHQgZGF0YSBjYW4gb25seSBoYXZlIG9uZSBpdGVtIGJ1dCBpbiB0aGUgZnV0dXJlIGl0IGNhbiBoYXZlIG11bHRpcGxlIHBhdGhzLlxuICAgICAgICAgICAgICAgIGNvbnN0IGZsaWdodERhdGFQYXRoID0gZmxpZ2h0RGF0YVswXTtcbiAgICAgICAgICAgICAgICAvLyBTbGljZXMgb2ZmIHRoZSBsYXN0IHNlZ21lbnQgKHdoaWNoIGlzIGF0IC0zKSBhcyBpdCBkb2Vzbid0IGV4aXN0IGluIHRoZSB0cmVlIHlldFxuICAgICAgICAgICAgICAgIGNvbnN0IHRyZWVQYXRoID0gZmxpZ2h0RGF0YVBhdGguc2xpY2UoMCwgLTMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IFt0cmVlUGF0Y2gsIHN1YlRyZWVEYXRhXSA9IGZsaWdodERhdGFQYXRoLnNsaWNlKC0yKTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdUcmVlID0gYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlKC8vIFRPRE8tQVBQOiByZW1vdmUgJydcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgICAgICAgICAuLi50cmVlUGF0aFxuICAgICAgICAgICAgICAgIF0sIHN0YXRlLnRyZWUsIHRyZWVQYXRjaCk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1RyZWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTRUdNRU5UIE1JU01BVENIJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiA9IG92ZXJyaWRlQ2Fub25pY2FsVXJsID8gY3JlYXRlSHJlZkZyb21Vcmwob3ZlcnJpZGVDYW5vbmljYWxVcmwpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmIChjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgbXV0YWJsZS5jYW5vbmljYWxVcmxPdmVycmlkZSA9IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbXV0YWJsZS5wYXRjaGVkVHJlZSA9IG5ld1RyZWU7XG4gICAgICAgICAgICAgICAgbXV0YWJsZS5tcGFOYXZpZ2F0aW9uID0gaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0KHN0YXRlLnRyZWUsIG5ld1RyZWUpO1xuICAgICAgICAgICAgICAgIC8vIFJvb3QgcmVmcmVzaFxuICAgICAgICAgICAgICAgIGlmIChmbGlnaHREYXRhUGF0aC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGUuc3ViVHJlZURhdGEgPSBzdWJUcmVlRGF0YTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb3B5IHN1YlRyZWVEYXRhIGZvciB0aGUgcm9vdCBub2RlIG9mIHRoZSBjYWNoZS5cbiAgICAgICAgICAgICAgICAgICAgY2FjaGUuc3ViVHJlZURhdGEgPSBzdGF0ZS5jYWNoZS5zdWJUcmVlRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgZmlsbENhY2hlV2l0aE5ld1N1YlRyZWVEYXRhKGNhY2hlLCBzdGF0ZS5jYWNoZSwgZmxpZ2h0RGF0YVBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBLZWVwIGhyZWYgYXMgaXQgd2FzIHNldCBkdXJpbmcgbmF2aWdhdGUgLyByZXN0b3JlXG4gICAgICAgICAgICAgICAgICAgIGNhbm9uaWNhbFVybDogY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmID8gY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmIDogc3RhdGUuY2Fub25pY2FsVXJsLFxuICAgICAgICAgICAgICAgICAgICAvLyBLZWVwIHB1c2hSZWYgYXMgc2VydmVyLXBhdGNoIG9ubHkgY2F1c2VzIGNhY2hlL3RyZWUgdXBkYXRlLlxuICAgICAgICAgICAgICAgICAgICBwdXNoUmVmOiBzdGF0ZS5wdXNoUmVmLFxuICAgICAgICAgICAgICAgICAgICAvLyBLZWVwIGZvY3VzQW5kU2Nyb2xsUmVmIGFzIHNlcnZlci1wYXRjaCBvbmx5IGNhdXNlcyBjYWNoZS90cmVlIHVwZGF0ZS5cbiAgICAgICAgICAgICAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWY6IHN0YXRlLmZvY3VzQW5kU2Nyb2xsUmVmLFxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBwYXRjaGVkIHJvdXRlciBzdGF0ZVxuICAgICAgICAgICAgICAgICAgICB0cmVlOiBuZXdUcmVlLFxuICAgICAgICAgICAgICAgICAgICBwcmVmZXRjaENhY2hlOiBzdGF0ZS5wcmVmZXRjaENhY2hlLFxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBwYXRjaGVkIGNhY2hlXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlOiBjYWNoZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgQUNUSU9OX1JFU1RPUkU6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB1cmwgLCB0cmVlICB9ID0gYWN0aW9uO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhyZWYgPSBjcmVhdGVIcmVmRnJvbVVybCh1cmwpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCBjYW5vbmljYWwgdXJsXG4gICAgICAgICAgICAgICAgICAgIGNhbm9uaWNhbFVybDogaHJlZixcbiAgICAgICAgICAgICAgICAgICAgcHVzaFJlZjogc3RhdGUucHVzaFJlZixcbiAgICAgICAgICAgICAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWY6IHN0YXRlLmZvY3VzQW5kU2Nyb2xsUmVmLFxuICAgICAgICAgICAgICAgICAgICBjYWNoZTogc3RhdGUuY2FjaGUsXG4gICAgICAgICAgICAgICAgICAgIHByZWZldGNoQ2FjaGU6IHN0YXRlLnByZWZldGNoQ2FjaGUsXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc3RvcmUgcHJvdmlkZWQgdHJlZVxuICAgICAgICAgICAgICAgICAgICB0cmVlOiB0cmVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBBQ1RJT05fUkVGUkVTSDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGNhY2hlICwgbXV0YWJsZSAgfSA9IGFjdGlvbjtcbiAgICAgICAgICAgICAgICBjb25zdCBocmVmID0gc3RhdGUuY2Fub25pY2FsVXJsO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzRm9yQ3VycmVudFRyZWUgPSBKU09OLnN0cmluZ2lmeShtdXRhYmxlLnByZXZpb3VzVHJlZSkgPT09IEpTT04uc3RyaW5naWZ5KHN0YXRlLnRyZWUpO1xuICAgICAgICAgICAgICAgIGlmIChtdXRhYmxlLm1wYU5hdmlnYXRpb24gJiYgaXNGb3JDdXJyZW50VHJlZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGhyZWYuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5vbmljYWxVcmw6IG11dGFibGUuY2Fub25pY2FsVXJsT3ZlcnJpZGUgPyBtdXRhYmxlLmNhbm9uaWNhbFVybE92ZXJyaWRlIDogc3RhdGUuY2Fub25pY2FsVXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETy1BUFA6IHZlcmlmeSBtcGFOYXZpZ2F0aW9uIG5vdCBiZWluZyBzZXQgaXMgY29ycmVjdCBoZXJlLlxuICAgICAgICAgICAgICAgICAgICAgICAgcHVzaFJlZjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdQdXNoOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1wYU5hdmlnYXRpb246IG11dGFibGUubXBhTmF2aWdhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbCBuYXZpZ2F0aW9uIHJlcXVpcmVzIHNjcm9sbCBhbmQgZm9jdXMgbWFuYWdlbWVudCB0byB0cmlnZ2VyLlxuICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWY6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBseTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBjYWNoZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlOiBzdGF0ZS5jYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZldGNoQ2FjaGU6IHN0YXRlLnByZWZldGNoQ2FjaGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBwYXRjaGVkIHJvdXRlciBzdGF0ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyZWU6IHN0YXRlLnRyZWVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIGNvbmN1cnJlbnQgcmVuZGVyaW5nIC8gc3RyaWN0IG1vZGUgY2FzZSB3aGVyZSB0aGUgY2FjaGUgYW5kIHRyZWUgd2VyZSBhbHJlYWR5IHBvcHVsYXRlZC5cbiAgICAgICAgICAgICAgICBpZiAobXV0YWJsZS5wYXRjaGVkVHJlZSAmJiBpc0ZvckN1cnJlbnRUcmVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgaHJlZi5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbm9uaWNhbFVybDogbXV0YWJsZS5jYW5vbmljYWxVcmxPdmVycmlkZSA/IG11dGFibGUuY2Fub25pY2FsVXJsT3ZlcnJpZGUgOiBocmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0IHBlbmRpbmdQdXNoIChhbHdheXMgZmFsc2UgaW4gdGhpcyBjYXNlKS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hSZWY6IHN0YXRlLnB1c2hSZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBmb2N1cyBhbmQgc2Nyb2xsLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETy1BUFA6IG1pZ2h0IG5lZWQgdG8gZGlzYWJsZSB0aGlzIGZvciBGYXN0IFJlZnJlc2guXG4gICAgICAgICAgICAgICAgICAgICAgICBmb2N1c0FuZFNjcm9sbFJlZjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGx5OiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGU6IGNhY2hlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmV0Y2hDYWNoZTogc3RhdGUucHJlZmV0Y2hDYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyZWU6IG11dGFibGUucGF0Y2hlZFRyZWVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFjYWNoZS5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZldGNoIGRhdGEgZnJvbSB0aGUgcm9vdCBvZiB0aGUgdHJlZS5cbiAgICAgICAgICAgICAgICAgICAgY2FjaGUuZGF0YSA9IGNyZWF0ZVJlY29yZEZyb21UaGVuYWJsZSgoMCwgX2FwcFJvdXRlcikuZmV0Y2hTZXJ2ZXJSZXNwb25zZShuZXcgVVJMKGhyZWYsIGxvY2F0aW9uLm9yaWdpbiksIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnRyZWVbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS50cmVlWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUudHJlZVsyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdyZWZldGNoJywgXG4gICAgICAgICAgICAgICAgICAgIF0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgW2ZsaWdodERhdGEsIGNhbm9uaWNhbFVybE92ZXJyaWRlXSA9IHJlYWRSZWNvcmRWYWx1ZShjYWNoZS5kYXRhKTtcbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgY2FzZSB3aGVuIG5hdmlnYXRpbmcgdG8gcGFnZSBpbiBgcGFnZXNgIGZyb20gYGFwcGBcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZsaWdodERhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5vbmljYWxVcmw6IGZsaWdodERhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoUmVmOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1B1c2g6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXBhTmF2aWdhdGlvbjogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHk6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGU6IHN0YXRlLmNhY2hlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmV0Y2hDYWNoZTogc3RhdGUucHJlZmV0Y2hDYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyZWU6IHN0YXRlLnRyZWVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGNhY2hlLmRhdGEgYXMgaXQgaGFzIGJlZW4gcmVzb2x2ZWQgYXQgdGhpcyBwb2ludC5cbiAgICAgICAgICAgICAgICBjYWNoZS5kYXRhID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvLyBUT0RPLUFQUDogQ3VycmVudGx5IHRoZSBGbGlnaHQgZGF0YSBjYW4gb25seSBoYXZlIG9uZSBpdGVtIGJ1dCBpbiB0aGUgZnV0dXJlIGl0IGNhbiBoYXZlIG11bHRpcGxlIHBhdGhzLlxuICAgICAgICAgICAgICAgIGNvbnN0IGZsaWdodERhdGFQYXRoID0gZmxpZ2h0RGF0YVswXTtcbiAgICAgICAgICAgICAgICAvLyBGbGlnaHREYXRhUGF0aCB3aXRoIG1vcmUgdGhhbiB0d28gaXRlbXMgbWVhbnMgdW5leHBlY3RlZCBGbGlnaHQgZGF0YSB3YXMgcmV0dXJuZWRcbiAgICAgICAgICAgICAgICBpZiAoZmxpZ2h0RGF0YVBhdGgubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8tQVBQOiBoYW5kbGUgdGhpcyBjYXNlIGJldHRlclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUkVGUkVTSCBGQUlMRUQnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBHaXZlbiB0aGUgcGF0aCBjYW4gb25seSBoYXZlIHR3byBpdGVtcyB0aGUgaXRlbXMgYXJlIG9ubHkgdGhlIHJvdXRlciBzdGF0ZSBhbmQgc3ViVHJlZURhdGEgZm9yIHRoZSByb290LlxuICAgICAgICAgICAgICAgIGNvbnN0IFt0cmVlUGF0Y2gsIHN1YlRyZWVEYXRhXSA9IGZsaWdodERhdGFQYXRoO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1RyZWUgPSBhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUoLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgJydcbiAgICAgICAgICAgICAgICBdLCBzdGF0ZS50cmVlLCB0cmVlUGF0Y2gpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdUcmVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU0VHTUVOVCBNSVNNQVRDSCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYgPSBjYW5vbmljYWxVcmxPdmVycmlkZSA/IGNyZWF0ZUhyZWZGcm9tVXJsKGNhbm9uaWNhbFVybE92ZXJyaWRlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpZiAoY2Fub25pY2FsVXJsT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbXV0YWJsZS5jYW5vbmljYWxVcmxPdmVycmlkZSA9IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbXV0YWJsZS5wcmV2aW91c1RyZWUgPSBzdGF0ZS50cmVlO1xuICAgICAgICAgICAgICAgIG11dGFibGUucGF0Y2hlZFRyZWUgPSBuZXdUcmVlO1xuICAgICAgICAgICAgICAgIG11dGFibGUubXBhTmF2aWdhdGlvbiA9IGlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dChzdGF0ZS50cmVlLCBuZXdUcmVlKTtcbiAgICAgICAgICAgICAgICAvLyBTZXQgc3ViVHJlZURhdGEgZm9yIHRoZSByb290IG5vZGUgb2YgdGhlIGNhY2hlLlxuICAgICAgICAgICAgICAgIGNhY2hlLnN1YlRyZWVEYXRhID0gc3ViVHJlZURhdGE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGhyZWYsIHRoaXMgZG9lc24ndCByZXVzZSB0aGUgc3RhdGUuY2Fub25pY2FsVXJsIGFzIGJlY2F1c2Ugb2YgY29uY3VycmVudCByZW5kZXJpbmcgdGhlIGhyZWYgbWlnaHQgY2hhbmdlIGJldHdlZW4gZGlzcGF0Y2hpbmcgYW5kIGFwcGx5aW5nLlxuICAgICAgICAgICAgICAgICAgICBjYW5vbmljYWxVcmw6IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiA/IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiA6IGhyZWYsXG4gICAgICAgICAgICAgICAgICAgIC8vIHNldCBwZW5kaW5nUHVzaCAoYWx3YXlzIGZhbHNlIGluIHRoaXMgY2FzZSkuXG4gICAgICAgICAgICAgICAgICAgIHB1c2hSZWY6IHN0YXRlLnB1c2hSZWYsXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8tQVBQOiBtaWdodCBuZWVkIHRvIGRpc2FibGUgdGhpcyBmb3IgRmFzdCBSZWZyZXNoLlxuICAgICAgICAgICAgICAgICAgICBmb2N1c0FuZFNjcm9sbFJlZjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHk6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IHBhdGNoZWQgY2FjaGUuXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlOiBjYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgcHJlZmV0Y2hDYWNoZTogc3RhdGUucHJlZmV0Y2hDYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgcGF0Y2hlZCByb3V0ZXIgc3RhdGUuXG4gICAgICAgICAgICAgICAgICAgIHRyZWU6IG5ld1RyZWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIEFDVElPTl9QUkVGRVRDSDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHVybCAsIHNlcnZlclJlc3BvbnNlICB9ID0gYWN0aW9uO1xuICAgICAgICAgICAgICAgIGNvbnN0IFtmbGlnaHREYXRhLCBjYW5vbmljYWxVcmxPdmVycmlkZV0gPSBzZXJ2ZXJSZXNwb25zZTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPLUFQUDogSW1wbGVtZW50IHByZWZldGNoIGZvciBoYXJkIG5hdmlnYXRpb25cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZsaWdodERhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaHJlZiA9IGNyZWF0ZUhyZWZGcm9tVXJsKHVybCk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETy1BUFA6IEN1cnJlbnRseSB0aGUgRmxpZ2h0IGRhdGEgY2FuIG9ubHkgaGF2ZSBvbmUgaXRlbSBidXQgaW4gdGhlIGZ1dHVyZSBpdCBjYW4gaGF2ZSBtdWx0aXBsZSBwYXRocy5cbiAgICAgICAgICAgICAgICBjb25zdCBmbGlnaHREYXRhUGF0aCA9IGZsaWdodERhdGFbMF07XG4gICAgICAgICAgICAgICAgLy8gVGhlIG9uZSBiZWZvcmUgbGFzdCBpdGVtIGlzIHRoZSByb3V0ZXIgc3RhdGUgdHJlZSBwYXRjaFxuICAgICAgICAgICAgICAgIGNvbnN0IFt0cmVlUGF0Y2gsIHN1YlRyZWVEYXRhXSA9IGZsaWdodERhdGFQYXRoLnNsaWNlKC0yKTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPLUFQUDogVmVyaWZ5IGlmIGBudWxsYCBjYW4ndCBiZSByZXR1cm5lZCBmcm9tIHVzZXIgY29kZS5cbiAgICAgICAgICAgICAgICAvLyBJZiBzdWJUcmVlRGF0YSBpcyBudWxsIHRoZSBwcmVmZXRjaCBkaWQgbm90IHByb3ZpZGUgYSBjb21wb25lbnQgdHJlZS5cbiAgICAgICAgICAgICAgICBpZiAoc3ViVHJlZURhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsbENhY2hlV2l0aFByZWZldGNoZWRTdWJUcmVlRGF0YShzdGF0ZS5jYWNoZSwgZmxpZ2h0RGF0YVBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBmbGlnaHRTZWdtZW50UGF0aCA9IGZsaWdodERhdGFQYXRoLnNsaWNlKDAsIC0yKTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdUcmVlID0gYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlKC8vIFRPRE8tQVBQOiByZW1vdmUgJydcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgICAgICAgICAuLi5mbGlnaHRTZWdtZW50UGF0aFxuICAgICAgICAgICAgICAgIF0sIHN0YXRlLnRyZWUsIHRyZWVQYXRjaCk7XG4gICAgICAgICAgICAgICAgLy8gUGF0Y2ggZGlkIG5vdCBhcHBseSBjb3JyZWN0bHlcbiAgICAgICAgICAgICAgICBpZiAobmV3VHJlZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBuZXcgdHJlZSBiYXNlZCBvbiB0aGUgZmxpZ2h0U2VnbWVudFBhdGggYW5kIHJvdXRlciBzdGF0ZSBwYXRjaFxuICAgICAgICAgICAgICAgIHN0YXRlLnByZWZldGNoQ2FjaGUuc2V0KGhyZWYsIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUGF0aCB3aXRob3V0IHRoZSBsYXN0IHNlZ21lbnQsIHJvdXRlciBzdGF0ZSwgYW5kIHRoZSBzdWJUcmVlRGF0YVxuICAgICAgICAgICAgICAgICAgICBmbGlnaHRTZWdtZW50UGF0aCxcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIG5ldyB0cmVlIGJhc2VkIG9uIHRoZSBmbGlnaHRTZWdtZW50UGF0aCBhbmQgcm91dGVyIHN0YXRlIHBhdGNoXG4gICAgICAgICAgICAgICAgICAgIHRyZWU6IG5ld1RyZWUsXG4gICAgICAgICAgICAgICAgICAgIGNhbm9uaWNhbFVybE92ZXJyaWRlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIGNhc2Ugc2hvdWxkIG5ldmVyIGJlIGhpdCBhcyBkaXNwYXRjaCBpcyBzdHJvbmdseSB0eXBlZC5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBhY3Rpb24nKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXJ2ZXJSZWR1Y2VyKHN0YXRlLCBfYWN0aW9uKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xufVxuY29uc3QgcmVkdWNlciA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gc2VydmVyUmVkdWNlciA6IGNsaWVudFJlZHVjZXI7XG5leHBvcnRzLnJlZHVjZXIgPSByZWR1Y2VyO1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWR1Y2VyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInJlZHVjZXIiLCJBQ1RJT05fUFJFRkVUQ0giLCJBQ1RJT05fU0VSVkVSX1BBVENIIiwiQUNUSU9OX1JFU1RPUkUiLCJBQ1RJT05fTkFWSUdBVEUiLCJBQ1RJT05fUkVGUkVTSCIsIl9leHRlbmRzIiwicmVxdWlyZSIsImRlZmF1bHQiLCJfbWF0Y2hTZWdtZW50cyIsIl9hcHBSb3V0ZXIiLCJjcmVhdGVSZWNvcmRGcm9tVGhlbmFibGUiLCJ0aGVuYWJsZSIsInN0YXR1cyIsInRoZW4iLCJlcnIiLCJyZWFkUmVjb3JkVmFsdWUiLCJjcmVhdGVIcmVmRnJvbVVybCIsInVybCIsInBhdGhuYW1lIiwic2VhcmNoIiwiaGFzaCIsImludmFsaWRhdGVDYWNoZUJ5Um91dGVyU3RhdGUiLCJuZXdDYWNoZSIsImV4aXN0aW5nQ2FjaGUiLCJyb3V0ZXJTdGF0ZSIsImtleSIsInNlZ21lbnRGb3JQYXJhbGxlbFJvdXRlIiwiY2FjaGVLZXkiLCJBcnJheSIsImlzQXJyYXkiLCJleGlzdGluZ1BhcmFsbGVsUm91dGVzQ2FjaGVOb2RlIiwicGFyYWxsZWxSb3V0ZXMiLCJnZXQiLCJwYXJhbGxlbFJvdXRlQ2FjaGVOb2RlIiwiTWFwIiwiZGVsZXRlIiwic2V0IiwiZmlsbENhY2hlV2l0aE5ld1N1YlRyZWVEYXRhIiwiZmxpZ2h0RGF0YVBhdGgiLCJpc0xhc3RFbnRyeSIsImxlbmd0aCIsInBhcmFsbGVsUm91dGVLZXkiLCJzZWdtZW50Iiwic2VnbWVudEZvckNhY2hlIiwiZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXAiLCJjaGlsZFNlZ21lbnRNYXAiLCJleGlzdGluZ0NoaWxkQ2FjaGVOb2RlIiwiY2hpbGRDYWNoZU5vZGUiLCJkYXRhIiwic3ViVHJlZURhdGEiLCJzbGljZSIsImludmFsaWRhdGVDYWNoZUJlbG93RmxpZ2h0U2VnbWVudFBhdGgiLCJmbGlnaHRTZWdtZW50UGF0aCIsImZpbGxDYWNoZVdpdGhQcmVmZXRjaGVkU3ViVHJlZURhdGEiLCJmaWxsQ2FjaGVXaXRoRGF0YVByb3BlcnR5Iiwic2VnbWVudHMiLCJmZXRjaFJlc3BvbnNlIiwiYmFpbE9wdGltaXN0aWMiLCJjcmVhdGVPcHRpbWlzdGljVHJlZSIsImZsaWdodFJvdXRlclN0YXRlIiwiX2lzRmlyc3RTZWdtZW50IiwicGFyZW50UmVmZXRjaCIsIl9ocmVmIiwiZXhpc3RpbmdTZWdtZW50IiwiZXhpc3RpbmdQYXJhbGxlbFJvdXRlcyIsImlzTGFzdFNlZ21lbnQiLCJzZWdtZW50TWF0Y2hlcyIsIm1hdGNoU2VnbWVudCIsInNob3VsZFJlZmV0Y2hUaGlzTGV2ZWwiLCJjaGlsZFRyZWUiLCJjaGlsZEl0ZW0iLCJjaGlsZHJlbiIsInJlc3VsdCIsImFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSIsInRyZWVQYXRjaCIsImlzUm9vdExheW91dCIsInRyZWUiLCJjdXJyZW50U2VnbWVudCIsImxhc3RTZWdtZW50IiwicGFyYWxsZWxSb3V0ZVBhdGNoIiwic2hvdWxkSGFyZE5hdmlnYXRlIiwiaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0IiwiY3VycmVudFRyZWUiLCJuZXh0VHJlZSIsImN1cnJlbnRUcmVlU2VnbWVudCIsIm5leHRUcmVlU2VnbWVudCIsImN1cnJlbnRUcmVlQ2hpbGQiLCJ2YWx1ZXMiLCJuZXh0VHJlZUNoaWxkIiwiY2xpZW50UmVkdWNlciIsInN0YXRlIiwiYWN0aW9uIiwidHlwZSIsIm5hdmlnYXRlVHlwZSIsImNhY2hlIiwibXV0YWJsZSIsImZvcmNlT3B0aW1pc3RpY05hdmlnYXRpb24iLCJocmVmIiwicGVuZGluZ1B1c2giLCJpc0ZvckN1cnJlbnRUcmVlIiwiSlNPTiIsInN0cmluZ2lmeSIsInByZXZpb3VzVHJlZSIsIm1wYU5hdmlnYXRpb24iLCJjYW5vbmljYWxVcmwiLCJjYW5vbmljYWxVcmxPdmVycmlkZSIsInB1c2hSZWYiLCJmb2N1c0FuZFNjcm9sbFJlZiIsImFwcGx5IiwicHJlZmV0Y2hDYWNoZSIsInBhdGNoZWRUcmVlIiwidXNlRXhpc3RpbmdDYWNoZSIsInByZWZldGNoVmFsdWVzIiwibmV3VHJlZSIsImhhcmROYXZpZ2F0ZSIsImxvY2F0aW9uIiwiY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmIiwidW5kZWZpbmVkIiwic3BsaXQiLCJwdXNoIiwib3B0aW1pc3RpY1RyZWUiLCJyZXMiLCJmZXRjaFNlcnZlclJlc3BvbnNlIiwiZmxpZ2h0RGF0YSIsIkVycm9yIiwib3ZlcnJpZGVDYW5vbmljYWxVcmwiLCJjb25zb2xlIiwibG9nIiwidHJlZVBhdGgiLCJVUkwiLCJvcmlnaW4iLCJzZXJ2ZXJSZXNwb25zZSIsInNlcnZlclJlZHVjZXIiLCJfYWN0aW9uIiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./.yarn/__virtual__/next-virtual-393d91bbcd/0/cache/next-npm-13.0.2-b39abd22d0-f6fea2ee34.zip/node_modules/next/dist/client/components/reducer.js\n"));

/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-393d91bbcd/0/cache/next-npm-13.0.2-b39abd22d0-f6fea2ee34.zip/node_modules/next/dist/client/components/render-from-template-context.js":
/*!******************************************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-393d91bbcd/0/cache/next-npm-13.0.2-b39abd22d0-f6fea2ee34.zip/node_modules/next/dist/client/components/render-from-template-context.js ***!
  \******************************************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _s = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = RenderFromTemplateContext;\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"./.yarn/cache/@swc-helpers-npm-0.4.11-d20747f9c8-736857d524.zip/node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar _react = _interop_require_wildcard(__webpack_require__(/*! react */ \"./.yarn/__virtual__/next-virtual-393d91bbcd/0/cache/next-npm-13.0.2-b39abd22d0-f6fea2ee34.zip/node_modules/next/dist/compiled/react/index.js\"));\nvar _appRouterContext = __webpack_require__(/*! ../../shared/lib/app-router-context */ \"./.yarn/__virtual__/next-virtual-393d91bbcd/0/cache/next-npm-13.0.2-b39abd22d0-f6fea2ee34.zip/node_modules/next/dist/shared/lib/app-router-context.js\");\nfunction RenderFromTemplateContext() {\n    _s();\n    var children = (0, _react).useContext(_appRouterContext.TemplateContext);\n    return /*#__PURE__*/ _react[\"default\"].createElement(_react[\"default\"].Fragment, null, children);\n}\n_s(RenderFromTemplateContext, \"Fd1ieM0FAzMq7OA5+LlfYPV5S7Y=\");\n_c = RenderFromTemplateContext;\n\"use client\";\nif ((typeof exports[\"default\"] === \"function\" || typeof exports[\"default\"] === \"object\" && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === \"undefined\") {\n    Object.defineProperty(exports[\"default\"], \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports[\"default\"], exports);\n    module.exports = exports[\"default\"];\n} //# sourceMappingURL=render-from-template-context.js.map\nvar _c;\n$RefreshReg$(_c, \"RenderFromTemplateContext\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi8ueWFybi9fX3ZpcnR1YWxfXy9uZXh0LXZpcnR1YWwtMzkzZDkxYmJjZC8wL2NhY2hlL25leHQtbnBtLTEzLjAuMi1iMzlhYmQyMmQwLWY2ZmVhMmVlMzQuemlwL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVuZGVyLWZyb20tdGVtcGxhdGUtY29udGV4dC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFDYTs7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsa0JBQWUsR0FBR0c7QUFDbEIsSUFBSUMsNEJBQTRCQyxtTkFBZ0U7QUFDaEcsSUFBSUMsU0FBU0YsMEJBQTBCQyxtQkFBT0EsQ0FBQywySkFBTztBQUN0RCxJQUFJRSxvQkFBb0JGLG1CQUFPQSxDQUFDLGtNQUFxQztBQUNyRSxTQUFTRiw0QkFBNEI7O0lBQ2pDLElBQU1LLFdBQVcsQ0FBQyxHQUFHRixNQUFNLEVBQUVHLFVBQVUsQ0FBQ0Ysa0JBQWtCRyxlQUFlO0lBQ3pFLE9BQU8sV0FBVyxHQUFHSixNQUFPSixDQUFBQSxVQUFPLENBQUNTLGFBQWEsQ0FBQ0wsTUFBT0osQ0FBQUEsVUFBTyxDQUFDVSxRQUFRLEVBQUUsSUFBSSxFQUFFSjtBQUNyRjtHQUhTTDtLQUFBQTtBQUlUO0FBRUEsSUFBSSxDQUFDLE9BQU9ILE9BQVFFLENBQUFBLFVBQU8sS0FBSyxjQUFlLE9BQU9GLE9BQVFFLENBQUFBLFVBQU8sS0FBSyxZQUFZRixPQUFRRSxDQUFBQSxVQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9GLE9BQVFFLENBQUFBLFVBQU8sQ0FBQ1csVUFBVSxLQUFLLGFBQWE7SUFDcktmLE9BQU9DLGNBQWMsQ0FBQ0MsT0FBUUUsQ0FBQUEsVUFBTyxFQUFFLGNBQWM7UUFBRUQsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9nQixNQUFNLENBQUNkLE9BQVFFLENBQUFBLFVBQU8sRUFBRUY7SUFDL0JlLE9BQU9mLE9BQU8sR0FBR0EsT0FBUUUsQ0FBQUEsVUFBTztBQUNsQyxDQUFDLENBRUQsd0RBQXdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLy55YXJuL19fdmlydHVhbF9fL25leHQtdmlydHVhbC0zOTNkOTFiYmNkLzAvY2FjaGUvbmV4dC1ucG0tMTMuMC4yLWIzOWFiZDIyZDAtZjZmZWEyZWUzNC56aXAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yZW5kZXItZnJvbS10ZW1wbGF0ZS1jb250ZXh0LmpzP2IxMmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IFJlbmRlckZyb21UZW1wbGF0ZUNvbnRleHQ7XG52YXIgX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQuanNcIikuZGVmYXVsdDtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX2FwcFJvdXRlckNvbnRleHQgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHRcIik7XG5mdW5jdGlvbiBSZW5kZXJGcm9tVGVtcGxhdGVDb250ZXh0KCkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gKDAsIF9yZWFjdCkudXNlQ29udGV4dChfYXBwUm91dGVyQ29udGV4dC5UZW1wbGF0ZUNvbnRleHQpO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsIGNoaWxkcmVuKTtcbn1cbid1c2UgY2xpZW50JztcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVuZGVyLWZyb20tdGVtcGxhdGUtY29udGV4dC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWZhdWx0IiwiUmVuZGVyRnJvbVRlbXBsYXRlQ29udGV4dCIsIl9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQiLCJyZXF1aXJlIiwiX3JlYWN0IiwiX2FwcFJvdXRlckNvbnRleHQiLCJjaGlsZHJlbiIsInVzZUNvbnRleHQiLCJUZW1wbGF0ZUNvbnRleHQiLCJjcmVhdGVFbGVtZW50IiwiRnJhZ21lbnQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./.yarn/__virtual__/next-virtual-393d91bbcd/0/cache/next-npm-13.0.2-b39abd22d0-f6fea2ee34.zip/node_modules/next/dist/client/components/render-from-template-context.js\n"));

/***/ }),

/***/ "./.yarn/__virtual__/next-virtual-393d91bbcd/0/cache/next-npm-13.0.2-b39abd22d0-f6fea2ee34.zip/node_modules/next/dist/client/components/use-reducer-with-devtools.js":
/*!***************************************************************************************************************************************************************************!*\
  !*** ./.yarn/__virtual__/next-virtual-393d91bbcd/0/cache/next-npm-13.0.2-b39abd22d0-f6fea2ee34.zip/node_modules/next/dist/client/components/use-reducer-with-devtools.js ***!
  \***************************************************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArrayLimit(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.useReducerWithReduxDevtools = void 0;\nvar _react = __webpack_require__(/*! react */ \"./.yarn/__virtual__/next-virtual-393d91bbcd/0/cache/next-npm-13.0.2-b39abd22d0-f6fea2ee34.zip/node_modules/next/dist/compiled/react/index.js\");\nfunction normalizeRouterState(val) {\n    if (val instanceof Map) {\n        var obj = {};\n        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n        try {\n            for(var _iterator = val.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n                var _value = _slicedToArray(_step.value, 2), key = _value[0], value = _value[1];\n                if (typeof value === \"function\") {\n                    obj[key] = \"fn()\";\n                    continue;\n                }\n                if (typeof value === \"object\" && value !== null) {\n                    if (value.$$typeof) {\n                        obj[key] = value.$$typeof.toString();\n                        continue;\n                    }\n                    if (value._bundlerConfig) {\n                        obj[key] = \"FlightData\";\n                        continue;\n                    }\n                }\n                obj[key] = normalizeRouterState(value);\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally{\n            try {\n                if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n                    _iterator[\"return\"]();\n                }\n            } finally{\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n        return obj;\n    }\n    if (typeof val === \"object\" && val !== null) {\n        var obj1 = {};\n        for(var key1 in val){\n            var value1 = val[key1];\n            if (typeof value1 === \"function\") {\n                obj1[key1] = \"fn()\";\n                continue;\n            }\n            if (typeof value1 === \"object\" && value1 !== null) {\n                if (value1.$$typeof) {\n                    obj1[key1] = value1.$$typeof.toString();\n                    continue;\n                }\n                if (value1.hasOwnProperty(\"_bundlerConfig\")) {\n                    obj1[key1] = \"FlightData\";\n                    continue;\n                }\n            }\n            obj1[key1] = normalizeRouterState(value1);\n        }\n        return obj1;\n    }\n    if (Array.isArray(val)) {\n        return val.map(normalizeRouterState);\n    }\n    return val;\n}\nfunction devToolReducer(fn, ref) {\n    return function(state, action) {\n        var res = fn(state, action);\n        if (ref.current) {\n            ref.current.send(action, normalizeRouterState(res));\n        }\n        return res;\n    };\n}\nfunction useReducerWithReduxDevtoolsNoop(fn, initialState) {\n    _s();\n    var ref = _slicedToArray((0, _react).useReducer(fn, initialState), 2), state = ref[0], dispatch = ref[1];\n    return [\n        state,\n        dispatch,\n        function() {}\n    ];\n}\n_s(useReducerWithReduxDevtoolsNoop, \"6JWkGZ32UPfojeNx+xqn8ZU8A0Q=\");\nfunction useReducerWithReduxDevtoolsImpl(fn, initialState) {\n    _s1();\n    var devtoolsConnectionRef = (0, _react).useRef();\n    var enabledRef = (0, _react).useRef();\n    (0, _react).useEffect(function() {\n        if (devtoolsConnectionRef.current || enabledRef.current === false) {\n            return;\n        }\n        if (enabledRef.current === undefined && typeof window.__REDUX_DEVTOOLS_EXTENSION__ === \"undefined\") {\n            enabledRef.current = false;\n            return;\n        }\n        devtoolsConnectionRef.current = window.__REDUX_DEVTOOLS_EXTENSION__.connect({\n            instanceId: 1,\n            name: \"next-router\"\n        });\n        if (devtoolsConnectionRef.current) {\n            devtoolsConnectionRef.current.init(normalizeRouterState(initialState));\n        }\n        return function() {\n            devtoolsConnectionRef.current = undefined;\n        };\n    }, [\n        initialState\n    ]);\n    var ref = _slicedToArray((0, _react).useReducer(devToolReducer(/* logReducer( */ fn /*)*/ , devtoolsConnectionRef), initialState), 2), state = ref[0], dispatch = ref[1];\n    var sync = (0, _react).useCallback(function() {\n        if (devtoolsConnectionRef.current) {\n            devtoolsConnectionRef.current.send({\n                type: \"RENDER_SYNC\"\n            }, normalizeRouterState(state));\n        }\n    }, [\n        state\n    ]);\n    return [\n        state,\n        dispatch,\n        sync\n    ];\n}\n_s1(useReducerWithReduxDevtoolsImpl, \"pLR6zS9fUqATAvEc1j249W8BDm8=\");\nvar useReducerWithReduxDevtools =  true ? useReducerWithReduxDevtoolsImpl : 0;\nexports.useReducerWithReduxDevtools = useReducerWithReduxDevtools;\nif ((typeof exports[\"default\"] === \"function\" || typeof exports[\"default\"] === \"object\" && exports[\"default\"] !== null) && typeof exports[\"default\"].__esModule === \"undefined\") {\n    Object.defineProperty(exports[\"default\"], \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports[\"default\"], exports);\n    module.exports = exports[\"default\"];\n} //# sourceMappingURL=use-reducer-with-devtools.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi8ueWFybi9fX3ZpcnR1YWxfXy9uZXh0LXZpcnR1YWwtMzkzZDkxYmJjZC8wL2NhY2hlL25leHQtbnBtLTEzLjAuMi1iMzlhYmQyMmQwLWY2ZmVhMmVlMzQuemlwL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvdXNlLXJlZHVjZXItd2l0aC1kZXZ0b29scy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELG1DQUFtQyxHQUFHLEtBQUs7QUFDM0MsSUFBSUcsU0FBU0MsbUJBQU9BLENBQUMsMkpBQU87QUFDNUIsU0FBU0MscUJBQXFCQyxHQUFHLEVBQUU7SUFDL0IsSUFBSUEsZUFBZUMsS0FBSztRQUNwQixJQUFNQyxNQUFNLENBQUM7WUFDUjs7WUFBTCxRQUFLLFlBQXNCRixJQUFJRyxPQUFPLHVCQUFqQyx3R0FBb0M7Z0JBQXBDLDZDQUFPQyxpQkFBS1Q7Z0JBQ2IsSUFBSSxPQUFPQSxVQUFVLFlBQVk7b0JBQzdCTyxHQUFHLENBQUNFLElBQUksR0FBRztvQkFDWCxRQUFTO2dCQUNiLENBQUM7Z0JBQ0QsSUFBSSxPQUFPVCxVQUFVLFlBQVlBLFVBQVUsSUFBSSxFQUFFO29CQUM3QyxJQUFJQSxNQUFNVSxRQUFRLEVBQUU7d0JBQ2hCSCxHQUFHLENBQUNFLElBQUksR0FBR1QsTUFBTVUsUUFBUSxDQUFDQyxRQUFRO3dCQUNsQyxRQUFTO29CQUNiLENBQUM7b0JBQ0QsSUFBSVgsTUFBTVksY0FBYyxFQUFFO3dCQUN0QkwsR0FBRyxDQUFDRSxJQUFJLEdBQUc7d0JBQ1gsUUFBUztvQkFDYixDQUFDO2dCQUNMLENBQUM7Z0JBQ0RGLEdBQUcsQ0FBQ0UsSUFBSSxHQUFHTCxxQkFBcUJKO1lBQ3BDOztZQWhCSztZQUFBOzs7cUJBQUE7b0JBQUE7OztvQkFBQTswQkFBQTs7OztRQWlCTCxPQUFPTztJQUNYLENBQUM7SUFDRCxJQUFJLE9BQU9GLFFBQVEsWUFBWUEsUUFBUSxJQUFJLEVBQUU7UUFDekMsSUFBTUUsT0FBTSxDQUFDO1FBQ2IsSUFBSSxJQUFNRSxRQUFPSixJQUFJO1lBQ2pCLElBQU1MLFNBQVFLLEdBQUcsQ0FBQ0ksS0FBSTtZQUN0QixJQUFJLE9BQU9ULFdBQVUsWUFBWTtnQkFDN0JPLElBQUcsQ0FBQ0UsS0FBSSxHQUFHO2dCQUNYLFFBQVM7WUFDYixDQUFDO1lBQ0QsSUFBSSxPQUFPVCxXQUFVLFlBQVlBLFdBQVUsSUFBSSxFQUFFO2dCQUM3QyxJQUFJQSxPQUFNVSxRQUFRLEVBQUU7b0JBQ2hCSCxJQUFHLENBQUNFLEtBQUksR0FBR1QsT0FBTVUsUUFBUSxDQUFDQyxRQUFRO29CQUNsQyxRQUFTO2dCQUNiLENBQUM7Z0JBQ0QsSUFBSVgsT0FBTWEsY0FBYyxDQUFDLG1CQUFtQjtvQkFDeENOLElBQUcsQ0FBQ0UsS0FBSSxHQUFHO29CQUNYLFFBQVM7Z0JBQ2IsQ0FBQztZQUNMLENBQUM7WUFDREYsSUFBRyxDQUFDRSxLQUFJLEdBQUdMLHFCQUFxQko7UUFDcEM7UUFDQSxPQUFPTztJQUNYLENBQUM7SUFDRCxJQUFJTyxNQUFNQyxPQUFPLENBQUNWLE1BQU07UUFDcEIsT0FBT0EsSUFBSVcsR0FBRyxDQUFDWjtJQUNuQixDQUFDO0lBQ0QsT0FBT0M7QUFDWDtBQUNBLFNBQVNZLGVBQWVDLEVBQUUsRUFBRUMsR0FBRyxFQUFFO0lBQzdCLE9BQU8sU0FBQ0MsT0FBT0MsUUFBUztRQUNwQixJQUFNQyxNQUFNSixHQUFHRSxPQUFPQztRQUN0QixJQUFJRixJQUFJSSxPQUFPLEVBQUU7WUFDYkosSUFBSUksT0FBTyxDQUFDQyxJQUFJLENBQUNILFFBQVFqQixxQkFBcUJrQjtRQUNsRCxDQUFDO1FBQ0QsT0FBT0E7SUFDWDtBQUNKO0FBQ0EsU0FBU0csZ0NBQWdDUCxFQUFFLEVBQUVRLFlBQVksRUFBRTs7SUFDdkQsSUFBMEIsc0JBQUMsR0FBR3hCLE1BQU0sRUFBRXlCLFVBQVUsQ0FBQ1QsSUFBSVEsbUJBQTlDTixRQUFtQixRQUFaUSxXQUFZO0lBQzFCLE9BQU87UUFDSFI7UUFDQVE7UUFDQSxXQUFJLENBQUM7S0FDUjtBQUNMO0dBUFNIO0FBUVQsU0FBU0ksZ0NBQWdDWCxFQUFFLEVBQUVRLFlBQVksRUFBRTs7SUFDdkQsSUFBTUksd0JBQXdCLENBQUMsR0FBRzVCLE1BQU0sRUFBRTZCLE1BQU07SUFDaEQsSUFBTUMsYUFBYSxDQUFDLEdBQUc5QixNQUFNLEVBQUU2QixNQUFNO0lBQ3BDLElBQUc3QixNQUFNLEVBQUUrQixTQUFTLENBQUMsV0FBSTtRQUN0QixJQUFJSCxzQkFBc0JQLE9BQU8sSUFBSVMsV0FBV1QsT0FBTyxLQUFLLEtBQUssRUFBRTtZQUMvRDtRQUNKLENBQUM7UUFDRCxJQUFJUyxXQUFXVCxPQUFPLEtBQUtXLGFBQWEsT0FBT0MsT0FBT0MsNEJBQTRCLEtBQUssYUFBYTtZQUNoR0osV0FBV1QsT0FBTyxHQUFHLEtBQUs7WUFDMUI7UUFDSixDQUFDO1FBQ0RPLHNCQUFzQlAsT0FBTyxHQUFHWSxPQUFPQyw0QkFBNEIsQ0FBQ0MsT0FBTyxDQUFDO1lBQ3hFQyxZQUFZO1lBQ1pDLE1BQU07UUFDVjtRQUNBLElBQUlULHNCQUFzQlAsT0FBTyxFQUFFO1lBQy9CTyxzQkFBc0JQLE9BQU8sQ0FBQ2lCLElBQUksQ0FBQ3BDLHFCQUFxQnNCO1FBQzVELENBQUM7UUFDRCxPQUFPLFdBQUk7WUFDUEksc0JBQXNCUCxPQUFPLEdBQUdXO1FBQ3BDO0lBQ0osR0FBRztRQUNDUjtLQUNIO0lBQ0QsSUFBMEIsc0JBQUMsR0FBR3hCLE1BQU0sRUFBRXlCLFVBQVUsQ0FBQ1YsZUFBZSxlQUFlLEdBQUdDLEdBQUcsR0FBRyxLQUFLWSx3QkFBd0JKLG1CQUE5R04sUUFBbUIsUUFBWlEsV0FBWTtJQUMxQixJQUFNYSxPQUFPLENBQUMsR0FBR3ZDLE1BQU0sRUFBRXdDLFdBQVcsQ0FBQyxXQUFJO1FBQ3JDLElBQUlaLHNCQUFzQlAsT0FBTyxFQUFFO1lBQy9CTyxzQkFBc0JQLE9BQU8sQ0FBQ0MsSUFBSSxDQUFDO2dCQUMvQm1CLE1BQU07WUFDVixHQUFHdkMscUJBQXFCZ0I7UUFDNUIsQ0FBQztJQUNMLEdBQUc7UUFDQ0E7S0FDSDtJQUNELE9BQU87UUFDSEE7UUFDQVE7UUFDQWE7S0FDSDtBQUNMO0lBdkNTWjtBQXdDVCxJQUFNNUIsOEJBQThCLEtBQWtCLEdBQWM0QixrQ0FBa0NKLENBQStCO0FBQ3JJMUIsbUNBQW1DLEdBQUdFO0FBRXRDLElBQUksQ0FBQyxPQUFPRixPQUFRNkMsQ0FBQUEsVUFBTyxLQUFLLGNBQWUsT0FBTzdDLE9BQVE2QyxDQUFBQSxVQUFPLEtBQUssWUFBWTdDLE9BQVE2QyxDQUFBQSxVQUFPLEtBQUssSUFBSSxLQUFNLE9BQU83QyxPQUFRNkMsQ0FBQUEsVUFBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS2hELE9BQU9DLGNBQWMsQ0FBQ0MsT0FBUTZDLENBQUFBLFVBQU8sRUFBRSxjQUFjO1FBQUU1QyxPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT2lELE1BQU0sQ0FBQy9DLE9BQVE2QyxDQUFBQSxVQUFPLEVBQUU3QztJQUMvQmdELE9BQU9oRCxPQUFPLEdBQUdBLE9BQVE2QyxDQUFBQSxVQUFPO0FBQ2xDLENBQUMsQ0FFRCxxREFBcUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vLnlhcm4vX192aXJ0dWFsX18vbmV4dC12aXJ0dWFsLTM5M2Q5MWJiY2QvMC9jYWNoZS9uZXh0LW5wbS0xMy4wLjItYjM5YWJkMjJkMC1mNmZlYTJlZTM0LnppcC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3VzZS1yZWR1Y2VyLXdpdGgtZGV2dG9vbHMuanM/Mjg3ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMudXNlUmVkdWNlcldpdGhSZWR1eERldnRvb2xzID0gdm9pZCAwO1xudmFyIF9yZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZVJvdXRlclN0YXRlKHZhbCkge1xuICAgIGlmICh2YWwgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHZhbC5lbnRyaWVzKCkpe1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIG9ialtrZXldID0gJ2ZuKCknO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqW2tleV0gPSB2YWx1ZS4kJHR5cGVvZi50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLl9idW5kbGVyQ29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gJ0ZsaWdodERhdGEnO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvYmpba2V5XSA9IG5vcm1hbGl6ZVJvdXRlclN0YXRlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBmb3IoY29uc3Qga2V5IGluIHZhbCl7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbFtrZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIG9ialtrZXldID0gJ2ZuKCknO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqW2tleV0gPSB2YWx1ZS4kJHR5cGVvZi50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLmhhc093blByb3BlcnR5KCdfYnVuZGxlckNvbmZpZycpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gJ0ZsaWdodERhdGEnO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvYmpba2V5XSA9IG5vcm1hbGl6ZVJvdXRlclN0YXRlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIHJldHVybiB2YWwubWFwKG5vcm1hbGl6ZVJvdXRlclN0YXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbn1cbmZ1bmN0aW9uIGRldlRvb2xSZWR1Y2VyKGZuLCByZWYpIHtcbiAgICByZXR1cm4gKHN0YXRlLCBhY3Rpb24pPT57XG4gICAgICAgIGNvbnN0IHJlcyA9IGZuKHN0YXRlLCBhY3Rpb24pO1xuICAgICAgICBpZiAocmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJlZi5jdXJyZW50LnNlbmQoYWN0aW9uLCBub3JtYWxpemVSb3V0ZXJTdGF0ZShyZXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG59XG5mdW5jdGlvbiB1c2VSZWR1Y2VyV2l0aFJlZHV4RGV2dG9vbHNOb29wKGZuLCBpbml0aWFsU3RhdGUpIHtcbiAgICBjb25zdCBbc3RhdGUsIGRpc3BhdGNoXSA9ICgwLCBfcmVhY3QpLnVzZVJlZHVjZXIoZm4sIGluaXRpYWxTdGF0ZSk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIGRpc3BhdGNoLFxuICAgICAgICAoKT0+e31cbiAgICBdO1xufVxuZnVuY3Rpb24gdXNlUmVkdWNlcldpdGhSZWR1eERldnRvb2xzSW1wbChmbiwgaW5pdGlhbFN0YXRlKSB7XG4gICAgY29uc3QgZGV2dG9vbHNDb25uZWN0aW9uUmVmID0gKDAsIF9yZWFjdCkudXNlUmVmKCk7XG4gICAgY29uc3QgZW5hYmxlZFJlZiA9ICgwLCBfcmVhY3QpLnVzZVJlZigpO1xuICAgICgwLCBfcmVhY3QpLnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICBpZiAoZGV2dG9vbHNDb25uZWN0aW9uUmVmLmN1cnJlbnQgfHwgZW5hYmxlZFJlZi5jdXJyZW50ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmFibGVkUmVmLmN1cnJlbnQgPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX18gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBlbmFibGVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkZXZ0b29sc0Nvbm5lY3Rpb25SZWYuY3VycmVudCA9IHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9fLmNvbm5lY3Qoe1xuICAgICAgICAgICAgaW5zdGFuY2VJZDogMSxcbiAgICAgICAgICAgIG5hbWU6ICduZXh0LXJvdXRlcidcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChkZXZ0b29sc0Nvbm5lY3Rpb25SZWYuY3VycmVudCkge1xuICAgICAgICAgICAgZGV2dG9vbHNDb25uZWN0aW9uUmVmLmN1cnJlbnQuaW5pdChub3JtYWxpemVSb3V0ZXJTdGF0ZShpbml0aWFsU3RhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIGRldnRvb2xzQ29ubmVjdGlvblJlZi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgaW5pdGlhbFN0YXRlXG4gICAgXSk7XG4gICAgY29uc3QgW3N0YXRlLCBkaXNwYXRjaF0gPSAoMCwgX3JlYWN0KS51c2VSZWR1Y2VyKGRldlRvb2xSZWR1Y2VyKC8qIGxvZ1JlZHVjZXIoICovIGZuIC8qKSovICwgZGV2dG9vbHNDb25uZWN0aW9uUmVmKSwgaW5pdGlhbFN0YXRlKTtcbiAgICBjb25zdCBzeW5jID0gKDAsIF9yZWFjdCkudXNlQ2FsbGJhY2soKCk9PntcbiAgICAgICAgaWYgKGRldnRvb2xzQ29ubmVjdGlvblJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBkZXZ0b29sc0Nvbm5lY3Rpb25SZWYuY3VycmVudC5zZW5kKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnUkVOREVSX1NZTkMnXG4gICAgICAgICAgICB9LCBub3JtYWxpemVSb3V0ZXJTdGF0ZShzdGF0ZSkpO1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBzdGF0ZVxuICAgIF0pO1xuICAgIHJldHVybiBbXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBkaXNwYXRjaCxcbiAgICAgICAgc3luY1xuICAgIF07XG59XG5jb25zdCB1c2VSZWR1Y2VyV2l0aFJlZHV4RGV2dG9vbHMgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHVzZVJlZHVjZXJXaXRoUmVkdXhEZXZ0b29sc0ltcGwgOiB1c2VSZWR1Y2VyV2l0aFJlZHV4RGV2dG9vbHNOb29wO1xuZXhwb3J0cy51c2VSZWR1Y2VyV2l0aFJlZHV4RGV2dG9vbHMgPSB1c2VSZWR1Y2VyV2l0aFJlZHV4RGV2dG9vbHM7XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1yZWR1Y2VyLXdpdGgtZGV2dG9vbHMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwidXNlUmVkdWNlcldpdGhSZWR1eERldnRvb2xzIiwiX3JlYWN0IiwicmVxdWlyZSIsIm5vcm1hbGl6ZVJvdXRlclN0YXRlIiwidmFsIiwiTWFwIiwib2JqIiwiZW50cmllcyIsImtleSIsIiQkdHlwZW9mIiwidG9TdHJpbmciLCJfYnVuZGxlckNvbmZpZyIsImhhc093blByb3BlcnR5IiwiQXJyYXkiLCJpc0FycmF5IiwibWFwIiwiZGV2VG9vbFJlZHVjZXIiLCJmbiIsInJlZiIsInN0YXRlIiwiYWN0aW9uIiwicmVzIiwiY3VycmVudCIsInNlbmQiLCJ1c2VSZWR1Y2VyV2l0aFJlZHV4RGV2dG9vbHNOb29wIiwiaW5pdGlhbFN0YXRlIiwidXNlUmVkdWNlciIsImRpc3BhdGNoIiwidXNlUmVkdWNlcldpdGhSZWR1eERldnRvb2xzSW1wbCIsImRldnRvb2xzQ29ubmVjdGlvblJlZiIsInVzZVJlZiIsImVuYWJsZWRSZWYiLCJ1c2VFZmZlY3QiLCJ1bmRlZmluZWQiLCJ3aW5kb3ciLCJfX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9fIiwiY29ubmVjdCIsImluc3RhbmNlSWQiLCJuYW1lIiwiaW5pdCIsInN5bmMiLCJ1c2VDYWxsYmFjayIsInR5cGUiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./.yarn/__virtual__/next-virtual-393d91bbcd/0/cache/next-npm-13.0.2-b39abd22d0-f6fea2ee34.zip/node_modules/next/dist/client/components/use-reducer-with-devtools.js\n"));

/***/ })

});